[
    {
        "id": "67ce124139a68312",
        "type": "tab",
        "label": "globalAssets",
        "disabled": false,
        "info": ""
    },
    {
        "id": "5fa172c20f49443b",
        "type": "tab",
        "label": "mainCalc",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "25ffd91f1979976d",
        "type": "tab",
        "label": "chatGPT",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "6fd22f15cd2422d0",
        "type": "tab",
        "label": "feedbackTest",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "b326d8d077e77e7a",
        "type": "tab",
        "label": "multiAIFlow",
        "disabled": false,
        "info": ""
    },
    {
        "id": "ecd378f1d3401d0d",
        "type": "tab",
        "label": "working feedback",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "ac96ed0192970f1b",
        "type": "tab",
        "label": "noderedAPI",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "dynamicCmdSubflow",
        "type": "subflow",
        "name": "Dynamic Command Processor",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 220,
                "y": 120,
                "wires": [
                    {
                        "id": "inputHandler"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 1480,
                "y": 180,
                "wires": [
                    {
                        "id": "1c1bc00d9a8c86d6",
                        "port": 0
                    },
                    {
                        "id": "94b392982f53c55a",
                        "port": 0
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "817a5b2b5a30223d",
        "type": "subflow",
        "name": "Working Dynamic Command Processor",
        "info": "",
        "category": "",
        "in": [
            {
                "x": 200,
                "y": 100,
                "wires": [
                    {
                        "id": "8b7fda62adc7c26d"
                    }
                ]
            }
        ],
        "out": [
            {
                "x": 900,
                "y": 360,
                "wires": [
                    {
                        "id": "731b22dc42e1a59e",
                        "port": 0
                    }
                ]
            },
            {
                "x": 900,
                "y": 400,
                "wires": [
                    {
                        "id": "731b22dc42e1a59e",
                        "port": 1
                    }
                ]
            },
            {
                "x": 900,
                "y": 460,
                "wires": [
                    {
                        "id": "731b22dc42e1a59e",
                        "port": 2
                    }
                ]
            }
        ],
        "env": [],
        "meta": {},
        "color": "#DDAA99"
    },
    {
        "id": "db1664ca19e007e4",
        "type": "group",
        "z": "5fa172c20f49443b",
        "name": "Global Settings Load",
        "style": {
            "fill": "#d1d1d1",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "a0e98eb9e64d9cd6",
            "4a45cc485f644505",
            "e5dcf619beeb6d82",
            "3a76cd70a0954887",
            "ce4d24263c44e46c",
            "5926f857c39fa7f8",
            "a9efc5167470cd12",
            "97dedff557300f31",
            "29ee4f96d6e5d988",
            "fa59f6c4d6ce4b69"
        ],
        "x": 354,
        "y": 219,
        "w": 1512,
        "h": 162
    },
    {
        "id": "b93dd9f1ed02b46a",
        "type": "group",
        "z": "5fa172c20f49443b",
        "name": "SortedBetsCheck",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#d1d1d1"
        },
        "nodes": [
            "dd2f628224cbb4c3",
            "b7f2bcc8b657be27",
            "803b92c8ed55dc13",
            "7f099d933bceb328"
        ],
        "x": 348,
        "y": 419,
        "w": 1524,
        "h": 708
    },
    {
        "id": "4126bd8cd63414e5",
        "type": "group",
        "z": "5fa172c20f49443b",
        "name": "BetInputCheck",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#d1d1d1"
        },
        "nodes": [
            "9e02f8f5e79de5a0",
            "bf94ecd062e4e70d",
            "907bb0adef74d85a",
            "3172a5061aab2782",
            "8dde91e674783ac8",
            "82f37f0f6985ba34"
        ],
        "x": 1918,
        "y": 419,
        "w": 1534,
        "h": 768
    },
    {
        "id": "6894234cd3cf5d07",
        "type": "group",
        "z": "b326d8d077e77e7a",
        "name": "Short Task Loop",
        "style": {
            "fill": "#e3f3d3",
            "label": true
        },
        "nodes": [
            "1638a67c56865971",
            "8b89f329a82bfed6",
            "77f2f541c83fdbc3",
            "a7d8108a4e153280",
            "c4c16bdf71735fe1",
            "4a2c4610f96ec367",
            "837ca3dddd6d3f88"
        ],
        "x": 474,
        "y": 539,
        "w": 692,
        "h": 222
    },
    {
        "id": "c803e0682d074b98",
        "type": "group",
        "z": "b326d8d077e77e7a",
        "name": "Short Task Loop",
        "style": {
            "fill": "#e3f3d3",
            "label": true
        },
        "nodes": [
            "f7833adb07fe5494",
            "58e089ec8917c51c",
            "96d76c6fe0e4d003",
            "c097527e1ff7411a",
            "ef5902f3dabd7fff",
            "5e1437b93e12f451",
            "724c55b43495a9e4"
        ],
        "x": 1194,
        "y": 539,
        "w": 692,
        "h": 222
    },
    {
        "id": "99c77abbc117cf9f",
        "type": "group",
        "z": "b326d8d077e77e7a",
        "name": "Fine Tune & Debug Loop",
        "style": {
            "fill": "#e3f3d3",
            "label": true
        },
        "nodes": [
            "dc807127b4407f93",
            "5099ba28e81c2373",
            "ad20311fd2c73a10",
            "99c5558fb42f69fc",
            "83e01b980d591a8c",
            "7c015af7f9489466",
            "995ad83b99377710"
        ],
        "x": 1194,
        "y": 779,
        "w": 692,
        "h": 222
    },
    {
        "id": "4797c7b0a9eb125d",
        "type": "group",
        "z": "b326d8d077e77e7a",
        "name": "Review for errors; edge cases",
        "style": {
            "fill": "#e3f3d3",
            "label": true
        },
        "nodes": [
            "0713676a3c782313",
            "c4e873678cb4c841",
            "57a2da1d197a98db",
            "ac30414c6655dd06",
            "d8a4a809a1dcaad1",
            "f322d3b239caa967",
            "107a09284f0dc8c6"
        ],
        "x": 474,
        "y": 779,
        "w": 692,
        "h": 222
    },
    {
        "id": "ad9ab3ccb98c5479",
        "type": "group",
        "z": "25ffd91f1979976d",
        "name": "Start Chrome",
        "style": {
            "fill": "#d1d1d1",
            "label": true
        },
        "nodes": [
            "50b5ebf17c38bd1c",
            "288cc212527de778",
            "e0f37b3e31c3903c",
            "47dc79bad9bac696",
            "41c65bc386f2efd0",
            "9d108a65765227a4",
            "6df159f6597c93d8",
            "c05684c26ae329fa",
            "0a1fb772d6168db0",
            "605afeb07790bcef"
        ],
        "x": 334,
        "y": 79,
        "w": 992,
        "h": 282
    },
    {
        "id": "800948336d4baaaa",
        "type": "group",
        "z": "6fd22f15cd2422d0",
        "name": "Start Chrome",
        "style": {
            "fill": "#d1d1d1",
            "label": true
        },
        "nodes": [
            "31b8288b02620cfb",
            "d058aac6d68b73c4",
            "1f102993cb2cd091",
            "4df1f5d4059f8e19",
            "d11e099b958aeb59",
            "529ac81730214a31",
            "cd155de25c64c785",
            "99fe35068c9a6c78",
            "0fa9e9c17cfacb08",
            "2aaa4823845f8d59"
        ],
        "x": 434,
        "y": 119,
        "w": 1012,
        "h": 282
    },
    {
        "id": "d8cc715c64703cde",
        "type": "group",
        "z": "6fd22f15cd2422d0",
        "name": "Read Logs",
        "style": {
            "label": true,
            "fill": "#d1d1d1"
        },
        "nodes": [
            "1cdad3d653c0e5fa",
            "51e86c26bd777951",
            "525ededf5411f55d",
            "458713510b3edb94",
            "27692842a0727548"
        ],
        "x": 414,
        "y": 479,
        "w": 1012,
        "h": 182
    },
    {
        "id": "abb6cb8cc176530d",
        "type": "group",
        "z": "6fd22f15cd2422d0",
        "name": "Feedback Loop",
        "style": {
            "label": true,
            "fill": "#d1d1d1"
        },
        "nodes": [
            "fa21567ba22fdb93",
            "71c927bf29b50bd2",
            "eca15312159d4910",
            "9ff7d5131f370507",
            "a593028ef3f4668a",
            "a5f31990c3510d5f"
        ],
        "x": 414,
        "y": 759,
        "w": 1072,
        "h": 142
    },
    {
        "id": "7b7c1084c38a93ca",
        "type": "group",
        "z": "ecd378f1d3401d0d",
        "name": "Read Logs",
        "style": {
            "label": true,
            "fill": "#d1d1d1"
        },
        "nodes": [
            "8b79eb7951f13d35",
            "1f9e9648a6fdea3e",
            "eb2951843983362b",
            "4490085b05c634e4",
            "3819d7a1bb987cd4"
        ],
        "x": 254,
        "y": 79,
        "w": 972,
        "h": 182
    },
    {
        "id": "25b6777d38d17718",
        "type": "group",
        "z": "ecd378f1d3401d0d",
        "name": "Feedback Loop",
        "style": {
            "label": true,
            "fill": "#d1d1d1"
        },
        "nodes": [
            "c1e5648ebbc40637",
            "ecb21505f2b71198",
            "7735c94e771bdaf5",
            "a142d35aa4e7a75c",
            "f808f68ecb565594",
            "cebfdb8ca306df09",
            "0121c003d821a526",
            "4f260a029e80f953"
        ],
        "x": 254,
        "y": 351.5,
        "w": 1072,
        "h": 297
    },
    {
        "id": "1e5068284c73d985",
        "type": "group",
        "z": "6fd22f15cd2422d0",
        "name": "Feedback Loop",
        "style": {
            "label": true,
            "fill": "#d1d1d1"
        },
        "nodes": [
            "0f16fc5b36d46fd6",
            "0c1dbed619779ab1",
            "59ed5a547f573b39",
            "3f22537a06d38167",
            "191dd36382069a70",
            "96d8b069f61a302a",
            "9d05e7471fb032a1",
            "7a0a725cdb252858"
        ],
        "x": 414,
        "y": 1299,
        "w": 1072,
        "h": 269.5
    },
    {
        "id": "dd2f628224cbb4c3",
        "type": "group",
        "z": "5fa172c20f49443b",
        "g": "b93dd9f1ed02b46a",
        "name": "SortedBetsCheck: Ph1 Extract",
        "style": {
            "fill": "#e3f3d3",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "3849cc7df492b362",
            "a16a17c27bd71bd6",
            "16001f67efa309e1",
            "81f5f6ed3582f4a7",
            "1fe4967103d1edc8",
            "3f833d99e1e7b34b",
            "7e905be2ddbf209f",
            "5bd19c03c084c56e",
            "6a4c7c8a5d485e67",
            "79223214381a0e94",
            "c4b93446aa230ff6",
            "4ca12deadd3be409"
        ],
        "x": 374,
        "y": 499,
        "w": 1452,
        "h": 202
    },
    {
        "id": "b7f2bcc8b657be27",
        "type": "group",
        "z": "5fa172c20f49443b",
        "g": "b93dd9f1ed02b46a",
        "name": "SortedBetsCheck: Ph2 Transform",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#ffffbf"
        },
        "nodes": [
            "8c83108e97fb0cd2",
            "651a04261d7b2c0e",
            "c99ea954399ff73e",
            "6aa833b66249717c",
            "6eb1d3bdf91d9769",
            "6de8c17c083cb8f4",
            "fb9fbb9ae42710bd",
            "c59ac708faab91cb",
            "f617a066e7adfd41",
            "273cefe442d4e299",
            "6c93cf3ab8ccd07f"
        ],
        "x": 374,
        "y": 739,
        "w": 1472,
        "h": 202
    },
    {
        "id": "803b92c8ed55dc13",
        "type": "group",
        "z": "5fa172c20f49443b",
        "g": "b93dd9f1ed02b46a",
        "name": "SortedBetsCheck: Ph3 Load",
        "style": {
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "118cd677cd25eb05",
            "75d6aaab0021d346",
            "3bdb39087ef4d457",
            "62e4b98de6625a13"
        ],
        "x": 374,
        "y": 959,
        "w": 1462,
        "h": 142
    },
    {
        "id": "9e02f8f5e79de5a0",
        "type": "group",
        "z": "5fa172c20f49443b",
        "g": "4126bd8cd63414e5",
        "name": "BetInputCheck: Ph1 Extract",
        "style": {
            "fill": "#e3f3d3",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "272b6d76a23994ba",
            "3b7490b20fbb7087",
            "bd4fd4d1e09d770b",
            "74c06399d74963b0",
            "f4d0bfed3d6727e6",
            "5f817b78b5dfe714",
            "fb5587b589c5cd32",
            "24c74fc74752908c",
            "054adb80f90a06e5"
        ],
        "x": 1954,
        "y": 479,
        "w": 1432,
        "h": 162
    },
    {
        "id": "bf94ecd062e4e70d",
        "type": "group",
        "z": "5fa172c20f49443b",
        "g": "4126bd8cd63414e5",
        "name": "BetInputCheck: Ph2 Transform",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#ffffbf"
        },
        "nodes": [
            "9d42e07bd472374f",
            "aab5da598ff97b79",
            "6d7830c85b50c511",
            "b4dca9fd7958c13f",
            "12551b69148dc875",
            "18ee888a0e0c3587",
            "740d874372634aa9",
            "b753d113f1e07d62",
            "aa6c72150d31fb90",
            "148caedec77ae2dc",
            "7f404f5ee3444148"
        ],
        "x": 1944,
        "y": 799,
        "w": 1462,
        "h": 202
    },
    {
        "id": "907bb0adef74d85a",
        "type": "group",
        "z": "5fa172c20f49443b",
        "g": "4126bd8cd63414e5",
        "name": "BetInputCheck: Ph3 Load",
        "style": {
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "844825e531e70a8c",
            "8e05a6c56f99c187",
            "2e4fb60325f287ea",
            "37c361494a477963"
        ],
        "x": 1944,
        "y": 1019,
        "w": 1482,
        "h": 142
    },
    {
        "id": "e2bc7ac9aa77279e",
        "type": "mongodb4-client",
        "name": "Basic Connection",
        "protocol": "mongodb",
        "hostname": "http://127.0.0.1",
        "port": "22000",
        "dbName": "CimaMain",
        "appName": "",
        "authSource": "admin",
        "authMechanism": "SCRAM-SHA-256",
        "tls": false,
        "tlsCAFile": "",
        "tlsCertificateKeyFile": "",
        "tlsInsecure": false,
        "connectTimeoutMS": "",
        "socketTimeoutMS": "",
        "minPoolSize": "",
        "maxPoolSize": "",
        "maxIdleTimeMS": "",
        "uri": "mongodb://127.0.0.1:22000",
        "advanced": "{\"connectTimeoutMS\": 30000}",
        "uriTabActive": "tab-uri-advanced"
    },
    {
        "id": "df8a615d6d2cd2e7",
        "type": "websocket-listener",
        "path": "/ws/BetInputCheck",
        "wholemsg": "false"
    },
    {
        "id": "d21e854a8cd56e18",
        "type": "jsonlogic_engine",
        "z": "dynamicCmdSubflow",
        "name": "",
        "methods": ""
    },
    {
        "id": "inputHandler",
        "type": "function",
        "z": "dynamicCmdSubflow",
        "name": "inputConditionals",
        "func": "// Input Handler\nconst flowContext = flow.get('flowContext') || {};\n\n// Update the latest message\nflowContext.latestMsg = msg;\nflow.set('flowContext', flowContext);\n\nconsole.log(\"[inputConditionals] Starting inputConditionals function.\");\nconsole.log(`[inputConditionals] Input msg: ${JSON.stringify(msg)}`);\n\n// Case: Stop message\nif (msg.promptSectionContext && msg.promptSectionContext.status === \"stop\") {\n    console.log(\"[inputConditionals] Received stop message.\");\n    // Send stop message to all outputs\n    return;\n}\n\n// Case: Default non-dynamicCmd\nelse if (msg.promptSectionContext &&\n    typeof msg.promptSectionContext.currentStep === 'number' &&\n    typeof msg.promptSectionContext.totalSteps === 'number') {\n    console.log(\"[inputConditionals] Received default non-dynamicCmd message.\");\n    // Send to mainProcessor (output1)\n    node.send([msg]);\n}\n\n// Case: dynamicCmd message\nelse if (msg.dynamicCmdContext && msg.dynamicCmdContext.dynamicCmd === true) {\n    console.log(\"[inputConditionals] Received dynamicCmd message.\");\n    // Send dynamicCmd messages to mainProcessor (output1)\n    node.send([msg]);\n}\n\n// If none of the above conditions are met\nelse {\n    console.log(\"[inputConditionals] Message didn't meet any conditions.\");\n}\n\nreturn\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 430,
        "y": 180,
        "wires": [
            [
                "1c1bc00d9a8c86d6"
            ]
        ],
        "info": "# processMessage Function Breakdown\r\n\r\n## 1. Input Phase\r\n- **Always executed**\r\n- Update `flowContext` with latest message\r\n- Log function start and input message\r\n\r\n## 2. Processing Phase\r\n\r\n### Case 1: Regular message (most common)\r\n- **Condition:** Message doesn't meet any special conditions\r\n- **Action:** Pass message through unchanged\r\n- **Output:** First output (index 0)\r\n\r\n### Case 2: dynamicCmd message (common)\r\n- **Condition:** `msg.payload` exists, is a string, and contains \"dynamicCmd\"\r\n- **Action:** Pass message through unchanged\r\n- **Output:** First output (index 0)\r\n\r\n### Case 3: sidePrompt completion (less common)\r\n- **Condition:** `msg.sidePromptStatus` equals \"done\"\r\n- **Action:** \r\n  - Update flow variables (`waitingForSidePrompt`, `sidePromptResult`, `flowContext`)\r\n  - Log receipt of sidePrompt completion\r\n- **Output:** Second output (index 1)\r\n\r\n### Case 4: Stop message (edge case)\r\n- **Condition:** `msg.status` equals \"stop\"\r\n- **Action:** Log receipt of stop message\r\n- **Output:** No output (all null)\r\n\r\n## 3. Output Phase\r\n- Determine final output based on processing phase\r\n- Return array with message in appropriate index:\r\n  - [message, null, null] for first output\r\n  - [null, message, null] for second output\r\n  - [null, null, null] for stop message"
    },
    {
        "id": "1c1bc00d9a8c86d6",
        "type": "function",
        "z": "dynamicCmdSubflow",
        "name": "initialParser",
        "func": "function parseInputText(inputText) {\n    console.log(`[parseInputText] Starting to parse input text`);\n    console.log(`[parseInputText] Input text length: ${inputText.length} characters`);\n\n    const lines = inputText.split('\\n');\n    console.log(`[parseInputText] Number of lines: ${lines.length}`);\n\n    let dynamicCmdContext = {\n        dynamicCmd: true,\n        commandsArray: [],\n        currentOutputType: \"mainPrompt\",\n        cmdExecTime: Date.now()\n    };\n\n    let currentCommand = null;\n    let isCapturingNestedCommand = false;\n    let nestedCommandBuffer = '';\n\n    console.log(`[parseInputText] Initialized parsing variables`);\n\n    const processLine = (line, index) => {\n        console.log(`[parseInputText] Processing line ${index + 1}: '${line}'`);\n\n        const originalLine = line;\n        line = line.replace(/\\/\\/.*$/, '').trim(); // Remove comments\n\n        if (line !== originalLine) {\n            console.log(`[parseInputText] Removed comment. New line: '${line}'`);\n        }\n\n        if (line === 'dynamicCmd' || line === '- commandSet') {\n            return; // Skip these lines\n        }\n\n        const mainCommandMatch = line.match(/^-\\s*(\\w+)(\\d+)/);\n        if (mainCommandMatch) {\n            const [, cmdType, cmdNumber] = mainCommandMatch;\n            currentCommand = {\n                type: cmdType,\n                number: cmdNumber,\n                commands: [],\n                result: null\n            };\n            dynamicCmdContext.commandsArray.push(currentCommand);\n            console.log(`[parseInputText] Started new main command: ${cmdType}${cmdNumber}`);\n        } else if (line.startsWith('- `')) {\n            isCapturingNestedCommand = true;\n            nestedCommandBuffer = line.substring(3);\n            console.log(`[parseInputText] Started capturing nested command`);\n        } else if (isCapturingNestedCommand) {\n            if (line.endsWith('`')) {\n                nestedCommandBuffer += line.substring(0, line.length - 1);\n                currentCommand.commands.push(nestedCommandBuffer.trim());\n                isCapturingNestedCommand = false;\n                console.log(`[parseInputText] Finished capturing nested command`);\n            } else {\n                nestedCommandBuffer += line + '\\n';\n            }\n        } else if (line.startsWith('-') && currentCommand) {\n            const subCommand = line.substring(1).trim();\n            currentCommand.commands.push(subCommand);\n            console.log(`[parseInputText] Added sub-command to ${currentCommand.type}${currentCommand.number}: '${subCommand}'`);\n        }\n    };\n\n    lines.forEach(processLine);\n\n    console.log(`[parseInputText] Finished parsing input text`);\n    console.log(`[parseInputText] Final parsed dynamicCmdContext: ${JSON.stringify(dynamicCmdContext, null, 2)}`);\n\n    return dynamicCmdContext;\n}\n\n// Node-RED function node entry point\nif (msg.payload && typeof msg.payload === 'string' && msg.payload.includes('dynamicCmd')) {\n    console.log(`[initialParser] Received message with dynamicCmd content`);\n    const parsedCmd = parseInputText(msg.payload);\n    let flowContext = {};\n    flowContext.dynamicCmdContext = parsedCmd;\n    flow.set('flowContext', flowContext);  // This line adds flow-level persistence\n    console.log(`[initialParser] Stored parsed dynamicCmd in flow context`);\n\n    msg.dynamicCmdContext = parsedCmd;\n\n    // Initialize other contexts if they don't exist\n    msg.inputContext = msg.inputContext || { filePrompt: \"\", filePath: \"\" };\n    msg.promptSectionContext = msg.promptSectionContext || {\n        promptSectionsArray: [],\n        status: \"\",\n        _continuation: false,\n        _event: \"\",\n        currentStep: 0,\n        totalSteps: 0,\n        promptConfig: { title: \"\", body: \"\" }\n    };\n\n    console.log(`[initialParser] Attached parsed dynamicCmdContext to msg object`);\n    node.send([null, msg]);\n} else {\n    console.log(`[initialParser] Received non-dynamicCmd message, passing through`);\n    msg.dynamicCmdContext = { dynamicCmd: false };\n    node.send([msg, null]);\n}",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 630,
        "y": 180,
        "wires": [
            [],
            [
                "d9c9b8665a5ca2df"
            ]
        ],
        "info": "Function parseInputText(inputText):\r\n    Split inputText into lines\r\n    Initialize dynamicCmd object\r\n\r\n    For each line in lines:\r\n        Remove comments from line\r\n        \r\n        If line is 'dynamicCmd':\r\n            Start new command set in dynamicCmd\r\n        Else if line starts with '- ' and matches command pattern:\r\n            Create new command in current command set\r\n        Else if line starts with '- `':\r\n            Start capturing multi-line command\r\n        Else if currently capturing multi-line command:\r\n            If line ends with '`':\r\n                Finish capturing multi-line command\r\n            Else:\r\n                Continue capturing multi-line command\r\n        Else if line starts with '-':\r\n            Add sub-command to current command\r\n\r\n    Return dynamicCmd object\r\n\r\n// Node-RED function node entry point\r\nIf msg.payload contains 'dynamicCmd':\r\n    Parse msg.payload\r\n    Store result in flow context and msg.dynamicCmd\r\n    Return [msg, null, null]\r\nElse:\r\n    Set msg.dynamicCmd to false\r\n    Return [msg, null, null]"
    },
    {
        "id": "d9c9b8665a5ca2df",
        "type": "function",
        "z": "dynamicCmdSubflow",
        "name": "blockExecutor",
        "func": "console.log('[blockExecutor] Starting execution');\n\nconst flowContext = flow.get('flowContext') || {};\n\n/**\n * Waits for a processed result to be ready in the flow context.\n * @param {number} timeout - Maximum time to wait in milliseconds\n * @returns {Promise<any>} The processed result\n */\nasync function waitForProcessedResult(timeout = 600000) {\n    console.log('[waitForProcessedResult] Waiting for processed result');\n    const startTime = Date.now();\n\n    function checkResultReady() {\n        const flowContext = flow.get('flowContext') || {};\n        if (flowContext.processedResultReady) {\n            console.log('[waitForProcessedResult] Result ready');\n            flowContext.processedResultReady = false;\n            flow.set('flowContext', flowContext);\n            return flowContext.processedResult;\n        }\n        return null;\n    }\n\n    function checkTimeout() {\n        if (Date.now() - startTime > timeout) {\n            throw new Error('Timeout waiting for processed result');\n        }\n    }\n\n    async function waitBeforeNextCheck() {\n        await new Promise(resolve => setTimeout(resolve, 500));\n    }\n\n    async function waitLoop() {\n        while (true) {\n            const result = checkResultReady();\n            if (result !== null) {\n                return result;\n            }\n            checkTimeout();\n            await waitBeforeNextCheck();\n        }\n    }\n\n    return await waitLoop();\n}\n\n/**\n * Executes a single command and waits for its result.\n * @param {Object} command - The command to execute\n * @returns {Promise<any>} The result of the command execution\n */\nasync function executeCommand(command) {\n    node.send([null, {\n        ...msg,\n        dynamicCmdContext: {\n            dynamicCmd: true,\n            command: command,\n            triggerCommandExecution: Date.now()\n        }\n        }]);\n\n    return await waitForProcessedResult(600000);\n}\n\n/**\n * Executes all commands in a dynamicCmd structure.\n * @param {Object} dynamicCmdContext - The dynamicCmd context containing commands to execute\n * @returns {Promise<Array>} An array of results from all command executions\n */\nasync function executeBlockCommands(dynamicCmdContext) {\n    function initializeFlowContext() {\n        let flowContext = flow.get('flowContext') || {};\n        flowContext.previousResponse = flowContext.previousResponse || '[Previous response not available]';\n        flow.set('flowContext', flowContext);\n        console.log(\"[executeBlockCommands] flowContext\", flowContext)\n        return flowContext;\n    }\n\n    async function executeSingleCommand(command, flowContext, index, commandsArray) {\n        if (!command?.type) return null;\n\n        // Update dynamicCmdContext with current command info\n        dynamicCmdContext.currentCommand = {\n            type: command.type,\n            number: command.number,\n            index: index + 1,\n            total: commandsArray.length\n        };\n\n        console.log(`[executeSingleCommand] Processing command ${index + 1}/${commandsArray.length}: ${command.type}${command.number}`);\n\n        try {\n            const result = await executeCommand(command);\n            command.result = result;\n\n            // Store the result in the DynamicCmdContext.command structure\n            dynamicCmdContext.command = {\n                type: command.type,\n                number: command.number,\n                result: result\n            };\n\n            //console.log(\"[executeSingleCommand] Flow Context: \", JSON.stringify(flowContext, null, 2));\n            console.log(\"[executeSingleCommand] Command: \", JSON.stringify(command, null, 2));\n            // Find the command in the array and update its result\n            const commandIndex = flowContext.dynamicCmdContext.commandsArray.findIndex(\n            cmd => cmd.type === command.type && cmd.number === command.number\n            );\n\n            // Log the updated dynamicCmdContext after each command\n            flowContext.dynamicCmdContext.commandsArray[commandIndex].result = result;\n            flow.set('flowContext', flowContext);\n            msg.dynamicCmdContext = flowContext.dynamicCmdContext;\n            console.log(`[executeSingleCommand] Updated dynamicCmdContext:`, JSON.stringify(msg.dynamicCmdContext, null, 2));\n\n            return result;\n        } catch (error) {\n            console.error(`[executeBlockCommands] Error executing ${command.type}:`, error);\n            command.processedResult = `[Error: ${error.message}]`;\n            return `[Error: ${error.message}]`;\n        }\n    }\n\n    async function executeBlockCommandMain() {\n        if (!dynamicCmdContext?.commandsArray?.length) {\n            throw new Error(\"Invalid dynamicCmd structure\");\n        }\n\n        let flowContext = initializeFlowContext();\n        let results = [];\n        const commandsArray = flowContext.dynamicCmdContext.commandsArray;\n\n        for (let i = 0; i < commandsArray.length; i++) {\n            const command = commandsArray[i];\n            const result = await executeSingleCommand(command, flowContext, i, commandsArray);\n            results.push(result);\n\n            // Log the progress after each command\n            console.log(`[executeBlockCommandMain] Completed command ${i + 1}/${commandsArray.length}`);\n\n            await new Promise(resolve => setTimeout(resolve, 100));\n\n            // Check if this is the last command\n            if (i === commandsArray.length - 1) {\n                msg.dynamicCmdContext.blockComplete = true;\n                console.log('[executeBlockCommandMain] All commands processed, blockComplete set to true');\n            }\n        }\n\n        // Clear current command info after all commands are processed\n        dynamicCmdContext.currentCommand = null;\n\n        // Log the final dynamicCmdContext\n        console.log(`[executeBlockCommandMain] Final dynamicCmdContext:`, JSON.stringify(msg.dynamicCmdContext, null, 2));\n\n        return results;\n    }\n\n    return await executeBlockCommandMain();\n}\n\n/**\n * Handles the execution of a dynamic command.\n * @param {Object} data - The dynamic command data\n */\nasync function handleDynamicCommand(data) {\n    if (!data || !data.commandsArray) throw new Error(\"Invalid dynamicCmd data\");\n\n    console.log('[handleDynamicCommand] Executing new dynamic command');\n    try {\n        const results = await executeBlockCommands(data);\n    \n        msg.dynamicCmdContext.results = results;\n        msg.dynamicCmdContext.finalResult = results[results.length - 1]; // Set the last result as the final result\n\n        if (msg.dynamicCmdContext.blockComplete) {\n            console.log('[handleDynamicCommand] All commands processed successfully');\n            console.log('[handleDynamicCommand] result : ', msg.dynamicCmdContext.finalResult);\n            node.send([msg, null]);\n        } else {\n            console.log('[handleDynamicCommand] Not all commands processed, check for errors');\n        }\n    } catch (error) {\n        console.error(\"[handleDynamicCommand] Error processing commands:\", error);\n        node.error(\"Error processing commands: \" + error.message, msg);\n    }\n}\n\n/**\n * Parses the incoming message and categorizes it.\n * @param {Object} msg - The incoming message\n * @returns {Object} Categorized message object\n */\nfunction parseIncomingMessage(msg) {\n    if (msg.dynamicCmdContext && msg.dynamicCmdContext.dynamicCmd) {\n        console.log('[parseIncomingMessage] New dynamic command detected');\n        return { type: 'dynamicCmd', data: msg.dynamicCmdContext };\n    } else {\n        console.log('[parseIncomingMessage] Pass through message');\n        return { type: 'passThrough', data: msg };\n    }\n}\n\n/**\n * Handles different types of messages based on their category.\n */\nasync function main() {\n    console.log('[main] Starting message handling');\n    try {\n        const parsedMsg = parseIncomingMessage(msg);\n\n        switch (parsedMsg.type) {\n            case 'dynamicCmd':\n                await handleDynamicCommand(parsedMsg.data);\n                break;\n        }\n    } catch (error) {\n        console.error(\"[main] Error:\", error);\n        node.error(\"Error in main: \" + error.message, msg);\n    }\n}\n\n// Main execution flow\nconsole.log('[blockExecutor] Starting execution');\nmain().then(() => console.log('[blockExecutor] Execution completed'));",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 240,
        "wires": [
            [
                "94b392982f53c55a"
            ],
            [
                "c8091fa058f1e46a"
            ]
        ],
        "info": "# Block Executor Control Flow\r\n\r\n1. **Initialization**\r\n   - Log start of execution\r\n   - Retrieve or initialize `flowContext`\r\n\r\n2. **Utility Functions Definition**\r\n   - `sendFlowUpdate`: Send flow updates to another node\r\n   - `helper_waitProcessing`: Wait for processed result\r\n\r\n3. **Main Functions Definition**\r\n   - `executeCommand`: Send a command and wait for processing\r\n   - `executeBlockCommands`: Process a set of commands organized in sections\r\n   - `parseIncomingMessage`: Categorize incoming messages\r\n   - `handleMessage`: Main entry point for processing messages\r\n\r\n4. **Main Execution**\r\n   - Call `handleMessage()`\r\n\r\n5. **Message Handling (in `handleMessage`)**\r\n   - Parse incoming message\r\n   - Based on message type:\r\n     a. 'newDynamicCmd': \r\n        - Call `executeBlockCommands`\r\n        - On completion, update flow and send result\r\n     b. 'processedResult': \r\n        - Update flow variables\r\n     c. Other types: \r\n        - Pass message through\r\n\r\n6. **Block Command Execution (in `executeBlockCommands`)**\r\n   - Iterate through sections and commands\r\n   - For each command:\r\n     - Call `executeCommand`\r\n     - Collect results and update flow variables\r\n\r\n7. **Command Execution (in `executeCommand`)**\r\n   - Send command\r\n   - Wait for processing using `helper_waitProcessing`\r\n\r\n8. **Completion**\r\n   - Log execution completion\r\n   - Return null\r\n\r\nThroughout: Use `sendFlowUpdate` for flow variable updates and extensive error handling and logging."
    },
    {
        "id": "c8091fa058f1e46a",
        "type": "function",
        "z": "dynamicCmdSubflow",
        "name": "commandExecutor",
        "func": "// Command Executor Node\n\nlet flowContext = flow.get('flowContext') || {};\n//flowContext.dynamicCmdContext = flowContext.dynamicCmdContext || {};\n//flowContext.dynamicCmdContext.commandsArray = flowContext.dynamicCmdContext.commandsArray || [];\n\n// Log function\nfunction log(functionName, ...messages) {\n    const timestamp = new Date().toISOString();\n    console.log(`[${timestamp}] [${functionName}]`, ...messages);\n}\n\n// Parse dynamic variables in text\nfunction parseDynamicVariables(text, flowContext) {\n    \n    log('parseDynamicVariables', 'Starting function with text:', text);\n\n    if (typeof text !== 'string') {\n        log('parseDynamicVariables', 'Warning: text is not a string. Type:', typeof text);\n        if (text === null || text === undefined) {\n            log('parseDynamicVariables', 'Text is null or undefined. Returning empty string.');\n            return '';\n        }\n        try {\n            text = String(text);\n            log('parseDynamicVariables', 'Converted text to string:', text);\n        } catch (error) {\n            log('parseDynamicVariables', 'Error converting text to string:', error);\n            return '[Error: Unable to process non-string input]';\n        }\n    }\n\n    if (!flowContext || typeof flowContext !== 'object') {\n        log('parseDynamicVariables', 'Warning: flowContext is not a valid object');\n        return text;\n    }\n\n    try {\n        // Handle previousResponse\n        if (text.includes('{previousResponse}')) {\n            log('parseDynamicVariables', 'Found {previousResponse} placeholder in text');\n\n            if (msg.promptSectionContext && typeof msg.promptSectionContext.currentStep === 'number') {\n                const currentStep = msg.promptSectionContext.currentStep;\n                const previousStep = currentStep - 1;\n                if (previousStep >= 0 && msg.promptSectionContext.responseArray[previousStep]) {\n                    const previousResponse = msg.promptSectionContext.responseArray[previousStep];\n                    log('parseDynamicVariables', `Found previousResponse for step ${previousStep}:`, previousResponse);\n                    // Ensure responseText is a string\n                    let stringResponseText = String(previousResponse);\n                    text = text.replace(/{previousResponse}/g, stringResponseText);\n                } else {\n                    log('parseDynamicVariables', `No previousResponse found for step ${previousStep}`);\n                    text = text.replace(/{previousResponse}/g, '[Previous response not available]');\n                }\n            }\n            log('parseDynamicVariables', 'After replacing previousResponse:', text);\n        }\n\n        // Handle the $<<variable>>$\n        flowContext = flow.get(\"flowContext\");\n        text = text.replace(/\\$<<(\\w+)(\\d+)Result>>\\$/g, (match, cmdType, cmdNumber) => {\n            console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Processing match: ${match}`);\n            console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Command Type: ${cmdType}, Command Number: ${cmdNumber}`);\n\n            console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Full dynamicCmdContext:`, JSON.stringify(flowContext.dynamicCmdContext, null, 2));\n\n            if (flowContext.dynamicCmdContext) {\n                let cmd;\n\n                if (Array.isArray(flowContext.dynamicCmdContext.commandsArray)) {\n                    console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Searching in commandsArray`);\n                    cmd = flowContext.dynamicCmdContext.commandsArray.find(c => \n                        c.type === cmdType && c.number.toString() === cmdNumber.toString()\n                    );\n                } else if (flowContext.dynamicCmdContext.command) {\n                    console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Checking single command`);\n                    const singleCmd = flowContext.dynamicCmdContext.command;\n                    if (singleCmd.type === cmdType && singleCmd.number.toString() === cmdNumber.toString()) {\n                        cmd = singleCmd;\n                    }\n                }\n\n                if (cmd) {\n                    console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Matching command found:`, JSON.stringify(cmd, null, 2));\n\n                    if (cmd.result !== undefined && cmd.result !== null) {\n                        console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Replaced ${match} with:`, cmd.result);\n                        return String(cmd.result);\n                    } else {\n                        console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Command found but result is undefined or null`);\n                    }\n                } else {\n                    console.log(`[${new Date().toISOString()}] [parseDynamicVariables] No matching command found for type: ${cmdType} and number: ${cmdNumber}`);\n                }\n            } else {\n                console.log(`[${new Date().toISOString()}] [parseDynamicVariables] dynamicCmdContext is not defined`);\n            }\n\n            console.log(`[${new Date().toISOString()}] [parseDynamicVariables] Warning: ${match} not available in flowContext`);\n            return `[${cmdType}${cmdNumber}Result not available]`;\n        });\n\n        // Replace $<<execute(...)>>$\n        text = text.replace(/\\$<<execute\\((.*?)\\)>>\\$/g, (match, code) => {\n            log('parseDynamicVariables', 'Executing code:', code);\n            try {\n                code = code.replace(/;$/, '');\n                const safeContext = createSafeContext(flowContext);\n                const result = new Function('flowContext', `with(flowContext) { return (${code}); }`)(safeContext);\n                log('parseDynamicVariables', 'Execution result:', result);\n                return result !== undefined ? result : '[undefined]';\n            } catch (error) {\n                log('parseDynamicVariables', 'Error executing:', error.message);\n                return `[Error executing: ${error.message}]`;\n            }\n        });\n\n        // Handle regular flowContext property access\n        text = text.replace(/\\$<<([\\w.]+)>>\\$/g, (match, path) => {\n            log('parseDynamicVariables', 'Accessing flowContext property:', path);\n            const parts = path.split('.');\n            let value = flowContext;\n            for (const part of parts) {\n                if (value && typeof value === 'object' && part in value) {\n                    value = value[part];\n                } else {\n                    log('parseDynamicVariables', `Warning: ${path} not available in flowContext`);\n                    return `[${path} not available]`;\n                }\n            }\n            const result = typeof value === 'object' ? JSON.stringify(value) : String(value);\n            log('parseDynamicVariables', 'Context property value:', result);\n            return result;\n        });\n\n        log('parseDynamicVariables', 'Final result:', text);\n        return text;\n    } catch (error) {\n        log('parseDynamicVariables', 'Unexpected error:', error);\n        return `[Error: ${error.message}]`;\n    }\n}\n\n// Create a safe flowContext for command execution\nfunction createSafeContext(flowContext) {\n    return {\n        flow: {\n            get: (key) => {\n                const value = flow.get(key);\n                log('createSafeContext', `flow.get('${key}'):`, value);\n                return value;\n            },\n            set: (key, value) => {\n                log('createSafeContext', `flow.set('${key}'):`, value);\n                flow.set(key, value);\n            }\n        },\n        global: {\n            get: (key) => {\n                const value = global.get(key);\n                log('createSafeContext', `global.get('${key}'):`, value);\n                return value;\n            },\n            set: (key, value) => {\n                log('createSafeContext', `global.set('${key}'):`, value);\n                global.set(key, value);\n            }\n        },\n        flowContext: flowContext\n    };\n}\n\n// Execute local command\nfunction executeLocalCmd(command, flowContext) {\n    log('executeLocalCmd', 'Executing local command:', command);\n    let result = '';\n    try {\n        const commandString = command.commands.join('\\n');\n        log('executeLocalCmd', 'Executing:', commandString);\n        const safeContext = createSafeContext(flowContext);\n        const wrappedCommand = `with(this) { ${commandString} }`;\n        const commandResult = new Function(wrappedCommand).call(safeContext);\n        result = commandResult !== undefined ? commandResult : '';\n    } catch (error) {\n        log('executeLocalCmd', 'Error:', error.message);\n        result = `[Error: ${error.message}]`;\n    }\n    log('executeLocalCmd', 'Result:', result);\n    return result;\n}\n\n// Execute compile or pack command\nfunction executeCompileOrPackCmd(command, flowContext) {\n    log('executeCompileOrPackCmd', 'Executing compile/pack command:', command);\n    let result = '';\n\n    if (command && Array.isArray(command.commands)) {\n        result = command.commands.map(cmd => {\n            return parseDynamicVariables(cmd, flowContext);\n        }).join('\\n');\n    } else {\n        log('executeCompileOrPackCmd', 'Invalid command structure:', command);\n        result = '[Error: Invalid command structure]';\n    }\n\n    log('executeCompileOrPackCmd', 'Result:', result);\n    return result.trim();\n}\n\n// Execute main prompt command\nfunction executeMainPromptCmd(command, flowContext) {\n    log('executeMainPromptCmd', 'Executing main prompt command:', command);\n    const result = command.commands.map(cmd => parseDynamicVariables(cmd, flowContext)).join('\\n');\n    log('executeMainPromptCmd', 'Result:', result);\n    return result;\n}\n\n// Wait for side prompt result\nfunction waitForSidePromptResult(timeout = 300000) {\n    log('waitForSidePromptResult', 'Starting to wait for side prompt result');\n\n    return new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        const checkSidePromptResult = () => {\n            if (flow.get('waitingForSidePrompt') == false) {\n                log('waitForSidePromptResult', 'Side prompt result is ready');\n                let sidePromptResult = flow.get('sidePromptResult') || {};\n                resolve(sidePromptResult);\n            } else if (Date.now() - startTime > timeout) {\n                log('waitForSidePromptResult', 'Timeout reached while waiting for side prompt result');\n                reject(new Error('Timeout waiting for side prompt result'));\n            } else {\n                log('waitForSidePromptResult', 'Side prompt result not ready, checking again in 1000ms');\n                setTimeout(checkSidePromptResult, 1300);\n            }\n        };\n        checkSidePromptResult();\n    });\n}\n\n// Execute side prompt command\nasync function executeSidePromptCmd(command, flowContext) {\n    log('executeSidePromptCmd', 'Executing side prompt command:', command);\n    const sidePromptCommands = command.commands;\n\n    // Set flow level variable indicating side prompt processing\n    flow.set('waitingForSidePrompt', true);\n\n    // Execute side prompt commands\n    const result = sidePromptCommands.map(cmd => parseDynamicVariables(cmd, flowContext));\n \n    log('executeSidePromptCmd', 'result' , result);\n\n    // Prepare the message to be sent immediately\n    let sidePromptMsg = {\n        sidePromptContext: {\n            promptSectionsArray: result,\n            status: \"start\"\n        }\n    };\n\n    node.send([null, sidePromptMsg])\n\n    log('executeSidePromptCmd', 'Sent side prompt, waiting for result');\n\n    try {\n        // Wait for the side prompt result\n        const sidePromptResult = await waitForSidePromptResult();\n\n        // Update flow flowContext with side prompt result\n        flowContext.processedResult = sidePromptResult;\n        flowContext.processedResultReady = true;\n        flow.set('flowContext', flowContext);\n\n        log('executeSidePromptCmd', 'Received side prompt result:', sidePromptResult);\n        return sidePromptResult;\n    } catch (error) {\n        log('executeSidePromptCmd', 'Error waiting for side prompt result:', error);\n        return `[Error: ${error.message}]`;\n    } finally {\n        // Reset the processing flag\n        flow.set('waitingForSidePrompt', false);\n    }\n}\n\n// Execute command based on its type\nasync function executeCommand(command, flowContext) {\n    log('executeCommand', 'Executing command:', command);\n    let result = '';\n\n    try {\n        switch (command.type) {\n            case 'localCmd':\n                result = await executeLocalCmd(command, flowContext);\n                break;\n            case 'compileCmd':\n                result = await executeCompileOrPackCmd(command, flowContext);\n                break;\n            case 'packCmd':\n                result = await executeCompileOrPackCmd(command, flowContext);\n                break;\n            case 'sidePromptCmd':\n                result = await executeSidePromptCmd(command, flowContext);\n                break;\n            case 'mainPromptCmd':\n                result = await executeMainPromptCmd(command, flowContext);\n                break;\n            default:\n                log('executeCommand', 'Unknown command type:', command.type);\n                result = `[Unknown command type: ${command.type}]`;\n        }\n    } catch (error) {\n        log('executeCommand', 'Error executing command:', error);\n        result = `[Error: ${error.message}]`;\n    }\n\n    log('executeCommand', 'Result:', result);\n    return result;\n}\n\n\n\n// Determine output type based on command type\nfunction determineOutputType(commandType) {\n    switch (commandType) {\n        case 'sidePromptCmd': return 'sidePrompt';\n        case 'mainPromptCmd': return 'mainPrompt';\n        default: return 'dynamicCmd';\n    }\n}\n\n// Update flowContext with command result\nfunction updateFlowContext(flowContext, command, result) {\n    flowContext.processedResult = result;\n    flowContext.processedResultReady = true;\n\n    // Update the result in the commandsArray\n    if (Array.isArray(flowContext.dynamicCmdContext.commandsArray)) {\n        const commandIndex = flowContext.dynamicCmdContext.commandsArray.findIndex(\n            cmd => cmd.type === command.type && cmd.number === command.number\n        );\n        if (commandIndex !== -1) {\n            flowContext.dynamicCmdContext.commandsArray[commandIndex].result = result;\n        }\n    }\n\n    // Update the responseArray in sidePromptContext\n    if (flowContext.sidePromptContext && Array.isArray(flowContext.sidePromptContext.responseArray)) {\n        const currentStep = flowContext.sidePromptContext.currentStep;\n        if (currentStep >= 0 && currentStep < flowContext.sidePromptContext.responseArray.length) {\n            flowContext.sidePromptContext.responseArray[currentStep] = {\n                ...flowContext.sidePromptContext.responseArray[currentStep],\n                response1: result\n            };\n        }\n    }\n\n    flow.set('flowContext', flowContext);\n\n    log('updateFlowContext', `Updated flowContext with result for ${command.type}${command.number}`);\n    log('updateFlowContext', `Updated flowContext: ${flowContext}`);\n}\n\n\n// Main execution function\nasync function main() {\n    console.log('starting Main');\n    log('commandExecutor main', 'Starting main function');\n\n    // Log the relevant parts of the msg object\n    log('commandExecutor main', 'Received Msg:', JSON.stringify(msg, null, 2));\n\n    const { dynamicCmd, command, triggerCommandExecution } = msg.dynamicCmdContext || {};\n\n    // Log individual properties\n    log('commandExecutor main', 'dynamicCmd:', dynamicCmd);\n    log('commandExecutor main', 'command:', JSON.stringify(command, null, 2));\n    log('commandExecutor main', 'triggerCommandExecution:', triggerCommandExecution);\n\n    // Handle non-dynamic commands and side prompt completion\n    if (!dynamicCmd && !msg.sidePromptContext.status) {\n        log('commandExecutor main', 'Passing through non-dynamic command');\n        return { ...msg, dynamicCmdContext: { ...msg.dynamicCmdContext, currentOutputType: 'passThrough' } };\n    }\n    // Handle SidePrompt Reception\n    else if (msg.sidePromptContext.status === \"Sequence Complete\") {\n        // Reset the processing flag & pass results\n        log('commandExecutor main', 'Reset Flag');\n        flow.set('waitingForSidePrompt', false);\n        flow.set('sidePromptResult', msg.payload);\n        return null;\n    }\n    // Handle invalid dynamic commands\n    else if ((!command || !triggerCommandExecution) && !msg.sidePromptContext.status) {\n        log('commandExecutor main', 'Invalid dynamic command, passing through');\n        return msg;\n    }\n\n    // Process valid dynamic command\n    log('commandExecutor main', 'Processing dynamic command');\n    let finalResult, currentOutputType = 'dynamicCmd';\n\n    try {\n        // Execute the command and determine output type\n        finalResult = await executeCommand(command, msg);\n        currentOutputType = determineOutputType(command.type);\n\n        // Update the result in the command\n        command.result = finalResult;\n        msg.dynamicCmdContext.currentOutputType = currentOutputType;\n    } catch (error) {\n        log('commandExecutor main', 'Error executing command', error);\n        finalResult = `[Error: ${error.message}]`;\n        currentOutputType = 'error';\n    }\n\n    log('commandExecutor main', 'Final result', finalResult);\n    log('commandExecutor main', 'Current output type', currentOutputType);\n\n    // Update flowContext\n    \n    updateFlowContext(flowContext, command, finalResult);\n\n    // Return processed result\n    return {\n        ...msg,\n        dynamicCmdContext: {\n            ...msg.dynamicCmdContext,\n            command: { ...command, result: finalResult },\n            processedResult: finalResult,\n            currentOutputType,\n        }\n    };\n}\n\n// Execute the main function and send the result\n(async () => {\n    try {\n        let newMsg = await main();\n        node.send([newMsg, null]);\n    } catch (error) {\n        log('commandExecutor', 'Error in main execution:', error);\n        node.error('Error in command executor', error);\n    }\n})();",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 320,
        "wires": [
            [],
            [
                "7437d3a15148c947"
            ]
        ],
        "info": "# Command Executor Control Flow\r\n\r\n1. **Initialization**\r\n   - Log start of execution\r\n   - Initialize or retrieve `flowContext`\r\n\r\n2. **Utility Functions Definition**\r\n   - `parseDynamicVariables`: Parse and replace dynamic variables in text\r\n   - `createSafeContext`: Create a safe context for executing commands\r\n   - `executeLocalCmd`: Execute local commands\r\n   - `executeCompileOrPackCmd`: Execute compile or pack commands\r\n   - `executeMainPromptCmd`: Execute main prompt commands\r\n   - `waitForSidePromptResult`: Wait for side prompt results\r\n   - `executeSidePromptCmd`: Execute side prompt commands\r\n   - `executeCommand`: Main function to execute commands based on type\r\n\r\n3. **Main Function Definition**\r\n   - `main()`: Core logic for processing commands\r\n\r\n4. **Main Execution**\r\n   - Try-catch block to execute `main()` and handle any errors\r\n\r\n5. **Main Function Flow (`main()`)**\r\n   - Check if message contains a dynamic command\r\n   - If not, pass through the message with an output type\r\n   - If yes:\r\n     a. Extract command and trigger from message\r\n     b. Refresh `flowContext`\r\n     c. Process the command:\r\n        - Execute the command using `executeCommand()`\r\n        - Determine the output type based on command type\r\n        - Handle any errors during execution\r\n     d. Update `flowContext` with the result\r\n     e. Return processed result with output type\r\n\r\n6. **Command Execution (`executeCommand()`)**\r\n   - Switch based on command type:\r\n     - `localCmd`: Execute using `executeLocalCmd()`\r\n     - `compileCmd` or `packCmd`: Execute using `executeCompileOrPackCmd()`\r\n     - `mainPromptCmd`: Execute using `executeMainPromptCmd()`\r\n     - `sidePromptCmd`: Execute using `executeSidePromptCmd()`\r\n\r\n7. **Dynamic Variable Parsing (`parseDynamicVariables()`)**\r\n   - Handle `previousResponse` and `sidePromptResult`\r\n   - Replace command type number results\r\n   - Execute inline code within `$<<execute(...)>>$`\r\n   - Handle regular msg property access\r\n\r\n8. **Side Prompt Execution (`executeSidePromptCmd()`)**\r\n   - Set flow-level variable for side prompt processing\r\n   - Execute side prompt commands\r\n   - Send out message with side prompts\r\n   - Wait for side prompt result using `waitForSidePromptResult()`\r\n   - Update `flowContext` with the result\r\n\r\nThroughout: Extensive logging and error handling at each step"
    },
    {
        "id": "c9770c87f37d1b12",
        "type": "comment",
        "z": "dynamicCmdSubflow",
        "name": "Check Descriptions for Breakdown",
        "info": "",
        "x": 1660,
        "y": 20,
        "wires": []
    },
    {
        "id": "7437d3a15148c947",
        "type": "function",
        "z": "dynamicCmdSubflow",
        "name": "sectionControllerSide",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet promptSections = context.get('promptSections') || [];\nlet currentStep = context.get('currentStep') || 0;\n\nconsole.log(`[sectionControllerSide] promptSections.length : ${promptSections.length}`);\n\nfunction processPromptSections(inputPromptSections) {\n    console.log('[sectionControllerSide] Processing input promptSections');\n\n    if (!Array.isArray(inputPromptSections)) {\n        console.error('[sectionControllerSide] Error: Input is not an array');\n        return [];\n    }\n\n    const processedPromptSections = inputPromptSections.map((prompt, index) => ({\n        title: `promptSection ${index + 1}`,\n        body: prompt,\n    }));\n\n    context.set('promptSections', processedPromptSections);\n    console.log(`[sectionControllerSide] Processed ${processedPromptSections.length} promptSections`);\n    node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${processedPromptSections.length} promptSections` });\n\n    return processedPromptSections;\n}\n\nfunction processNextPrompt() {\n    console.log(`[sectionControllerSide] Processing next prompt. Current step: ${currentStep}`);\n    if (currentStep < promptSections.length) {\n        const msg = {\n            sidePromptContext: {\n                promptSectionsArray: promptSections,\n                responseArray: [],\n                status: \"processing\",\n                _continuation: true,\n                _event: \"node:\" + Math.random().toString(36).substr(2, 9),\n                currentStep: currentStep,\n                totalSteps: promptSections.length,\n                promptConfig: {\n                    title: promptSections[currentStep].title,\n                    body: promptSections[currentStep].body\n                },\n                sidePromptCmdDone: \"\"\n            },\n            payload: promptSections[currentStep].body,\n        };\n        console.log(`[sectionControllerSide] Sending prompt ${currentStep + 1} of ${promptSections.length}`);\n        node.send(msg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${promptSections.length}` });\n        currentStep++;\n        context.set('currentStep', currentStep);\n    } else {\n        console.log('[sectionControllerSide] All promptSections processed. Stopping.');\n        node.send([null, {\n            payload: \"Sequence Complete\",\n            sidePromptContext: { sidePromptCmdDone: \"Sequence Complete\" }\n        }]);\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[sectionControllerSide] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[sectionControllerSide] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    promptSections = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('promptSections', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, promptSections Unloaded\" });\n}\n\n// Main logic\nif (msg.sidePromptContext && msg.sidePromptContext._continuation == true) {\n    console.log(`[sectionControllerSide] Received continuation message with payload: ${msg.payload}`);\n    console.log(\"[sectionControllerSide] msg:\", msg);\n    if (isProcessing) {\n        if (msg.sidePromptContext.status === \"done\" || msg.sidePromptContext.status === \"End of Sequence\") {\n            console.log('[sectionControllerSide] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            processNextPrompt();\n        } else if (msg.sidePromptContext.status === \"error\") {\n            console.log(`[sectionControllerSide] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[sectionControllerSide] Received new message with payload: ${JSON.stringify(msg.payload)}`);\n    if (msg.sidePromptContext && msg.sidePromptContext.status === \"start\") {\n        if (Array.isArray(msg.sidePromptContext.promptSectionsArray)) {\n            promptSections = processPromptSections(msg.sidePromptContext.promptSectionsArray);\n            startProcessing();\n        } else {\n            console.log('[sectionControllerSide] Invalid input: payload is not an array of promptSections');\n            node.status({ fill: \"red\", shape: \"ring\", text: \"Invalid input\" });\n        }\n    } else if (msg.sidePromptContext && msg.sidePromptContext.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.sidePromptContext && msg.sidePromptContext.status === \"Sequence Complete\") {\n        node.send([null, {\n            ...msg,\n        }]);\n        stopProcessing();\n    } else {\n        console.log(`[sectionControllerSide] Unrecognized message: ${JSON.stringify(msg)}`);\n    }\n}\n\nreturn null;",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1000,
        "y": 400,
        "wires": [
            [
                "5d50ade39f4eed52"
            ],
            [
                "d55ca1dfbf182d65"
            ]
        ]
    },
    {
        "id": "5d50ade39f4eed52",
        "type": "function",
        "z": "dynamicCmdSubflow",
        "name": "Run Prompt Side",
        "func": "console.log('[Run Prompt Side] Starting execution');\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\nlet nodeContext = context.get('nodeContext') || {};\nnodeContext.sidePromptContext = nodeContext.sidePromptContext || {};\nnodeContext.sidePromptContext.responseArray = nodeContext.sidePromptContext.responseArray || [];\nnodeContext.runPromptSection = nodeContext.runPromptSection || {};\nnodeContext.runPromptSection.isStopRequested = msg.payload === \"stop\";\n\nconsole.log('nodeContext.runPromptSection:', nodeContext.runPromptSection);\n\nlet browser, browserContext, currentPage;\n\nasync function setupBrowserAndGetPage(options = {}) {\n    const { getLastPage = false } = options;\n\n    if (!browser) {\n        try {\n            browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n            browserContext = browser.contexts()[0];\n        } catch (error) {\n            throw new Error('Connection setup error: ' + error.message);\n        }\n    }\n\n    if (!browserContext) {\n        browserContext = browser.contexts()[0];\n    }\n\n    let currentPage;\n    if (getLastPage) {\n        const pages = await browserContext.pages();\n        currentPage = pages[pages.length - 1];\n    } else {\n        currentPage = (await browserContext.pages())[0] || await browserContext.newPage();\n    }\n\n    return { browser, browserContext, currentPage };\n}\n////////////////\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n        if (shouldClick) {\n            await button.click();\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        if (shouldReload) await page.reload({ waitUntil: 'networkidle' });\n    } catch (error) {\n        console.error(`[Run Prompt Main] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    let previousLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    while (Date.now() - startTime < maxWaitTime) {\n        if (nodeContext.runPromptSection.isStopRequested) {\n            await stopGeneration();\n            await clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            const page = await getCurrentPage();\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                await page.waitForTimeout(1000); // Wait for scroll animation\n            }\n\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n\n            if (articles.length === 0) {\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n            } catch (error) {\n                responseText = await lastArticle.innerText();\n            }\n\n            const currentLength = responseText.length;\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n\n            if (stableCount >= maxStableCount) {\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    let responseText = '';\n    try {\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        if (articles.length > 0) {\n            const lastArticle = articles[articles.length - 1];\n            const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n            if (copyButton) {\n                await copyButton.click();\n                await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n                responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            } else {\n                const markdownDiv = await lastArticle.$('div.markdown');\n                responseText = markdownDiv ? await markdownDiv.innerText() : '';\n            }\n        }\n    } catch (error) {\n        try {\n            const lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n            const textBaseElement = await lastArticle.$('.text-base');\n            responseText = textBaseElement ? await textBaseElement.innerText() : '';\n        } catch (innerError) {\n            responseText = '';\n        }\n    }\n\n    return responseText;\n}\n\n////////////////\n\n\nasync function runPromptSection() {\n  console.log('[Run Prompt Side] Entering runPromptSection');\n  try {\n    await reloadPageIfNecessary(0);\n\n    const page = await getCurrentPage();\n    const newChatButton = await page.$('nav > a.flex.py-3.px-3.items-center.gap-3.rounded-md:has-text(\"New chat\")');\n    if (newChatButton) {\n        await newChatButton.click();\n        await page.waitForLoadState('networkidle');\n    }\n    console.log('[Run Prompt Side] Got current page in runPromptSection');\n\n    console.log('[Run Prompt Side] Full Msg:', msg);\n    await clickButtonIfVisible('button:has-text(\"Continue generating\")', true);\n    const promptText = msg.sidePromptContext.promptConfig.body || 'Sidefiring';\n    console.log('[Run Prompt Side] Entering prompt:', promptText);\n    await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n    await page.fill('#prompt-textarea', promptText);\n\n    // Some type of check block\n    if (msg.sidePromptContext && msg.sidePromptContext.sidePromptCmdDone) {\n      console.log('[Run Prompt Side] Handling sidePrompt');\n      const sidePromptText = msg.sidePromptContext.sidePromptCmdDone;\n      await page.evaluate((text) => {\n        const textarea = document.querySelector('#prompt-textarea');\n        textarea.value += '\\n\\n' + text;\n        textarea.dispatchEvent(new Event('input', { bubbles: true }));\n      }, sidePromptText);\n    }\n\n    await page.click('button[data-testid=\"send-button\"]');\n    console.log('[Run Prompt Side] Sent prompt');\n\n    await waitForResponseCompletion();\n\n    const responseText = await extractResponseText(page);\n    await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n    await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n    \n    nodeContext.sidePromptContext.responseArray = nodeContext.sidePromptContext.responseArray || [];\n\n    // Ensure responseText is a string\n    let stringResponseText = String(responseText);\n\n    // Add the new response to the array\n    nodeContext.sidePromptContext.responseArray.push(stringResponseText);\n    context.set('nodeContext', nodeContext);\n    console.log('nodeContext.sidePromptContext.responseArray :', nodeContext.sidePromptContext.responseArray);\n\n    console.log('[Run Prompt Side] Exiting runPromptSection');\n    return responseText;\n  } catch (error) {\n    console.log(`[Run Prompt Side] Error in runPromptSection: ${error.message}`);\n    console.log('[Run Prompt Side] Error stack:', error.stack);\n    throw error;\n  }\n}\n\nasync function runPromptSectionWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPromptSection();\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt Main] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isStopRequested() {\n    return nodeContext.runPromptSection.isStopRequested;\n}\n\n////////////////\n\nasync function stopGeneration() {\n    nodeContext.runPromptSection.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    await clearStopRequestedState();\n}\n\nasync function clearStopRequestedState() {\n    nodeContext.runPromptSection.isStopRequested = false;\n}\n\nasync function handleStopRequest(browser, msg) {\n  if (browser) {\n    browser.close().then(() => console.log('[Run Prompt Side] Browser closed due to stop request'));\n  }\n  node.status({ fill: \"yellow\", shape: \"ring\", text: \"Stopped\" });\n  return { payload: \"Execution stopped\", status: { fill: \"yellow\", shape: \"ring\", text: \"Stopped\" } };\n}\n\n////////////////\n  \nfunction handleLastStep(result) {\n    const lastResponse = nodeContext.sidePromptContext.responseArray[nodeContext.sidePromptContext.responseArray.length - 1];\n    \n    return {\n        ...result,\n        sidePromptContext: {\n            ...result.sidePromptContext,\n            _continuation: false,\n            status: \"Sequence Complete\",\n            responseArray: nodeContext.sidePromptContext.responseArray,\n            endOfSequence: true,\n            sidePromptCmdDone: true,\n        },\n        payload: lastResponse\n    };\n}\n\nfunction isLastStep(msg) {\n    console.log('Checking if this is the last step');\n    return msg.sidePromptContext.currentStep === msg.sidePromptContext.totalSteps - 1;\n}\nfunction handleError(error) {\n    console.log('[Run Prompt Side] Error:', error);\n    return {\n      payload: `Error: ${error.message}`,\n      status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n      error: error\n    };\n}\n  \nfunction cleanup(browser, result, msg) {\n  if (browser) {\n    browser.close().then(() => console.log('[Run Prompt Side] Browser closed'));\n  }\n\n  node.status(result.status);\n\n  let isLastMessage = result.endOfSequence || false;\n  \n  const firstOutput = {\n    ...msg,\n    endOfSequence: isLastMessage,\n    sidePromptContext: {\n      ...msg.sidePromptContext,\n      _continuation: !isLastMessage,\n      status: result.status.text,\n      responseArray: [\n          ...nodeContext.sidePromptContext.responseArray,\n      ],\n      _event: isLastMessage ? \"End of Sequence\" : \"Continue\",\n      sidePromptCmdDone: false\n    },\n  };\n\n   return firstOutput;\n}\n\nasync function executeScript(msg) {\n  console.log('[Run Prompt Side] Entering executeScript');\n  console.log('[Run Prompt Side] Full Msg:', JSON.stringify(msg, null, 2));\n  const maxRetries = 3;\n  let browser;\n  let result = { payload: null, status: null, error: null };\n\n  try {\n    browser = await setupBrowser();\n\n    if (isStopRequested()) {\n      return handleStopRequest(browser, msg);\n    }\n\n    result = await runPromptSectionWithRetries(msg, maxRetries);\n\n    if (isLastStep(msg)) {\n      result = handleLastStep(msg);\n      console.log('last step result: ', result);\n      context.set('nodeContext', undefined);\n       node.send([result, null]);\n    }\n    else {\n        let sendMsg = cleanup(browser, result, msg);\n        node.send([sendMsg, null]);\n    }\n  } catch (error) {\n    result = handleError(error);\n  }\n\n\n}\n\nexecuteScript(msg);\n\nreturn null;",
        "outputs": 3,
        "timeout": "",
        "noerr": 27,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1010,
        "y": 500,
        "wires": [
            [
                "7437d3a15148c947"
            ],
            [],
            []
        ]
    },
    {
        "id": "057d1e420082c237",
        "type": "comment",
        "z": "dynamicCmdSubflow",
        "name": "All Dynamic Cmd is flow level",
        "info": "- check out the node.send pattern in block exec and wait for processed result\n-- should only send a short, internally coded msg\n- only really pass on the final msg after block execution\n- Make sure all step tracking is done at flow level\n- make sure cmd results are found accurately\n- Also put in side prompt results\n- Also make sure main prompt works\n- Readjust the JSON\nSlapped on as msg at the end.\n---\n- make a short loop with block executor and command executor -> sideprompt\nReorganize side prompt - go straight into block executor\n- move output to loop back to block executor",
        "x": 1660,
        "y": 60,
        "wires": []
    },
    {
        "id": "9897c0bda7821d37",
        "type": "debug",
        "z": "dynamicCmdSubflow",
        "name": "debug 9",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1000,
        "y": 600,
        "wires": []
    },
    {
        "id": "3e99deeda814c17e",
        "type": "comment",
        "z": "dynamicCmdSubflow",
        "name": "Block Execution Process",
        "info": "- Compile Cmd\n- Make sure localCmd1Result is replaced",
        "x": 1630,
        "y": 160,
        "wires": []
    },
    {
        "id": "4ec4db05a8bfb198",
        "type": "link in",
        "z": "dynamicCmdSubflow",
        "name": "link in 5",
        "links": [
            "d55ca1dfbf182d65"
        ],
        "x": 765,
        "y": 400,
        "wires": [
            [
                "9897c0bda7821d37",
                "c8091fa058f1e46a"
            ]
        ]
    },
    {
        "id": "d55ca1dfbf182d65",
        "type": "link out",
        "z": "dynamicCmdSubflow",
        "name": "link out 6",
        "mode": "link",
        "links": [
            "4ec4db05a8bfb198"
        ],
        "x": 1185,
        "y": 400,
        "wires": []
    },
    {
        "id": "a4247e3d1ddaecc1",
        "type": "comment",
        "z": "dynamicCmdSubflow",
        "name": "Internal Dynamic Cmd Flow",
        "info": "Sends a msg\n",
        "x": 1640,
        "y": 120,
        "wires": []
    },
    {
        "id": "eb37406d0f486c7c",
        "type": "comment",
        "z": "dynamicCmdSubflow",
        "name": "Next",
        "info": "- Side Prompt Handling\n    - make sure to set a flag to make it wait\n    - make sure to properly store result\n    - In RunPromptSection - figure out how the memory structure works.\n    - Finished sideprompt handling\n        - run prompt side - response key\n\n\n- Pack Command\n- Main Command",
        "x": 1570,
        "y": 320,
        "wires": []
    },
    {
        "id": "08b6869916f384c6",
        "type": "comment",
        "z": "dynamicCmdSubflow",
        "name": "",
        "info": "- Keep state in flow\n- only pass messages in and out",
        "x": 1560,
        "y": 400,
        "wires": []
    },
    {
        "id": "94b392982f53c55a",
        "type": "function",
        "z": "dynamicCmdSubflow",
        "name": "outputHandler",
        "func": "// Output Handler Node\n\n// Utility function for logging\nconst log = (prefix, message, obj = null) => {\n    console.log(`[${prefix}] ${message}${obj ? ': ' + JSON.stringify(obj) : ''}`);\n};\n\n// Handle main prompt output\nfunction handleMainPromptOutput(msg) {\n    log('handleMainPromptOutput', 'Starting to handle main prompt output');\n\n    if (msg?.dynamicCmdContext?.finalResult) {\n        log('handleMainPromptOutput', 'Found finalResult, moving to payload');\n        msg.payload = msg.dynamicCmdContext.finalResult;\n    } else {\n        log('handleMainPromptOutput', 'finalResult not found in the message');\n    }\n\n    return [msg, null, null];\n}\n\n// Handle error output\nfunction handleErrorOutput(msg) {\n    log('handleErrorOutput', 'Handling error output', msg);\n    return [null, null, msg];\n}\n\n// Garbage collection\nfunction garbageCollect() {\n    log('garbageCollect', 'Starting garbage collection');\n    flow.keys().forEach(key => {\n        flow.set(key, undefined);\n        log('garbageCollect', `Cleared flow variable: ${key}`);\n    });\n    log('garbageCollect', 'Garbage collection completed');\n}\n\n// Main execution logic\nfunction processOutput() {\n    log('Output Handler', 'Starting main execution logic');\n\n    // Garbage collection if dynamic command is completed\n    if (msg.dynamicCmdContext?.dynamicCmd !== false && msg.dynamicCmdContext?.blockComplete === true) {\n        log('Output Handler', 'Dynamic command completed, triggering garbage collection');\n        garbageCollect();\n        \n        //Block to get final result\n        handleMainPromptOutput(msg)\n        node.send(msg);\n    }\n\n    \n}\n\n// Execute the main function\nprocessOutput();\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 240,
        "wires": [
            []
        ]
    },
    {
        "id": "8b7fda62adc7c26d",
        "type": "function",
        "z": "817a5b2b5a30223d",
        "name": "inputConditionals",
        "func": "// Input Handler\nconst flowContext = flow.get('flowContext') || {};\n\n// Update the latest message\nflowContext.latestMsg = msg;\nflow.set('flowContext', flowContext);\n\nconsole.log(\"[inputConditionals] Starting inputConditionals function.\");\nconsole.log(`[inputConditionals] Input msg: ${JSON.stringify(msg)}`);\n\n// Check if this is a sidePrompt completion message\nif (msg.sidePromptStatus === \"done\") {\n    console.log(\"[inputConditionals] Received sidePrompt completion message.\");\n    flow.set('waitingForSidePrompt', false);\n    flow.set('sidePromptResult', msg.payload);\n    flow.set('flowContext', flowContext);\n    return msg; // Send sidePrompt completion to output2\n}\n// Check if this is a sidePrompt completion message\nif (msg.status === \"stop\") {\n    console.log(\"[inputConditionals] Received stop message.\");\n    return null; // Send sidePrompt completion to output2\n}\n\n// Check if this is a dynamicCmd message\nif (msg.payload && typeof msg.payload === 'string' && msg.payload.includes('dynamicCmd')) {\n    return msg; // Send dynamicCmd messages to mainProcessor\n}\n\n// For all other messages, pass through to output1\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 100,
        "wires": [
            [
                "ce9314d0c6a00494"
            ]
        ],
        "info": "# processMessage Function Breakdown\r\n\r\n## 1. Input Phase\r\n- **Always executed**\r\n- Update `flowContext` with latest message\r\n- Log function start and input message\r\n\r\n## 2. Processing Phase\r\n\r\n### Case 1: Regular message (most common)\r\n- **Condition:** Message doesn't meet any special conditions\r\n- **Action:** Pass message through unchanged\r\n- **Output:** First output (index 0)\r\n\r\n### Case 2: dynamicCmd message (common)\r\n- **Condition:** `msg.payload` exists, is a string, and contains \"dynamicCmd\"\r\n- **Action:** Pass message through unchanged\r\n- **Output:** First output (index 0)\r\n\r\n### Case 3: sidePrompt completion (less common)\r\n- **Condition:** `msg.sidePromptStatus` equals \"done\"\r\n- **Action:** \r\n  - Update flow variables (`waitingForSidePrompt`, `sidePromptResult`, `flowContext`)\r\n  - Log receipt of sidePrompt completion\r\n- **Output:** Second output (index 1)\r\n\r\n### Case 4: Stop message (edge case)\r\n- **Condition:** `msg.status` equals \"stop\"\r\n- **Action:** Log receipt of stop message\r\n- **Output:** No output (all null)\r\n\r\n## 3. Output Phase\r\n- Determine final output based on processing phase\r\n- Return array with message in appropriate index:\r\n  - [message, null, null] for first output\r\n  - [null, message, null] for second output\r\n  - [null, null, null] for stop message"
    },
    {
        "id": "ce9314d0c6a00494",
        "type": "function",
        "z": "817a5b2b5a30223d",
        "name": "initialParser",
        "func": "// The initialParser Layer\n\nfunction parseInputText(inputText) {\n    console.log(`[parseInputText] Starting to parse input text`);\n    console.log(`[parseInputText] Input text length: ${inputText.length} characters`);\n\n    const lines = inputText.split('\\n');\n    console.log(`[parseInputText] Number of lines: ${lines.length}`);\n\n    let dynamicCmd = { sections: [] };\n    let currentCommand = null;\n    let isCapturingNestedCommand = false;\n    let nestedCommandBuffer = '';\n\n    console.log(`[parseInputText] Initialized parsing variables`);\n\n    const processLine = (line, index) => {\n        console.log(`[parseInputText] Processing line ${index + 1}: '${line}'`);\n\n        const originalLine = line;\n        line = line.replace(/\\/\\/.*$/, '').trim(); // Remove comments\n\n        if (line !== originalLine) {\n            console.log(`[parseInputText] Removed comment. New line: '${line}'`);\n        }\n\n        if (line === 'dynamicCmd') {\n            dynamicCmd.sections.push({ type: 'commandSet', commands: [] });\n            console.log(`[parseInputText] Detected 'dynamicCmd' section. Created new command set. Total sections: ${dynamicCmd.sections.length}`);\n            return;\n        }\n\n        if (line === '- commandSet') {\n            console.log(`[parseInputText] Detected commandSet line, ignoring.`);\n            return;\n        }\n\n        const mainCommandMatch = line.match(/^-\\s*(\\w+)(\\d+)/);\n        if (mainCommandMatch) {\n            const [, cmdType, cmdNumber] = mainCommandMatch;\n            currentCommand = { type: cmdType, number: cmdNumber, commands: [] };\n            dynamicCmd.sections[dynamicCmd.sections.length - 1].commands.push(currentCommand);\n            console.log(`[parseInputText] Started new main command: ${cmdType}${cmdNumber}. Total commands in current section: ${dynamicCmd.sections[dynamicCmd.sections.length - 1].commands.length}`);\n        } else if (line.startsWith('- `')) {\n            isCapturingNestedCommand = true;\n            nestedCommandBuffer = line.substring(3);\n            console.log(`[parseInputText] Started capturing nested command. Initial buffer: '${nestedCommandBuffer}'`);\n        } else if (isCapturingNestedCommand) {\n            if (line.endsWith('`')) {\n                nestedCommandBuffer += line.substring(0, line.length - 1);\n                currentCommand.commands.push(nestedCommandBuffer);\n                isCapturingNestedCommand = false;\n                console.log(`[parseInputText] Finished capturing nested command: '${nestedCommandBuffer}'`);\n                console.log(`[parseInputText] Total commands for ${currentCommand.type}${currentCommand.number}: ${currentCommand.commands.length}`);\n            } else {\n                nestedCommandBuffer += line + '\\n';\n                console.log(`[parseInputText] Capturing nested command. Current buffer length: ${nestedCommandBuffer.length} characters`);\n            }\n        } else if (line.startsWith('-') && currentCommand) {\n            const subCommand = line.substring(1).trim();\n            currentCommand.commands.push(subCommand);\n            console.log(`[parseInputText] Added sub-command to ${currentCommand.type}${currentCommand.number}: '${subCommand}'`);\n            console.log(`[parseInputText] Total commands for ${currentCommand.type}${currentCommand.number}: ${currentCommand.commands.length}`);\n        } else {\n            console.log(`[parseInputText] Skipped line: '${line}'`);\n        }\n    };\n\n    lines.forEach(processLine);\n\n    console.log(`[parseInputText] Finished parsing input text.`);\n    console.log(`[parseInputText] Total sections in dynamicCmd: ${dynamicCmd.sections.length}`);\n    dynamicCmd.sections.forEach((section, index) => {\n        console.log(`[parseInputText] Section ${index + 1} has ${section.commands.length} commands`);\n    });\n    console.log(`[parseInputText] Final parsed dynamicCmd: ${JSON.stringify(dynamicCmd, null, 2)}`);\n\n    return dynamicCmd;\n}\n\n// Node-RED function node entry point\nif (msg.payload && typeof msg.payload === 'string' && msg.payload.includes('dynamicCmd')) {\n    console.log(`[initialParser] Received message with dynamicCmd content`);\n    const parsedCmd = parseInputText(msg.payload);\n    flow.set('parsedDynamicCmd', parsedCmd);  // This line adds flow-level persistence\n    console.log(`[initialParser] Stored parsed dynamicCmd in flow context`);\n    msg.dynamicCmd = parsedCmd;\n    console.log(`[initialParser] Attached parsed dynamicCmd to msg object`);\n    return [msg, null, null];\n} else {\n    console.log(`[initialParser] Received non-dynamicCmd message, passing through`);\n    msg.dynamicCmd = false;\n    return [msg, null, null]; // Pass through non-dynamicCmd messages\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 650,
        "y": 180,
        "wires": [
            [
                "773c9afecffb264f"
            ]
        ]
    },
    {
        "id": "773c9afecffb264f",
        "type": "function",
        "z": "817a5b2b5a30223d",
        "name": "blockExecutor",
        "func": "// blockExecutor\n\nconsole.log('[blockExecutor] Starting execution');\n\nconst flowContext = flow.get('flowContext') || {};\n\nfunction helper_waitProcessing(timeout = 30000) {\n    console.log('[helper_waitProcessing] Starting to wait for processed result');\n    return new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        const checkProcessedResult = () => {\n            const currentContext = flow.get('flowContext') || {};\n            if (currentContext.processedResultReady) {\n                console.log('[helper_waitProcessing] Processed result is ready');\n                currentContext.processedResultReady = false;\n                flow.set('flowContext', currentContext);\n                resolve(currentContext.processedResult);\n            } else if (Date.now() - startTime > timeout) {\n                console.warn('[helper_waitProcessing] Timeout reached while waiting for processed result');\n                reject(new Error('Timeout waiting for processed result'));\n            } else {\n                console.log('[helper_waitProcessing] Processed result not ready, checking again in 500ms');\n                setTimeout(checkProcessedResult, 500);\n            }\n        };\n        checkProcessedResult();\n    });\n}\n\nasync function executeCommand(command) {\n    flow.set('currentCommand', command);\n    flow.set('currentResult', '');\n    flow.set('triggerDynamicVars', Date.now());\n    console.log('[executeCommand] Set currentCommand and triggerDynamicVars in flow');\n\n    const msgToSend = {\n        dynamicCmd: true,\n        command: command,\n        triggerDynamicVars: Date.now()\n    };\n    console.log('[executeCommand] Sending message:', JSON.stringify(msgToSend));\n    node.send(msgToSend);\n\n    return await helper_waitProcessing(60000);\n}\n\nasync function executeBlockCommands(dynamicCmd) {\n    console.log('[executeBlockCommands] Starting execution of commands');\n\n    if (!dynamicCmd || !dynamicCmd.sections || !Array.isArray(dynamicCmd.sections)) {\n        console.error(\"[executeBlockCommands] Invalid dynamicCmd structure:\", dynamicCmd);\n        throw new Error(\"Invalid dynamicCmd structure\");\n    }\n\n    let flowContext = flow.get('flowContext') || {};\n    flowContext.previousResponse = flowContext.previousResponse || '[Previous response not available]';\n    flow.set('flowContext', flowContext);\n\n    let finalResult = \"\";\n\n    for (let sectionIndex = 0; sectionIndex < dynamicCmd.sections.length; sectionIndex++) {\n        console.log(`[executeBlockCommands] Processing section ${sectionIndex}`);\n        const section = dynamicCmd.sections[sectionIndex];\n\n        if (!section || !section.commands || !Array.isArray(section.commands)) {\n            console.warn(`[executeBlockCommands] Invalid section structure at index ${sectionIndex}:`, section);\n            continue;\n        }\n\n        for (let commandIndex = 0; commandIndex < section.commands.length; commandIndex++) {\n            console.log(`[executeBlockCommands] Processing command ${commandIndex} in section ${sectionIndex}`);\n            const command = section.commands[commandIndex];\n\n            if (!command || !command.type) {\n                console.warn(`[executeBlockCommands] Invalid command at section ${sectionIndex}, command ${commandIndex}:`, command);\n                continue;\n            }\n\n            let result;\n\n            try {\n                console.log(`[executeBlockCommands] Executing command of type: ${command.type}`);\n                result = await executeCommand(command);\n\n                console.log(`[executeBlockCommands] Command result:`, result);\n                command.result = result;\n                finalResult += (finalResult ? \"\\n\" : \"\") + result;\n\n                flowContext[`${command.type}${command.number}Result`] = result;\n                flow.set('flowContext', flowContext);\n\n                command.processedResult = result;\n            } catch (error) {\n                console.error(`[executeBlockCommands] Error executing command ${command.type}:`, error);\n                command.processedResult = `[Error: ${error.message}]`;\n            }\n\n            await new Promise(resolve => setTimeout(resolve, 100));\n        }\n    }\n\n    // Add the dynamicCmdComplete flag\n    msg.dynamicCmdComplete = true;\n    \n    return finalResult;\n}\n\nfunction parseIncomingMessage(msg) {\n    if (msg.dynamicCmd && !msg.currentCommand) {\n        console.log('[parseIncomingMessage] New dynamic command detected');\n        return { type: 'newDynamicCmd', data: msg.dynamicCmd };\n    } else if (msg.type === 'processedResult') {\n        console.log('[parseIncomingMessage] Processed result received');\n        return { type: 'processedResult', data: msg.data, command: msg.command };\n    } else {\n        console.log('[parseIncomingMessage] Pass through message');\n        return { type: 'passThrough', data: msg };\n    }\n}\n\nfunction handleMessage() {\n    console.log('[handleMessage] Starting message handling');\n    try {\n        const parsedMsg = parseIncomingMessage(msg);\n\n        switch (parsedMsg.type) {\n            case 'newDynamicCmd':\n                if (!parsedMsg.data) {\n                    throw new Error(\"Invalid dynamicCmd data\");\n                }\n                console.log('[handleMessage] Executing new dynamic command');\n                executeBlockCommands(parsedMsg.data)\n                    .then(result => {\n                        console.log('[handleMessage] Command execution completed. Result:', result);\n                        flow.set('finalResult', result);\n                        console.log('[handleMessage] Set finalResult in flow');\n                        node.send({ payload: result, dynamicCmdComplete: true });\n                    })\n                    .catch(error => {\n                        console.error(\"[handleMessage] Error processing commands:\", error);\n                        node.error(\"Error processing commands: \" + error.message, msg);\n                    });\n                break;\n\n            case 'processedResult':\n                console.log('[handleMessage] Setting processed result');\n                flow.set('processedResult', parsedMsg.data);\n                flow.set('processedResultReady', true);\n                console.log('[handleMessage] Updated flow variables: processedResult and processedResultReady');\n                break;\n\n            case 'passThrough':\n            default:\n                console.log('[handleMessage] Passing through message');\n                node.send(msg);\n                break;\n        }\n    } catch (error) {\n        console.error(\"[handleMessage] Error in handleMessage:\", error);\n        node.error(\"Error in handleMessage: \" + error.message, msg);\n    }\n}\n\nconsole.log('[blockExecutor] Calling handleMessage');\nhandleMessage();\n\nconsole.log('[blockExecutor] Execution completed');\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 260,
        "wires": [
            [
                "626b45db91593296"
            ]
        ]
    },
    {
        "id": "626b45db91593296",
        "type": "function",
        "z": "817a5b2b5a30223d",
        "name": "commandExecutor",
        "func": "// commandExecutor\n\nconsole.log('[commandExecutor] Starting execution');\n\nlet flowContext = flow.get('flowContext') || {};\n\nfunction parseDynamicVariables(text, context) {\n    console.log('[parseDynamicVariables] Starting function with text:', text);\n\n    if (typeof text !== 'string') {\n        console.warn('[parseDynamicVariables] Warning: text is not a string. Type:', typeof text);\n        if (text === null || text === undefined) {\n            console.warn('[parseDynamicVariables] Text is null or undefined. Returning empty string.');\n            return '';\n        }\n        try {\n            text = String(text);\n            console.log('[parseDynamicVariables] Converted text to string:', text);\n        } catch (error) {\n            console.error('[parseDynamicVariables] Error converting text to string:', error);\n            return '[Error: Unable to process non-string input]';\n        }\n    }\n\n    if (!msg || typeof msg !== 'object') {\n        console.warn('[parseDynamicVariables] Warning: msg is not a valid object');\n        return text;\n    }\n\n    try {\n        // Handle previousResponse and sidePromptResult\n        if (context && context.latestMsg && typeof context.latestMsg.currentStep === 'number') {\n            const currentStep = context.latestMsg.currentStep;\n            const previousStep = currentStep - 1;\n            const previousResponseKey = `response${previousStep}`;\n\n            if (previousStep >= 0 && context.latestMsg[previousResponseKey]) {\n                const previousResponse = context.latestMsg[previousResponseKey];\n                console.log(`[parseDynamicVariables] Found previousResponse for step ${previousStep}:`, previousResponse);\n                text = text.replace(/{previousResponse}/g, previousResponse);\n            } else {\n                console.warn(`[parseDynamicVariables] No previousResponse found for step ${previousStep}`);\n                text = text.replace(/{previousResponse}/g, '[Previous response not available]');\n            }\n        } else {\n            console.warn('[parseDynamicVariables] Unable to determine previousResponse from context');\n            text = text.replace(/{previousResponse}/g, '[Previous response not available]');\n        }\n\n        console.log('[parseDynamicVariables] After replacing previousResponse:', text);\n        text = text.replace(/{sidePromptResult}/g, context.sidePromptResult || '[Side prompt result not available]');\n\n        // Replace $<<commandTypeNumberResult>>$\n        text = text.replace(/\\$<<(\\w+)(\\d+)Result>>\\$/g, (match, cmdType, cmdNumber) => {\n            const resultKey = `${cmdType}${cmdNumber}Result`;\n            const result = context[resultKey] || `[${resultKey} not available]`;\n            console.log(`[parseDynamicVariables] Replaced ${match} with:`, result);\n            return result;\n        });\n\n        // Replace $<<execute(...)>>$\n        text = text.replace(/\\$<<execute\\((.*?)\\)>>\\$/g, (match, code) => {\n            console.log(`[parseDynamicVariables] Executing code:`, code);\n            try {\n                code = code.replace(/;$/, '');\n                const safeContext = createSafeContext(msg, context);\n                const result = new Function('context', `with(context) { return (${code}); }`)(safeContext);\n                console.log(`[parseDynamicVariables] Execution result:`, result);\n                return result !== undefined ? result : '[undefined]';\n            } catch (error) {\n                console.error(`[parseDynamicVariables] Error executing: ${error.message}`);\n                return `[Error executing: ${error.message}]`;\n            }\n        });\n\n        // Handle regular msg property access\n        text = text.replace(/\\$<<([\\w.]+)>>\\$/g, (match, path) => {\n            console.log(`[parseDynamicVariables] Accessing msg property:`, path);\n            const parts = path.split('.');\n            let value = msg;\n            for (const part of parts) {\n                if (value && typeof value === 'object' && part in value) {\n                    value = value[part];\n                } else {\n                    console.warn(`[parseDynamicVariables] Warning: ${path} not available in msg`);\n                    return `[${path} not available]`;\n                }\n            }\n            const result = typeof value === 'object' ? JSON.stringify(value) : String(value);\n            console.log(`[parseDynamicVariables] Msg property value:`, result);\n            return result;\n        });\n\n        console.log(`[parseDynamicVariables] Final result: ${text}`);\n        return text;\n    } catch (error) {\n        console.error('[parseDynamicVariables] Unexpected error:', error);\n        return `[Error: ${error.message}]`;\n    }\n}\n\nfunction createSafeContext(msg, context) {\n    return {\n        flow: {\n            get: (key) => {\n                const value = flow.get(key);\n                console.log(`[createSafeContext] flow.get('${key}'):`, value);\n                return value;\n            },\n            set: (key, value) => {\n                console.log(`[createSafeContext] flow.set('${key}'):`, value);\n                flow.set(key, value);\n            }\n        },\n        global: {\n            get: (key) => {\n                const value = global.get(key);\n                console.log(`[createSafeContext] global.get('${key}'):`, value);\n                return value;\n            },\n            set: (key, value) => {\n                console.log(`[createSafeContext] global.set('${key}'):`, value);\n                global.set(key, value);\n            }\n        },\n        msg: msg,\n        context: context\n    };\n}\n\nfunction executeCommand(command, context) {\n    console.log(`[executeCommand] Executing command:`, JSON.stringify(command));\n    let result = '';\n\n    switch (command.type) {\n        case 'localCmd':\n            result = executeLocalCmd(command, msg, context);\n            break;\n        case 'compileCmd':\n        case 'packCmd':\n            result = executeCompileOrPackCmd(command, msg, context);\n            break;\n        case 'mainPromptCmd':\n            result = executeMainPromptCmd(command, msg, context);\n            break;\n        case 'sidePromptCmd':\n            result = executeSidePromptCmd(command, msg, context);\n            break;\n        default:\n            console.warn(`[executeCommand] Unknown command type: ${command.type}`);\n            result = `[Unknown command type: ${command.type}]`;\n    }\n\n    console.log(`[executeCommand] Result:`, result);\n    return result;\n}\n\nfunction executeLocalCmd(command, msg, context) {\n    console.log(`[executeLocalCmd] Executing local command:`, JSON.stringify(command));\n    let result = '';\n    try {\n        const commandString = command.commands.join('\\n');\n        console.log(`[executeLocalCmd] Executing: ${commandString}`);\n        const safeContext = createSafeContext(msg, context);\n        const wrappedCommand = `with(this) { ${commandString} }`;\n        const commandResult = new Function(wrappedCommand).call(safeContext);\n        result = commandResult !== undefined ? commandResult : '';\n    } catch (error) {\n        console.error(`[executeLocalCmd] Error: ${error.message}`);\n        result = `[Error: ${error.message}]`;\n    }\n    console.log(`[executeLocalCmd] Result:`, result);\n    return result;\n}\n\nfunction executeCompileOrPackCmd(command, msg, context) {\n    console.log(`[executeCompileOrPackCmd] Executing compile/pack command:`, JSON.stringify(command));\n    let result = '';\n\n    if (command && Array.isArray(command.commands)) {\n        result = command.commands.map(cmd => {\n            return parseDynamicVariables(cmd, context);\n        }).join('\\n');\n    } else {\n        console.warn(`[executeCompileOrPackCmd] Invalid command structure:`, JSON.stringify(command));\n        result = '[Error: Invalid command structure]';\n    }\n\n    console.log(`[executeCompileOrPackCmd] Result:`, result);\n    return result.trim();\n}\n\nfunction executeMainPromptCmd(command, msg, context) {\n    console.log(`[executeMainPromptCmd] Executing main prompt command:`, JSON.stringify(command));\n    const result = command.commands.map(cmd => parseDynamicVariables(cmd, context)).join('\\n');\n    console.log(`[executeMainPromptCmd] Result:`, result);\n    return result;\n}\n\nasync function executeSidePromptCmd(command, msg, context) {\n    console.log(`[executeSidePromptCmd] Executing side prompt command:`, JSON.stringify(command));\n    const sidePromptCommands = command.commands;\n\n    // Set flow level variable indicating side prompt processing\n    flow.set('waitingForSidePrompt', true);\n\n    // Execute side prompt commands\n    const result = sidePromptCommands.map(cmd => parseDynamicVariables(cmd, context)).join('\\n');\n\n    // Send out the message with side prompts\n    node.send({ payload: result, sidePrompt: true });\n\n    console.log(`[executeSidePromptCmd] Sent side prompt, waiting for result`);\n\n    try {\n        // Wait for the side prompt result\n        const sidePromptResult = await waitForSidePromptResult();\n\n        // Update flow context with side prompt result\n        flowContext.sidePromptResult = sidePromptResult;\n        flow.set('flowContext', flowContext);\n\n        console.log(`[executeSidePromptCmd] Received side prompt result:`, sidePromptResult);\n        return sidePromptResult;\n    } catch (error) {\n        console.error(`[executeSidePromptCmd] Error waiting for side prompt result:`, error);\n        return `[Error: ${error.message}]`;\n    } finally {\n        // Reset the processing flag\n        flow.set('waitingForSidePrompt', false);\n    }\n}\n\nfunction waitForSidePromptResult(timeout = 100000) {\n    console.log('[waitForSidePromptResult] Starting to wait for side prompt result');\n    return new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        const checkSidePromptResult = () => {\n            let sidePromptResult = flow.get('sidePromptResult') || {};\n            if (flow.get('waitingForSidePrompt') == false) {\n                console.log('[waitForSidePromptResult] Side prompt result is ready');\n                resolve(sidePromptResult);\n            } else if (Date.now() - startTime > timeout) {\n                console.warn('[waitForSidePromptResult] Timeout reached while waiting for side prompt result');\n                reject(new Error('Timeout waiting for side prompt result'));\n            } else {\n                console.log('[waitForSidePromptResult] Side prompt result not ready, checking again in 1000ms');\n                setTimeout(checkSidePromptResult, 1300);\n            }\n        };\n        checkSidePromptResult();\n    });\n}\n\n\nfunction main() {\n    console.log('[main] Starting main function');\n\n    if (!msg.dynamicCmd) {\n        console.log('[main] Not a dynamic command message, passing through');\n        let outputType = 'normal'; // Default output type\n        return {\n            ...msg,\n            outputType: outputType // Add this line to pass the outputType\n        };\n    }\n\n    const command = msg.command;\n    const triggerDynamicVars = msg.triggerDynamicVars;\n\n    console.log('[main] Received command:', JSON.stringify(command));\n    console.log('[main] triggerDynamicVars:', triggerDynamicVars);\n\n    // Refresh flowContext at the beginning of main\n    let flowContext = flow.get('flowContext') || {};\n\n    if (command && triggerDynamicVars) {\n        console.log('[main] Processing command');\n        let finalResult;\n        let outputType = 'dynamicCmd'; // Default output type\n        console.log('[main] Output type:', outputType);\n\n        try {\n            console.log('[main] Executing command:', JSON.stringify(command));\n            const executedResult = executeCommand(command, flowContext);\n            console.log('[main] Executed result:', executedResult);\n            finalResult = executedResult;\n\n            // Set outputType based on command type\n            if (command.type === 'sidePromptCmd') {\n                outputType = 'sidePrompt';\n            } else if (command.type === 'mainPromptCmd') {\n                outputType = 'normal';\n            }\n            // Add more conditions for other command types if needed\n\n        } catch (error) {\n            console.error('[main] Error executing command:', error);\n            finalResult = `[Error: ${error.message}]`;\n            outputType = 'error';\n        }\n\n        console.log('[main] Final result:', finalResult);\n        console.log('[main] Output type:', outputType);\n\n        flowContext.processedResult = finalResult;\n        flowContext.processedResultReady = true;\n        flow.set('flowContext', flowContext);\n\n        const resultKey = `${command.type}${command.number}Result`;\n        flowContext[resultKey] = finalResult;\n        flow.set('flowContext', flowContext);\n        console.log(`[main] Stored result for ${resultKey} in flowContext`);\n\n        console.log('[main] Returning processed result');\n        return {\n            ...msg,\n            processedResult: {\n                type: 'processedResult',\n                data: finalResult,\n                command: command\n            },\n            outputType: outputType // Add this line to pass the outputType\n        };\n    } else {\n        console.log('[main] Invalid command or trigger, passing through message');\n        return msg;\n    }\n}\n\n// Add this line to log any errors that might occur\ntry {\n    return main();\n} catch (error) {\n    console.error('[commandExecutor] Error in main function:', error);\n    return msg;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 670,
        "y": 340,
        "wires": [
            [
                "731b22dc42e1a59e"
            ]
        ]
    },
    {
        "id": "731b22dc42e1a59e",
        "type": "function",
        "z": "817a5b2b5a30223d",
        "name": "outputHandler",
        "func": "// The Output Handler Layer\n\nfunction determineOutputType(msg) {\n    console.log('[determineOutputType] Starting output type determination');\n    console.log(`[determineOutputType] Input message:`, JSON.stringify(msg));\n\n    if (typeof msg !== 'object' || msg === null) {\n        console.warn('[determineOutputType] Invalid message object');\n        return 'normal';\n    }\n\n    if (msg.outputType) {\n        console.log(`[determineOutputType] Output type explicitly set: ${msg.outputType}`);\n        return msg.outputType;\n    }\n\n    if (msg.processedResult && msg.processedResult.type === 'processedResult') {\n        console.log('[determineOutputType] ProcessedResult found');\n        const command = msg.processedResult.command;\n        if (command && command.type === 'sidePromptCmd') {\n            console.log('[determineOutputType] SidePromptCmd detected');\n            return 'sidePrompt';\n        }\n    }\n\n    try {\n        const dynamicCmd = flow.get('dynamicCmd');\n        console.log('[determineOutputType] DynamicCmd:', JSON.stringify(dynamicCmd));\n        if (dynamicCmd && Array.isArray(dynamicCmd.sections) && dynamicCmd.sections.length > 0) {\n            const lastSection = dynamicCmd.sections[dynamicCmd.sections.length - 1];\n            if (Array.isArray(lastSection.commands) && lastSection.commands.length > 0) {\n                const lastCommand = lastSection.commands[lastSection.commands.length - 1];\n                console.log(`[determineOutputType] Last command type: ${lastCommand.type}`);\n                if (lastCommand.type === 'sidePromptCmd') {\n                    return 'sidePrompt';\n                }\n            }\n        }\n    } catch (error) {\n        console.error('[determineOutputType] Error checking dynamic command:', error);\n    }\n\n    if (dynamicCmd === undefined && msg.sidePrompt === true) {\n        console.log('[determineOutputType] dynamicCmd is undefined and msg.sidePrompt is true');\n        return 'sidePrompt';\n    }\n    \n    console.log('[determineOutputType] Defaulting to normal output type');\n    return 'normal';\n}\n\nfunction handleNormalOutput(msg) {\n    console.log('[handleNormalOutput] Handling normal output');\n    console.log('[handleNormalOutput] Returning message:', JSON.stringify(msg));\n    return [msg, null, null];\n}\n\nfunction handleSidePromptOutput(msg) {\n    console.log('[handleSidePromptOutput] Handling side prompt output');\n    console.log('[handleSidePromptOutput] Input message:', JSON.stringify(msg));\n\n    let sidePromptContent;\n    if (msg.processedResult &&\n        msg.processedResult.command &&\n        msg.processedResult.command.type === 'sidePromptCmd' &&\n        Array.isArray(msg.processedResult.command.commands)) {\n        sidePromptContent = msg.processedResult.command.commands;\n    } else if (Array.isArray(msg.payload)) {\n        sidePromptContent = msg.payload;\n    } else {\n        sidePromptContent = [msg.payload];\n    }\n\n    const sidePromptMsg = {\n        ...msg,\n        status: \"start\",\n        sidePrompt: true,\n        payload: sidePromptContent,\n        sidePromptNumber: msg.processedResult.command.number,\n    };\n\n    console.log(`[handleSidePromptOutput] Formatted side prompt message:`, JSON.stringify(sidePromptMsg));\n    return [null, sidePromptMsg, null];\n}\n\nfunction handleErrorOutput(msg) {\n    console.log('[handleErrorOutput] Handling error output');\n    console.log('[handleErrorOutput] Error message:', JSON.stringify(msg));\n    return [null, null, msg];\n}\n\nfunction garbageCollect() {\n    console.log('[garbageCollect] Starting garbage collection');\n    const flowKeys = flow.keys();\n    flowKeys.forEach(key => {\n        flow.set(key, undefined);\n        console.log(`[garbageCollect] Cleared flow variable: ${key}`);\n    });\n    console.log('[garbageCollect] Garbage collection completed');\n}\n\n// Main execution logic\nconsole.log('[Output Handler] Starting main execution logic');\n\nconst parsedExecutionResult = flow.get('parsedExecutionResult');\nif (parsedExecutionResult) {\n    console.log('[Output Handler] parsedExecutionResult found:', JSON.stringify(parsedExecutionResult));\n    msg.payload = parsedExecutionResult;\n}\n\nconst outputType = determineOutputType(msg);\nconsole.log(`[Output Handler] Determined output type: ${outputType}`);\n\nif (msg.dynamicCmd !== false && msg.dynamicCmdComplete === true) {\n    console.log('[Output Handler] Dynamic command completed, triggering garbage collection');\n    garbageCollect();\n}\n\nflow.set('lastOutputType', outputType);\nconsole.log(`[Output Handler] Stored lastOutputType: ${outputType}`);\n\nconsole.log(`[Output Handler] Switching based on output type: ${outputType}`);\nlet result;\nswitch (outputType) {\n    case 'normal':\n        result = handleNormalOutput(msg);\n        break;\n    case 'dynamicCmd':\n        console.log('[Output Handler] Handling dynamicCmd (no action)');\n        result = [null, null, null];\n        break;\n    case 'sidePrompt':\n        result = handleSidePromptOutput(msg);\n        break;\n    case 'error':\n        result = handleErrorOutput(msg);\n        break;\n    default:\n        console.warn(`[Output Handler] Unknown output type: ${outputType}, treating as normal`);\n        result = handleNormalOutput(msg);\n}\n\nconsole.log('[Output Handler] Final result:', JSON.stringify(result));\nreturn result;\n",
        "outputs": 4,
        "timeout": "",
        "noerr": 5,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 660,
        "y": 420,
        "wires": [
            [],
            [],
            [],
            [
                "986f04886dac8e5e"
            ]
        ]
    },
    {
        "id": "38f3c2ac7ac0b02e",
        "type": "switch",
        "z": "817a5b2b5a30223d",
        "name": "Stage Router",
        "property": "stage",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "stage1",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "stage2",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "stage3",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "complete",
                "vt": "str"
            },
            {
                "t": "eq",
                "v": "",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 5,
        "x": 380,
        "y": 260,
        "wires": [
            [
                "8b7fda62adc7c26d"
            ],
            [
                "ce9314d0c6a00494"
            ],
            [
                "773c9afecffb264f"
            ],
            [
                "626b45db91593296"
            ],
            [
                "731b22dc42e1a59e"
            ]
        ]
    },
    {
        "id": "c5ea16b270ced36c",
        "type": "link in",
        "z": "817a5b2b5a30223d",
        "name": "link in 4",
        "links": [],
        "x": 215,
        "y": 580,
        "wires": [
            [
                "38f3c2ac7ac0b02e"
            ]
        ]
    },
    {
        "id": "986f04886dac8e5e",
        "type": "link out",
        "z": "817a5b2b5a30223d",
        "name": "link out 5",
        "mode": "link",
        "links": [],
        "x": 895,
        "y": 560,
        "wires": []
    },
    {
        "id": "7b7126508f9af701",
        "type": "comment",
        "z": "67ce124139a68312",
        "name": "worked for 2 functions",
        "info": "",
        "x": 220,
        "y": 700,
        "wires": []
    },
    {
        "id": "8773e3ee5c59c8a8",
        "type": "inject",
        "z": "67ce124139a68312",
        "name": "Set disableWatch to false",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payloadType": "date",
        "x": 270,
        "y": 600,
        "wires": [
            [
                "71c51d19f152c495"
            ]
        ]
    },
    {
        "id": "71c51d19f152c495",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Set disableWatch to false",
        "func": "flow.set('disableWatch', false);\nreturn { payload: 'disableWatch set to false' };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 540,
        "y": 600,
        "wires": [
            []
        ]
    },
    {
        "id": "f4d8c1d5b61dd214",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Watch Files",
        "func": "let filePaths;\nlet userRootPaths = global.get('userRootPaths');\n\nif (Array.isArray(msg.payload)) {\n    filePaths = msg.payload; // Use payload directly if it's an array\n} else if (typeof msg.payload === 'string') {\n    filePaths = msg.payload.split(','); // Split payload into an array if it's a comma-separated string\n} else {\n    node.error('Invalid payload type. Expected an array or a comma-separated string.');\n    return null;\n}\n\nnode.warn('filepaths : ' + filePaths.length);\n\nconst debounceTimeout = 500; // Adjust this value as needed (in milliseconds)\nconst fileChangeTimers = {};\n\nfilePaths.forEach(path => {\n    if (fs.existsSync(path)) {\n        fs.watch(path, (eventType, filename) => {\n            if (filename) {\n                clearTimeout(fileChangeTimers[path]); // Clear any previous timer\n\n                fileChangeTimers[path] = setTimeout(() => {\n                    const changeMsg = {\n                        payload: path,\n                        filename: filename,\n                        topic: path,\n                        file: filename,\n                        type: eventType,\n                        size: fs.statSync(path).size\n                    };\n                    node.send(changeMsg);\n                }, debounceTimeout);\n            }\n        });\n    } else {\n        node.error(`File ${path} does not exist.`);\n    }\n});\n\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            }
        ],
        "x": 670,
        "y": 760,
        "wires": [
            [
                "62f51b767c95599c",
                "167bd4fe1602bc45"
            ]
        ]
    },
    {
        "id": "167bd4fe1602bc45",
        "type": "switch",
        "z": "67ce124139a68312",
        "name": "Check Disable Watch",
        "property": "disableWatch",
        "propertyType": "flow",
        "rules": [
            {
                "t": "false"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 890,
        "y": 760,
        "wires": [
            [
                "77cc33f0e6808346"
            ]
        ]
    },
    {
        "id": "77cc33f0e6808346",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Read File",
        "func": "const filePath = msg.payload;\nfs.readFile(filePath, 'utf8', (err, data) => {\n    if (err) {\n        node.error(err, msg);\n        return null;\n    }\n    msg.payload = data;\n    msg.filename = filePath;\n    node.send(msg);\n});\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            }
        ],
        "x": 1080,
        "y": 760,
        "wires": [
            [
                "5c60136a31a2ec75",
                "ddb31b995a1b064f"
            ]
        ]
    },
    {
        "id": "5c60136a31a2ec75",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Process File",
        "func": "// Disable the watch node to prevent recursive triggers\nflow.set('disableWatch', true);\n\n// Retrieve file content from the message payload\nconst fileContent = msg.payload;\nnode.warn('File content length: ' + fileContent.length);\n\n// Parse the file content to generate an AST\nlet ast;\ntry {\n    ast = acorn.parse(fileContent, { ecmaVersion: 2020, sourceType: \"module\" });\n} catch (e) {\n    node.error('Error parsing the file content: ' + e.message);\n    return null;\n}\n\n// Helper function to get the function name from a node\nfunction getFunctionName(node) {\n    return node.id ? node.id.name : (node.key ? node.name : null);\n}\n\n// Extract all top-level async functions\nconst topLevelAsyncFunctions = [];\nast.body.forEach(node => {\n    if (node.type === 'FunctionDeclaration' && node.async) {\n        topLevelAsyncFunctions.push(node);\n    } else if (node.type === 'VariableDeclaration') {\n        node.declarations.forEach(declaration => {\n            if (declaration.init && declaration.init.type === 'FunctionExpression' && declaration.init.async) {\n                topLevelAsyncFunctions.push(declaration.init);\n            }\n        });\n    }\n});\n\nif (topLevelAsyncFunctions.length === 0) {\n    node.error('No top-level async functions found.');\n    return null;\n}\n\nlet newFileContent = fileContent;\nlet changesMade = false;\n\n// First, gather the inner functions for each top-level async function\nconst functionData = topLevelAsyncFunctions.map(funcNode => {\n    const functionName = getFunctionName(funcNode);\n    if (!functionName) return null;\n\n    node.warn('Function found: ' + functionName);\n\n    // Extract top-level inner function names\n    const innerFunctionNames = [];\n    const innerFunctionRegex = /async function (\\w+)\\s*\\(.*?\\)\\s*{/g;\n    let functionBody = fileContent.slice(funcNode.body.start, funcNode.body.end);\n    let innerFunctionMatch;\n    while ((innerFunctionMatch = innerFunctionRegex.exec(functionBody)) !== null) {\n        // Ensure that the function is directly within the top-level function and not named \"execute\" or \"default\"\n        const functionStartIndex = innerFunctionMatch.index;\n        const precedingText = functionBody.slice(0, functionStartIndex);\n        const openBraces = (precedingText.match(/{/g) || []).length;\n        const closeBraces = (precedingText.match(/}/g) || []).length;\n        const innerFunctionName = innerFunctionMatch[1];\n        if (openBraces === closeBraces + 1 && innerFunctionName !== \"execute\" && innerFunctionName !== \"default\") {\n            innerFunctionNames.push(innerFunctionName);\n        }\n    }\n    node.warn('Top-level inner function names: ' + innerFunctionNames.join(', '));\n\n    return { funcNode, innerFunctionNames };\n}).filter(Boolean);\n\n// Helper function to insert the innerFunctions object\nfunction insertInnerFunctions(funcNode, innerFunctionNames, offset) {\n    if (innerFunctionNames.length === 0) {\n        return 0; // No inner functions to insert\n    }\n\n    // Check if 'innerFunctions' is already declared within the function body\n    const functionBody = fileContent.slice(funcNode.body.start + offset, funcNode.body.end + offset);\n    const innerFunctionsDeclared = /const innerFunctions = {([^}]*)}/.exec(functionBody);\n\n    if (innerFunctionsDeclared) {\n        const existingInnerFunctions = innerFunctionsDeclared[1];\n        const existingFunctions = existingInnerFunctions.split(',').map(fn => fn.trim()).filter(fn => fn.length > 0);\n        const missingFunctions = innerFunctionNames.filter(fn => !existingFunctions.includes(fn));\n        if (missingFunctions.length === 0) {\n            node.warn(`All inner functions already declared in ${getFunctionName(funcNode)}, skipping insertion.`);\n            return 0; // No adjustment needed\n        } else {\n            node.warn(`Updating inner functions in ${getFunctionName(funcNode)}.`);\n            const updatedInnerFunctionsArray = `const innerFunctions = {\\n    ${[...new Set([...existingFunctions, ...missingFunctions])].join(',\\n    ')}\\n  };`;\n\n            newFileContent = newFileContent.replace(innerFunctionsDeclared[0], updatedInnerFunctionsArray);\n            changesMade = true;\n            return updatedInnerFunctionsArray.length;\n        }\n    }\n\n    // Prepare the innerFunctions object to be inserted\n    const innerFunctionsArray = `\n  // #region : 0. Inner Functions\n  const innerFunctions = {\n    ${innerFunctionNames.join(',\\n    ')}\n  };\n  // #endregion`;\n\n    // Insert innerFunctions at the beginning of the main function body\n    const functionBodyStartIndex = funcNode.body.start + offset + 1; // +1 to skip the opening '{'\n    newFileContent = newFileContent.slice(0, functionBodyStartIndex) + innerFunctionsArray + newFileContent.slice(functionBodyStartIndex);\n    changesMade = true;\n    return innerFunctionsArray.length;\n}\n\n// Insert the innerFunctions object for each top-level async function sequentially\nlet adjustmentOffset = 0;\nfunctionData.forEach(({ funcNode, innerFunctionNames }) => {\n    adjustmentOffset += insertInnerFunctions(funcNode, innerFunctionNames, adjustmentOffset);\n\n    // Add a line in each inner function to add itself to innerFunctions (only for 2nd layer or deeper)\n    const innerFunctionRegex = /async function (\\w+)\\s*\\(.*?\\)\\s*{/g;\n    let functionBody = newFileContent.slice(funcNode.body.start + adjustmentOffset, funcNode.body.end + adjustmentOffset);\n    let innerFunctionMatch;\n    while ((innerFunctionMatch = innerFunctionRegex.exec(functionBody)) !== null) {\n        const innerFunctionName = innerFunctionMatch[1];\n        const innerFunctionBodyStartIndex = innerFunctionMatch.index + innerFunctionMatch[0].length + funcNode.body.start + adjustmentOffset;\n\n        // Determine the indentation of the inner function\n        const lineStartIndex = newFileContent.lastIndexOf('\\n', innerFunctionMatch.index + funcNode.body.start + adjustmentOffset) + 1;\n        const line = newFileContent.slice(lineStartIndex, innerFunctionMatch.index + funcNode.body.start + adjustmentOffset);\n        const indentation = line.match(/^\\s*/)[0];\n\n        // Check if this inner function is on the first layer or named \"execute\" or \"default\"\n        const precedingText = functionBody.slice(0, innerFunctionMatch.index);\n        const openBraces = (precedingText.match(/{/g) || []).length;\n        const closeBraces = (precedingText.match(/}/g) || []).length;\n        const isFirstLayer = openBraces === closeBraces + 1;\n        const isExcludedFunction = innerFunctionName === \"execute\" || innerFunctionName === \"default_exec\";\n\n        // Add the line with the determined indentation (only if not on the first layer and not an excluded function)\n        if (!isFirstLayer && !isExcludedFunction) {\n            const addToInnerFunctionsLine = `\\n${indentation}  innerFunctions.${innerFunctionName} = ${innerFunctionName};\\n`;\n            const updatedInnerFunctionBody = newFileContent.slice(0, innerFunctionBodyStartIndex) + addToInnerFunctionsLine + newFileContent.slice(innerFunctionBodyStartIndex);\n\n            // Only add the line if it doesn't already exist\n            if (!newFileContent.includes(`innerFunctions.${innerFunctionName} = ${innerFunctionName}`)) {\n                newFileContent = updatedInnerFunctionBody;\n                changesMade = true;\n                adjustmentOffset += addToInnerFunctionsLine.length;\n            }\n        }\n    }\n\n    // Update the AST to rescan the adjusted content again\n    try {\n        ast = acorn.parse(newFileContent, { ecmaVersion: 2020, sourceType: \"module\" });\n    } catch (e) {\n        node.error('Error parsing the updated file content: ' + e.message);\n        return null;\n    }\n});\n\n// Log new file content length for debugging\nnode.warn('New file content length: ' + newFileContent.length);\n\n// Only write back to the file if changes were made\nif (changesMade) {\n    msg.payload = newFileContent;\n    msg.filename = msg.filename; // Use the original file path\n    node.warn('Writing changes to the file.');\n    return [msg, null];\n} else {\n    // Indicate that no changes were needed\n    node.warn('No changes to write back to the file.');\n    // Reset disableWatch since no changes were made\n    flow.set('disableWatch', false);\n    return [null, { payload: 'No changes to the file.' }];\n}\n\n// Return null to avoid further processing\nreturn null;\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "acorn",
                "module": "acorn"
            }
        ],
        "x": 1290,
        "y": 760,
        "wires": [
            [
                "9b9a435bea293656",
                "58915726be2b9b02",
                "722cf7231496fff6",
                "2159df481b09d187"
            ],
            []
        ]
    },
    {
        "id": "9b9a435bea293656",
        "type": "file",
        "z": "67ce124139a68312",
        "name": "Write",
        "filename": "filename",
        "filenameType": "msg",
        "appendNewline": false,
        "createDir": false,
        "overwriteFile": "true",
        "encoding": "none",
        "x": 1570,
        "y": 720,
        "wires": [
            [
                "a8fe0f568d008b0a"
            ]
        ]
    },
    {
        "id": "a8fe0f568d008b0a",
        "type": "delay",
        "z": "67ce124139a68312",
        "name": "Enable Watch",
        "pauseType": "delay",
        "timeout": "1.5",
        "timeoutUnits": "seconds",
        "rate": "",
        "nbRateUnits": "",
        "randomFirst": "",
        "randomLast": "",
        "randomUnits": "seconds",
        "allowrate": false,
        "outputs": 1,
        "x": 1740,
        "y": 720,
        "wires": [
            [
                "1ccade01e7ab1f58"
            ]
        ]
    },
    {
        "id": "1ccade01e7ab1f58",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Reset Disable Watch",
        "func": "flow.set('disableWatch', false);\nreturn { payload: 'Watch node enabled' };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1980,
        "y": 720,
        "wires": [
            []
        ]
    },
    {
        "id": "35930f14f0c1d149",
        "type": "comment",
        "z": "67ce124139a68312",
        "name": "Inner function ; add AI additions together.",
        "info": "",
        "x": 1220,
        "y": 1040,
        "wires": []
    },
    {
        "id": "b898be3168fb9760",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Inject File Names",
        "func": "// Assuming githubPath is retrieved from the global context\nlet githubPath = global.get('userRootPaths').github;\n\n// Constructing the file paths dynamically using the githubPath\nconst filePaths = [\n    path.join(githubPath, 'cimaNode', 'Restructured', 'b_Middleman', 'Subfunctions', 'D1c_betCalculator copy.js'),\n    path.join(githubPath, 'cimaNode', 'Restructured', 'b_Middleman', 'Subfunctions', 'D1c_betCalculator.js'),\n    path.join(githubPath, 'cimaNode', 'Restructured', 'b_Middleman', 'Subfunctions', 'D1a_sortedBets_functions.js')\n];\n\nmsg = {\n    payload: filePaths\n};\n\nnode.send(msg);\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "path",
                "module": "path"
            }
        ],
        "x": 470,
        "y": 760,
        "wires": [
            [
                "f4d8c1d5b61dd214"
            ]
        ]
    },
    {
        "id": "62f51b767c95599c",
        "type": "debug",
        "z": "67ce124139a68312",
        "name": "Debug filename",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "filename",
        "targetType": "msg",
        "statusVal": "filename",
        "statusType": "auto",
        "x": 880,
        "y": 880,
        "wires": []
    },
    {
        "id": "e9b0dea1661ab2a6",
        "type": "inject",
        "z": "67ce124139a68312",
        "name": "Inject File Names",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "x": 230,
        "y": 760,
        "wires": [
            [
                "b898be3168fb9760"
            ]
        ]
    },
    {
        "id": "ddb31b995a1b064f",
        "type": "debug",
        "z": "67ce124139a68312",
        "name": "Debug msg",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "filename",
        "statusType": "auto",
        "x": 1270,
        "y": 880,
        "wires": []
    },
    {
        "id": "58915726be2b9b02",
        "type": "debug",
        "z": "67ce124139a68312",
        "name": "Debug msg",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "true",
        "targetType": "full",
        "statusVal": "filename",
        "statusType": "auto",
        "x": 1590,
        "y": 660,
        "wires": []
    },
    {
        "id": "b6f65ea7eb4da1df",
        "type": "inject",
        "z": "67ce124139a68312",
        "name": "Start Chat",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "0",
        "topic": "",
        "x": 1400,
        "y": 1000,
        "wires": [
            [
                "722cf7231496fff6"
            ]
        ]
    },
    {
        "id": "722cf7231496fff6",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Format Payload",
        "func": "// Extract the user message from the incoming message\nconst userMessage = msg.payload;\n\nif (!userMessage) {\n    node.error(\"No user message provided\");\n    return null;\n}\n\n// Prepend \"Error check this code\" to the user message\nconst modifiedMessage = \"Please check the following code for errors and make it more clean and concise. ONLY return the code, because I want to write it back it back into the file directly. Do not give me any other text. \\n\\n\" + userMessage;\n\n// Construct the payload for the llama3 chatbot\nmsg.payload = {\n    host: \"http://localhost:11434\",\n    model: \"deepseek-coder:6.7b\",\n    messages: [\n        { role: \"user\", content: modifiedMessage }\n    ]\n};\n\n// Pass the message on to the next node (llama3 chatbot node)\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1600,
        "y": 900,
        "wires": [
            [
                "d115becca289c5de"
            ]
        ]
    },
    {
        "id": "d115becca289c5de",
        "type": "ollama-chat",
        "z": "67ce124139a68312",
        "name": "",
        "x": 1790,
        "y": 900,
        "wires": [
            [
                "810e1d4fd254c839",
                "dfaea92025465515"
            ]
        ]
    },
    {
        "id": "43af3e4dc4268ba0",
        "type": "debug",
        "z": "67ce124139a68312",
        "name": "Stripped Message",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2190,
        "y": 900,
        "wires": []
    },
    {
        "id": "810e1d4fd254c839",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Code Block",
        "func": "// Ensure msg.payload is defined\nif (!msg.payload) {\n    node.error(\"msg.payload is undefined\");\n    return null;\n}\n\n// Ensure msg.payload.message.content is defined\nif (!msg.payload.message || !msg.payload.message.content) {\n    node.error(\"msg.payload.message.content is undefined\");\n    return null;\n}\n\n// Extract the code block from the content property\nconst inputText = msg.payload.message.content;\nconst codeBlockRegex = /```(javascript|python)([\\s\\S]*?)```/;\nconst match = inputText.match(codeBlockRegex);\n\nif (match) {\n    // Extracted code block and its language\n    const language = match[1].trim();\n    let codeBlock = match[2].trim(); // Remove leading/trailing whitespace\n\n    // Remove all instances of <｜begin▁of▁sentence｜>\n    const unwantedSequence = /<｜begin▁of▁sentence｜>/g;\n    codeBlock = codeBlock.replace(unwantedSequence, '');\n\n    msg.payload = { language, codeBlock };\n    node.warn(`Extracted ${language} code block:\\n` + codeBlock); // Debug: show the extracted code block\n} else {\n    node.error(\"No code block found in the input text.\");\n    return null;\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1990,
        "y": 900,
        "wires": [
            [
                "43af3e4dc4268ba0"
            ]
        ]
    },
    {
        "id": "dfaea92025465515",
        "type": "debug",
        "z": "67ce124139a68312",
        "name": "Chat Response",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 2020,
        "y": 1000,
        "wires": []
    },
    {
        "id": "cfe5ade48199dcf3",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Reset Disable Watch (No Change)",
        "func": "flow.set('disableWatch', false);\nreturn { payload: 'Watch node enabled (no change)' };",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1880,
        "y": 800,
        "wires": [
            []
        ]
    },
    {
        "id": "2159df481b09d187",
        "type": "delay",
        "z": "67ce124139a68312",
        "name": "Enable Watch",
        "pauseType": "delay",
        "timeout": ".3",
        "timeoutUnits": "seconds",
        "rate": "",
        "nbRateUnits": "",
        "randomFirst": "",
        "randomLast": "",
        "randomUnits": "seconds",
        "allowrate": false,
        "outputs": 1,
        "x": 1600,
        "y": 800,
        "wires": [
            [
                "cfe5ade48199dcf3"
            ]
        ]
    },
    {
        "id": "5604bb667c62adce",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Assets Indexer",
        "func": "",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "let outputMsg = Object;\n\nconst ROOT_PATHS = {\n    'LOU': {\n        log: 'C:\\\\Users\\\\LOU\\\\.node-red\\\\logs\\\\node-red.log',\n        documents: 'C:\\\\Users\\\\LOU\\\\Documents',\n        chrome: 'C:\\\\Users\\\\LOU\\\\AppData\\\\Local\\\\Google\\\\Chrome SxS\\\\Application\\\\chrome.exe',\n        github: 'C:\\\\Users\\\\LOU\\\\Documents\\\\GitHub',\n        cimaPrompts: String.raw`C:\\Users\\LOU\\Documents\\Sync\\CimaMainVault\\CimaPrompts\\Production`,\n\n    },\n    'PETER': {\n        documents: '/Users/peter/Documents',\n        chrome: '/Applications/Google Chrome Canary.app/Contents/MacOS/Google Chrome Canary',\n        github: '/Users/peter/Documents/GitHub',\n    },\n    'JANE': {\n        documents: '/home/jane/Documents',\n    },\n};\n\nconst TARGET_FOLDERS = [\n    'Sync/CimaMainVault/CimaPrompts/Production',\n];\n\nfunction getUserRootPaths() {\n    const username = os.userInfo().username.toUpperCase();\n    node.log(`Current user: ${username}`);\n    const userPaths = ROOT_PATHS[username];\n    node.log('User root paths: ' + JSON.stringify(userPaths));\n\n    // Store the user paths in the global context\n    global.set('userRootPaths', userPaths);\n\n    return userPaths;\n}\n\nfunction indexTargetFolders(rootPaths, targetFolders) {\n    const indexedPaths = {};\n\n    for (const [rootKey, rootPath] of Object.entries(rootPaths)) {\n        node.log(`\\nIndexing root path: ${rootKey} - ${rootPath}`);\n        indexedPaths[rootKey] = {};\n\n        for (const folder of targetFolders) {\n            const fullPath = path.join(rootPath, folder);\n            node.log(`Checking target folder: ${fullPath}`);\n\n            if (fs.existsSync(fullPath)) {\n                node.log(`Indexing contents of: ${fullPath}`);\n                indexedPaths[rootKey][folder] = indexDirectory(fullPath);\n            } else {\n                node.log(`Target folder not found: ${fullPath}`);\n            }\n        }\n    }\n\n    // Store the indexed paths in the global context\n    global.set('indexedPaths', indexedPaths);\n\n    return indexedPaths;\n}\n\nfunction indexDirectory(dirPath, baseObj = {}) {\n    const items = fs.readdirSync(dirPath, { withFileTypes: true });\n\n    items.forEach(item => {\n        if (item.isDirectory()) {\n            node.log(`Found directory: ${path.join(dirPath, item.name)}`);\n            baseObj[item.name] = { type: 'directory', path: path.join(dirPath, item.name), contents: {} };\n            indexDirectory(path.join(dirPath, item.name), baseObj[item.name].contents);\n        } else {\n            node.log(`Found file: ${path.join(dirPath, item.name)}`);\n            baseObj[item.name] = { type: 'file', path: path.join(dirPath, item.name) };\n        }\n    });\n\n    return baseObj;\n}\n\nfunction countItems(obj) {\n    const counts = { file: 0, directory: 0 };\n    function count(obj) {\n        for (const item of Object.values(obj)) {\n            if (item.type === 'file') {\n                counts.file++;\n            } else if (item.type === 'directory') {\n                counts.directory++;\n                count(item.contents);\n            } else if (typeof item === 'object') {\n                count(item);\n            }\n        }\n    }\n    count(obj);\n    return counts;\n}\n\n// Main function to be executed when the node receives a message\nfunction main() {\n    node.log('Starting indexing process...');\n    const userRootPaths = getUserRootPaths();\n    const indexedPaths = indexTargetFolders(userRootPaths, TARGET_FOLDERS);\n\n    node.log('\\nIndexed structure:');\n    node.log(JSON.stringify(indexedPaths, null, 2));\n\n    const counts = countItems(indexedPaths);\n\n    node.log('\\nTotal counts:');\n    node.log(`Files: ${counts.file}`);\n    node.log(`Directories: ${counts.directory}`);\n\n    // Prepare the output message\n    outputMsg.payload = {\n        indexedPaths: indexedPaths,\n        counts: counts\n    };\n\n    return outputMsg;\n}\n\n// This is the entry point for the Node-RED function node\nreturn main();",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 460,
        "y": 520,
        "wires": [
            [
                "e83c9d3383a75f0a"
            ]
        ]
    },
    {
        "id": "e83c9d3383a75f0a",
        "type": "debug",
        "z": "67ce124139a68312",
        "name": "Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 630,
        "y": 520,
        "wires": []
    },
    {
        "id": "06093ec0605a8e14",
        "type": "inject",
        "z": "67ce124139a68312",
        "name": "Start Sequence",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "start",
        "payloadType": "str",
        "x": 240,
        "y": 520,
        "wires": [
            [
                "5604bb667c62adce"
            ]
        ]
    },
    {
        "id": "2255b109a23ea4f6",
        "type": "inject",
        "z": "67ce124139a68312",
        "name": "Trigger Update",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 180,
        "y": 1160,
        "wires": [
            [
                "5c11b0e0be27f868"
            ]
        ]
    },
    {
        "id": "5c11b0e0be27f868",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Prepare Update",
        "func": "msg.method = 'GET';\nmsg.url = 'http://localhost:1880/flow/your-flow-id';\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 1160,
        "wires": [
            [
                "e55f1c0b5e2b5a23"
            ]
        ]
    },
    {
        "id": "e55f1c0b5e2b5a23",
        "type": "http request",
        "z": "67ce124139a68312",
        "name": "Get Flow",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 580,
        "y": 1160,
        "wires": [
            [
                "ca20c306ae4bf461"
            ]
        ]
    },
    {
        "id": "ca20c306ae4bf461",
        "type": "function",
        "z": "67ce124139a68312",
        "name": "Update Function Node",
        "func": "const functionNodeId = 'your-function-node-id';\nconst newFunctionCode = `\nmsg.payload = \"Updated dynamically!\";\nreturn msg;\n`;\n\nlet flow = msg.payload;\nlet functionNode = flow.nodes.find(node => node.id === functionNodeId);\nif (functionNode) {\n    functionNode.func = newFunctionCode;\n    msg.method = 'PUT';\n    msg.url = `http://localhost:1880/flow/${flow.id}`;\n    msg.payload = flow;\n    return msg;\n} else {\n    node.error('Function node not found');\n    return null;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 2,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 780,
        "y": 1160,
        "wires": [
            [
                "1f863bb49d4e2f34"
            ]
        ]
    },
    {
        "id": "1f863bb49d4e2f34",
        "type": "http request",
        "z": "67ce124139a68312",
        "name": "Update Flow",
        "method": "use",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 980,
        "y": 1160,
        "wires": [
            [
                "179990bfe6a2bd7e"
            ]
        ]
    },
    {
        "id": "179990bfe6a2bd7e",
        "type": "debug",
        "z": "67ce124139a68312",
        "name": "Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "x": 1130,
        "y": 1160,
        "wires": []
    },
    {
        "id": "f5bdf20f61bfcf55",
        "type": "comment",
        "z": "67ce124139a68312",
        "name": "Global Assets Indexer",
        "info": "",
        "x": 240,
        "y": 460,
        "wires": []
    },
    {
        "id": "4a45cc485f644505",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "Load Sports Settings",
        "func": "msg.extractMessage = msg.payload;\nmsg.timestamp = Date.now();\n\n// find query argument\nconst query = {\n};\n\n// payload for mongodb4 node\nmsg.payload = [query];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 260,
        "wires": [
            [
                "fa59f6c4d6ce4b69"
            ]
        ]
    },
    {
        "id": "e5dcf619beeb6d82",
        "type": "http in",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "",
        "url": "/LoadSettings",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 470,
        "y": 260,
        "wires": [
            [
                "4a45cc485f644505"
            ]
        ]
    },
    {
        "id": "8c83108e97fb0cd2",
        "type": "comment",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Outputs one at a time",
        "info": "",
        "x": 740,
        "y": 900,
        "wires": []
    },
    {
        "id": "3a76cd70a0954887",
        "type": "inject",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "START INJECT",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "START",
        "payloadType": "str",
        "x": 480,
        "y": 320,
        "wires": [
            [
                "4a45cc485f644505",
                "a0e98eb9e64d9cd6"
            ]
        ]
    },
    {
        "id": "ce4d24263c44e46c",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "Sports Settings Results",
        "func": "var SportsSettingsObject = {};\n\nfor (let index = 0; index < msg.result.length; index++) {\n    // Use the sports name as the key\n    let sportsName = msg.result[index].Sports;\n    SportsSettingsObject[sportsName] = msg.result[index];\n}\n\n// Set the object in the global context after the loop\ncontext.global.set('SportsSettings', SportsSettingsObject);\n\nmsg.SportsSettingsObject = SportsSettingsObject;\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 260,
        "wires": [
            [
                "5926f857c39fa7f8"
            ]
        ]
    },
    {
        "id": "5926f857c39fa7f8",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "Sports Settings",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1740,
        "y": 260,
        "wires": []
    },
    {
        "id": "a0e98eb9e64d9cd6",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "Load Stake Settings",
        "func": "msg.extractMessage = msg.payload;\nmsg.timestamp = Date.now();\n\n// find query argument\nconst query = {\n};\n\n// payload for mongodb4 node\nmsg.payload = [query];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 340,
        "wires": [
            [
                "a9efc5167470cd12"
            ]
        ]
    },
    {
        "id": "a9efc5167470cd12",
        "type": "mongodb4",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "StakeSettings",
        "operation": "find",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "StakeSettings.find.toArray",
        "x": 1180,
        "y": 340,
        "wires": [
            [
                "97dedff557300f31"
            ]
        ]
    },
    {
        "id": "97dedff557300f31",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "Stake Settings Results",
        "func": "// Set a global context variable using a message\ncontext.global.set('StakeSettings', msg.payload);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 340,
        "wires": [
            [
                "29ee4f96d6e5d988"
            ]
        ]
    },
    {
        "id": "29ee4f96d6e5d988",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "name": "Stake Settings",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1740,
        "y": 340,
        "wires": []
    },
    {
        "id": "651a04261d7b2c0e",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Transform 2: LineType Sorter",
        "func": "var incomingMessage = msg;\n\n//--------------------------------------\n// OUTPUT TO LINE TYPE CALCULATORS\n// Define output names and their corresponding indexes\nconst outputMapping = {\n    \"POINTSPREAD\": 0,\n    \"TOTAL\": 1,\n    \"MONEYLINE\": 2,\n    // Add more output names and indexes as needed\n};\n\nlet outputIndex;\n\nfunction outputMappedSend(currentResult, outputIndex) {\n    // Create an array to store messages for each output, initialized with null values\n    const outputs = Array(Object.keys(outputMapping).length).fill(null);\n\n    // Construct a new message object for the output\n    var outputMessage = {\n        req: incomingMessage.req, // Spread operator to copy existing msg properties\n        res: incomingMessage.res,\n        transform1Message: {combinedResults : incomingMessage.combinedResults, resultsArray : incomingMessage.resultsArray},\n        transform2Message: currentResult,\n        extractMessage: incomingMessage.extractMessage\n    };\n\n    // Ensure the extractMessage doesn't carry over unnecessary properties\n    if (outputMessage.extractMessage) {\n        delete outputMessage.transform1Message.extractMessage;\n    }\n\n    \n    // Assign the new message to the appropriate output based on the index\n    outputs[outputIndex] = outputMessage;\n\n    // Send the messages. Only the targeted output index will have a non-null message.\n    node.send([outputs]);\n}\n\n//------------\n//Calculate Length and iterate through\n// a. For resultLength Check msg.resultsArray\n// b. Switch Route it Through\n// c. The router calls a function.\n// Assuming msg.resultsArray is an array\n\nfor (let i = 0; i < incomingMessage.resultsArray.length; i++) {\n    // Access each element using msg.resultsArray[i]\n    let currentResult = incomingMessage.resultsArray[i];\n\n    // Determine the index of the desired output based on the LineType\n    switch (incomingMessage.resultsArray[i].LineType) {\n        case 'POINTSPREAD':\n            outputIndex = outputMapping[\"POINTSPREAD\"];\n            outputMappedSend(currentResult, outputIndex);\n            break;\n        case 'TOTAL':\n            outputIndex = outputMapping[\"TOTAL\"];\n            outputMappedSend(currentResult, outputIndex);\n            break;\n        case 'MONEYLINE':\n            outputIndex = outputMapping[\"MONEYLINE\"];\n            outputMappedSend(currentResult, outputIndex);\n            break;\n        default:\n            // Handle default case (optional)\n            node.warn('Unknown LineType: ', incomingMessage.resultsArray[i]);\n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 3,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 840,
        "wires": [
            [
                "6aa833b66249717c",
                "6eb1d3bdf91d9769"
            ],
            [
                "6de8c17c083cb8f4"
            ],
            [
                "fb9fbb9ae42710bd"
            ]
        ],
        "outputLabels": [
            "POINTSPREAD",
            "TOTAL",
            "MONEYLINE"
        ]
    },
    {
        "id": "c99ea954399ff73e",
        "type": "link in",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "SBCheck Ph2: IN : Transform1 : Split Messages > Line Type Sorter",
        "links": [
            "79223214381a0e94"
        ],
        "x": 415,
        "y": 840,
        "wires": [
            [
                "651a04261d7b2c0e"
            ]
        ]
    },
    {
        "id": "6aa833b66249717c",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Transform 2: Pointspread",
        "func": "// 3. Check Bet \n    // If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n    // If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n    // Then calculate line ; vig ; outcomes\n    // Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n    // Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform2Message = incomingMessageVar.transform2Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform2Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n        \n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n        \n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n    \n    return result;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    main.PointspreadPointsDifference = transform2Message['Bet1'].Line1PointsAmFloat + transform2Message['Bet2'].Line2PointsAmFloat\n\n    main.PointspreadRangeMin = SportsSettingsVar[main.sport].PointspreadRangeMin;\n    main.PointspreadRangeMax = SportsSettingsVar[main.sport].PointspreadRangeMax;\n\n    // Calculate Range Rating\n    main.PointspreadPointsDifferenceRating = main.PointspreadPointsDifference / main.PointspreadRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n    \n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n    \n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        main.line[i] = transform2Message[`Bet${i}`];        \n        main.line[i].lineValue = transform2Message[`Bet${i}`][`Line${i}PriceAmML`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win; \n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;            \n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n    \n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n    \n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n    \n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n \n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n    \n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n    \n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.PointspreadPointsDifference >= main.PointspreadRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }   \n    // B: If Arb Less than Range min & greater than 0\n    else if (main.PointspreadPointsDifference < main.PointspreadRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15){\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.PointspreadPointsDifference < main.PointspreadRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else{\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\"){\n        main.line[1].stake = globalStake; \n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\"){\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1/100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2/100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform2Message = incomingMessageVar.transform2Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform2Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 6,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 820,
        "wires": [
            [
                "c59ac708faab91cb",
                "f617a066e7adfd41"
            ]
        ]
    },
    {
        "id": "6eb1d3bdf91d9769",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Debug PspreadSorter",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 780,
        "wires": []
    },
    {
        "id": "6de8c17c083cb8f4",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Transform 2: Totals",
        "func": "// 3. Check Bet \n// If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n// If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n// Then calculate line ; vig ; outcomes\n// Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n// Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform2Message = incomingMessageVar.transform2Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform2Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    main.TotalsPointsDifference = transform2Message['Bet1'].Line1PointsAmFloat + transform2Message['Bet2'].Line2PointsAmFloat\n\n    main.TotalsRangeMin = SportsSettingsVar[main.sport].TotalsRangeMin;\n    main.TotalsRangeMax = SportsSettingsVar[main.sport].TotalsRangeMax;\n\n    // Calculate Range Rating\n    main.TotalsPointsDifferenceRating = main.TotalsPointsDifference / main.TotalsRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        main.line[i] = transform2Message[`Bet${i}`];\n        main.line[i].lineValue = transform2Message[`Bet${i}`][`Line${i}PriceAmML`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.TotalsPointsDifference >= main.TotalsRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.TotalsPointsDifference < main.TotalsRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.TotalsPointsDifference < main.TotalsRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform2Message = incomingMessageVar.transform2Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform2Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 6,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 860,
        "wires": [
            [
                "f617a066e7adfd41"
            ]
        ]
    },
    {
        "id": "fb9fbb9ae42710bd",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Transform 2: Moneyline",
        "func": "// 3. Check Bet \n// If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n// If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n// Then calculate line ; vig ; outcomes\n// Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n// Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform2Message = incomingMessageVar.transform2Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform2Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    main.MoneylineDifference = transform2Message['Bet1'].Line1PointsAmFloat + transform2Message['Bet2'].Line2PointsAmFloat\n\n    main.MoneylineRangeMin = SportsSettingsVar[main.sport].MoneylineRangeMin;\n    main.MoneylineRangeMax = SportsSettingsVar[main.sport].MoneylineRangeMax;\n\n    // Calculate Range Rating\n    main.MoneylineDifferenceRating = main.MoneylineDifference / main.MoneylineRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        main.line[i] = transform2Message[`Bet${i}`];\n        main.line[i].lineValue = transform2Message[`Bet${i}`][`Line${i}PriceAmML`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.MoneylineDifference >= main.MoneylineRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MONEYLINEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.MoneylineDifference < main.MoneylineRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.MoneylineDifference < main.MoneylineRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform2Message = incomingMessageVar.transform2Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform2Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 6,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 900,
        "wires": [
            [
                "f617a066e7adfd41"
            ]
        ]
    },
    {
        "id": "c59ac708faab91cb",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Debug PSpread",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 820,
        "wires": []
    },
    {
        "id": "f617a066e7adfd41",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Transform 2: Comparative Bets",
        "func": "\nvar incomingMessage = msg;\nvar msgIDVar = msg._msgid;\nvar resultCounter = incomingMessage.transform1Message.resultsArray.length;\nvar main = {};\nvar tenPercentStake = 10;\nvar vigMax = 5;\nvar arbPercentageRangeMin = 4;\nvar vigSplitRangeMin = 15;\nvar moneylineRangeMin = 21;\n\n//===================================\n// Buffer Functions\n// Initialize a buffer object if it doesn't exist\nif (!context.get(\"buffer\")) {\n    context.set(\"buffer\", {});\n}\n\n\n// Initialize a timeout object to keep track of message timeouts\nif (!context.get(\"timeouts\")) {\n    context.set(\"timeouts\", {});\n}\n\nlet buffer = context.get(\"buffer\");\n\nlet timeouts = context.get(\"timeouts\");\nconst timeoutDuration = 60000; // Timeout duration in milliseconds (1 minute)\n\n\n// Ensure buffer entry exists and initialize it as an empty array if it doesn't\nif (!buffer[msgIDVar]) {\n    buffer[msgIDVar] = {};\n    buffer[msgIDVar].messages = [];\n}\n\n// Add the incoming message to the buffer array for this msgIDVar\nbuffer[msgIDVar].messages.push(incomingMessage);\ncontext.set(\"buffer\", buffer); // Persist the updated buffer\n\n\n// Check if we need to set a timeout for this msgIDVar\nif (!timeouts[msgIDVar]) {\n    timeouts[msgIDVar] = setTimeout(() => {\n        cleanupBuffer(msgIDVar); // Cleanup function called after timeout\n        node.warn(`Cleanup performed for msgIDVar ${msgIDVar} due to timeout.`);\n    }, timeoutDuration);\n    context.set(\"timeouts\", timeouts); // Persist the updated timeouts\n}\n\n\n// Function to clean up the buffer and timeouts\nfunction cleanupBuffer(msgIDVar) {\n    const index = msgIDVar;\n    delete buffer[index]; // Remove the message group from the buffer\n    delete timeouts[index]; // Remove the timeout for this message group\n    context.set(\"buffer\", buffer); // Update the buffer in flow context\n    context.set(\"timeouts\", timeouts); // Update the timeouts in flow context\n}\n\n//=========================\n// CALCULATION FUNCTIONS\n// 4. figure out which is the original message\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit \n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n// General function to extract and sort messages by a specified property path\nfunction extractAndSortByProperty(messages, propertyPath) {\n    // Split the property path into parts for nested properties\n    const pathParts = propertyPath.split('.');\n\n    // Map and extract the specified property value, handling nested properties\n    const extractedValues = messages.map((message, index) => {\n        let value = message.transform2Message;\n        for (const part of pathParts) {\n            value = value ? value[part] : undefined;\n        }\n        return { messageIndex: index, value };\n    });\n\n    // Filter out any undefined values that may not exist for the specified property\n    const filteredValues = extractedValues.filter(item => item.value !== undefined);\n\n    // Sort the filtered array by the specified property in descending order\n    filteredValues.sort((a, b) => b.value - a.value);\n\n    return filteredValues;\n}\n\n\nfunction calculateComparison(){\n// Calculate Within  PointSpread , Totals, Moneyline\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit\n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n\n    // -------------------\n\n    // Check if the incomingMessage.transform2Message is the main bet to compare all results\n    if (incomingMessage.transform2Message && incomingMessage.transform2Message._id == incomingMessage.extractMessage._id){\n        // Set Bet Type\n        main.BetType = incomingMessage.transform2Message.BetType; \n    }\n\n\n    // A: If MIDDLEBET\n    if (main.BetType == \"MIDDLEBET\"){\n\n        // Filter results by BetType\n        let middleBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"MIDDLEBET\"\n        );\n        // Check if it doesn't exist\n        if (middleBetMessages.length <= 0){\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else{\n            // Example: Sort by 'PointspreadPointsDifference'\n            let sortedByPointspread = extractAndSortByProperty(buffer[msgIDVar].messages, 'PointspreadPointsDifference');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform2Message.PointspreadPointsDifference > sortedByPointspread[0])\n            {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else {\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // B: If ARBBET\n    if (main.BetType == \"ARBBET\") {\n       \n        // Filter results by BetType\n        let arbBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"ARBBET\"\n        );\n        // Check if it doesn't exist\n        if (arbBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else {\n            // Example: Sort by nested 'arbResults.ArbPercentage'\n            let sortedByArbPercentage = extractAndSortByProperty(buffer[msgIDVar].messages, 'arbResults.ArbPercentage');\n\n            // Example: Sort by nested 'arbResults.ArbProfit1'\n            let sortedByArbProfit1 = extractAndSortByProperty(buffer[msgIDVar].messages, 'arbResults.ArbProfit1');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform2Message.arbResults.ArbPercentage > (sortedByArbPercentage[0] + 3) || incomingMessage.transform2Message.arbResults.ArbProfit1 > (sortedByArbProfit1[0] + tenPercentStake)) {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else{\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // C: If Vigsplitbet\n    if (main.BetType == \"VIGSPLITBET\") {\n\n        // Filter results by BetType\n        let vigsplitBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"VIGSPLITBET\"\n        );\n        // Check if it doesn't exist\n        if (vigsplitBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n        // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n    // D: If Vigsplitbet\n    if (main.BetType == \"MONEYLINEBET\") {\n\n        // Filter results by BetType\n        let moneylineBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"MONEYLINEBET\"\n        );\n        // Check if it doesn't exist\n        if (moneylineBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n            // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n\n    //--------------------\n    // CHECK IF NO RESULTS ; RETURN IF NONE\n    if (incomingMessage.transform1Message.resultsArray.length == 1) {\n        main.SameGame = \"Clear\";\n    }\n    \n}\n\nfunction calculateProfit() {\n\n    // CHECK MIDDLEBET\n    if (incomingMessage.transform2Message.BetType == \"MIDDLEBET\"){\n        if (incomingMessage.transform2Message.PointspreadPointsDifference >= incomingMessage.transform2Message.PointspreadRangeMin)\n        {main.profitCheck = true;}\n        else{ main.profitCheck = false;}\n    }\n    // CHECK ARBBET\n    else if(incomingMessage.transform2Message.BetType == \"ARBBET\"){\n        if (incomingMessage.transform2Message.arbResults.ArbPercentage >= arbPercentageRangeMin)\n        { main.profitCheck = true; }\n        else { main.profitCheck = false; }      \n    }\n    // CHECK VIGSPLITBET\n    else if (incomingMessage.transform2Message.BetType == \"VIGSPLITBET\"){\n        if (incomingMessage.transform2Message.vigSplitProfit >= vigSplitRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK MONEYLINEBET\n    else if (incomingMessage.transform2Message.BetType == \"MONEYLINEBET\") {\n        if (incomingMessage.transform2Message.moneylineDifference > moneylineRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK VIGMAX\n    if (incomingMessage.transform2Message.TotalVig > vigMax){\n        main.profitCheck = false;\n    }\n\n}\n\n\n//========================\n// EXECUTION FUNCTIONS\n\n// If we have collected resultCounter messages for this msgIDVar, process them\nif (buffer[msgIDVar].messages.length === resultCounter) {\n\n    //-------------\n    //iterate through the incomingMessage.resultsArray[i]._id and check if it there are matches to the ones in the buffer\n    let matchesCount = 0;\n\n    // Example of improved match checking, avoiding incorrect index access\n    buffer[msgIDVar].messages.forEach((bufferedMsg, index) => {\n        if (bufferedMsg.transform2Message && incomingMessage.transform1Message.resultsArray.some(res => res._id === bufferedMsg.transform2Message._id)) {\n            matchesCount++;\n        }\n    });\n\n    //------------\n    // IF all messages exist, and complete.\n    if (matchesCount == incomingMessage.transform1Message.resultsArray.length) {\n        \n \n        clearTimeout(timeouts[msgIDVar]); // Important to clear timeout\n        context.set(\"timeouts\", timeouts); // Persist timeouts changes\n\n        // CALCULATE HERE\n        calculateComparison();\n        calculateProfit();\n        \n        // ADD ALL KEYS\n        for (const [key, value] of Object.entries(main)) {\n            incomingMessage.transform2Message[key] = value;\n        }\n        \n        // Prep Message and Send\n        var newMsg = {...msg};\n        newMsg.matches = matchesCount;\n        newMsg.extractMessage = msg.extractMessage;\n        newMsg.transform2Message = incomingMessage.transform2Message;\n        newMsg.transform1Message = incomingMessage.transform1Message;\n        newMsg.transformResults = incomingMessage.transformResults;\n        newMsg.main = main;\n\n        // Send the combined message on\n        node.send(newMsg);\n\n        // Cleanup buffer and timeouts for this msgIDVar\n        cleanupBuffer(msgIDVar);\n    } else {\n        // Handle case where results are missing\n        node.error(\"Not matching length\", msg);\n    }\n\n}\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 880,
        "wires": [
            [
                "6c93cf3ab8ccd07f",
                "273cefe442d4e299"
            ]
        ]
    },
    {
        "id": "3849cc7df492b362",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "Transform1 : Comparative Query Results",
        "func": "var msgIDVar = msg._msgid;\n\n// Initialize a buffer object if it doesn't exist\nif (!context.get(\"buffer\")) {\n    context.set(\"buffer\", {});\n}\n\n// Initialize a timeout object to keep track of message timeouts\nif (!context.get(\"timeouts\")) {\n    context.set(\"timeouts\", {});\n}\n\nlet buffer = context.get(\"buffer\");\nlet timeouts = context.get(\"timeouts\");\nconst timeoutDuration = 60000; // Timeout duration in milliseconds (1 minute)\n\n// Function to clean up the buffer and timeouts\nfunction cleanupBuffer(msgIDVar) {\n    const index = msgIDVar;\n    delete buffer[index]; // Remove the message group from the buffer\n    delete timeouts[index]; // Remove the timeout for this message group\n    context.set(\"buffer\", buffer); // Update the buffer in flow context\n    context.set(\"timeouts\", timeouts); // Update the timeouts in flow context\n}\n\n// Ensure buffer entry exists and initialize it as an empty array if it doesn't\nif (!buffer[msgIDVar]) {\n    buffer[msgIDVar] = [];\n}\n\n// Add the incoming message to the buffer array for this msgIDVar\nbuffer[msgIDVar].push(msg);\n\n// Check if we need to set a timeout for this msgIDVar\nif (!timeouts[msgIDVar]) {\n    timeouts[msgIDVar] = setTimeout(() => {\n        cleanupBuffer(msgIDVar); // Cleanup function called after timeout\n        node.warn(`Cleanup performed for msgIDVar ${msgIDVar} due to timeout.`);\n    }, timeoutDuration);\n}\n\n// If we have collected 3 messages for this msgIDVar, process them\nif (buffer[msgIDVar].length === 3) {\n    //node.send(msg);\n    \n    // Check if all required collections are present\n    const collections = [\"InProgressBets\", \"CompletedTransactions\", \"SortedBets\"];\n    const collectedCollections = buffer[msgIDVar].map(msg => msg.collection);\n\n    if (collections.every(collection => collectedCollections.includes(collection))) {\n        clearTimeout(timeouts[msgIDVar]); // Cancel the timeout as we're processing the messages\n        let combinedResults = {};\n\n        // Process messages based on their collections\n        buffer[msgIDVar].forEach((messageVar) => {\n            combinedResults[messageVar.collection] = messageVar.result;\n        });\n\n        // Add a new combo property, clean up\n        msg.combinedResults = combinedResults;\n        delete msg.payload;\n        delete msg.queryID;\n        delete msg.query;\n        delete msg.result;\n        delete msg.collection;\n\n        // Send the combined message on\n        node.send(msg);\n\n        // Cleanup buffer and timeouts for this msgIDVar\n        cleanupBuffer(msgIDVar); \n    } else {\n        // Handle case where required collections are missing\n        node.error(\"Not all required collections are present in the buffered messages.\", msg);\n    }\n    \n}\n\nreturn null; // Prevent sending the original message onwards",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 600,
        "wires": [
            [
                "1fe4967103d1edc8",
                "3f833d99e1e7b34b"
            ]
        ]
    },
    {
        "id": "a16a17c27bd71bd6",
        "type": "mongodb4",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "SortedBets",
        "operation": "aggregate",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "SortedBets.aggregate.toArray",
        "x": 930,
        "y": 660,
        "wires": [
            [
                "3849cc7df492b362",
                "5bd19c03c084c56e"
            ]
        ]
    },
    {
        "id": "16001f67efa309e1",
        "type": "mongodb4",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "InProgressBets",
        "operation": "aggregate",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "InProgressBets.aggregate.toArray",
        "x": 940,
        "y": 600,
        "wires": [
            [
                "3849cc7df492b362"
            ]
        ]
    },
    {
        "id": "81f5f6ed3582f4a7",
        "type": "mongodb4",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "CompletedTransactions",
        "operation": "aggregate",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "CompletedTransactions.aggregate.toArray",
        "x": 960,
        "y": 560,
        "wires": [
            [
                "3849cc7df492b362"
            ]
        ]
    },
    {
        "id": "1fe4967103d1edc8",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "results",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1450,
        "y": 660,
        "wires": []
    },
    {
        "id": "3f833d99e1e7b34b",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "Spit Messages",
        "func": "// Extract the input array\nvar incomingMessage = msg;\nvar newMsg = msg;\n\n    // MAKE ARRAY\n    var resultsArray = [];\n\n    // Define the properties to check\n    var resultsToGet = [\n        'SortedBets',\n        'InProgressBets',\n        'CompletedTransactions',\n    ];\n\n    // Iterate over the properties and push non-empty values to the array\n    resultsToGet.forEach(property => {\n        // Check if the property exists and is not undefined, and if it is an array\n        if (msg.combinedResults[property] && Array.isArray(msg.combinedResults[property].result)) {\n            // Iterate over the elements of the array and push them to the resultsArray\n            msg.combinedResults[property].result.forEach(entry => {\n                resultsArray.push(entry);\n            });\n        }\n    });\n    \n    // Push the original message\n    resultsArray.push(msg.extractMessage.item);\n\n    // Apply to the newMsg\n    newMsg.resultsArray = resultsArray;\n\n    // Send Message\n    node.send(newMsg);\n\n\n// Optionally, you can return null to prevent the original message from being passed to the next node\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1540,
        "y": 600,
        "wires": [
            [
                "79223214381a0e94",
                "6a4c7c8a5d485e67"
            ]
        ]
    },
    {
        "id": "7e905be2ddbf209f",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "set payload",
        "func": "let item = msg.extractMessage.item;\n\nconst oneWeekAgo = new Date(Date.now() - 12 * 7 * 24 * 60 * 60 * 1000); // 12 weeks ago\n\nconst GeneralBetsPipeline = [\n    {\n        $match: {\n            TimeStamp: {\n                $gte: oneWeekAgo,\n                $lt: new Date(),\n            },\n            $and: [\n                // Condition 1: Check if Item.GameNumber is the same\n                { GameNumber: { $eq: item.GameNumber } },\n                // Condition 1a: Check if Item.GameNumber is the same\n                { Sport: { $eq: item.Sport } },\n                // Condition 1b: Check if Item.GameNumber is the same\n                { League: { $eq: item.League } },\n                // Condition 2: Check if Item.Bet1.Book1 is different\n                { \"Bet1.Book1\": { $ne: item.Book1 } },\n                // Condition 3: Check if Item.Bet2.Book2 is different\n                { \"Bet2.Book2\": { $ne: item.Book2 } },\n                // Condition 4: Check Team 1\n                { \"Bet1.Team1\": { $ne: item.Team1 } },\n                // Condition 5: Check Team 2\n                { \"Bet2.Team2\": { $ne: item.Team2 } },\n                // Condition 6: Check if Bet1.BookNameAccountNameAssigned1 is different\n                { \"Bet1.BookNameAccountNameAssigned1\": { $ne: item.BookNameAccountName1 } },\n                // Condition 7: Check if Bet1.BookNameAccountNameAssigned2 is different\n                { \"Bet2.BookNameAccountNameAssigned2\": { $ne: item.BookNameAccountName2 } },\n                \n                // Condition 8: Check if Item.PointsDifference is equal or higher\n\n                // { PointsDifference: { $gt: item.PointsDifference } },\n                // Condition 5: Check if item.RoughSum is higher\n                // { PotentialProfit: { $gt: item.RoughSum } },\n            ],\n        },\n    },\n    {\n        $sort: {\n            GameNumber: -1,\n            LineType: -1,\n            Team1: -1,\n            Line1PriceAmML: -1,\n            Line1PointsAmFloat: -1,\n            TimeStamp: -1,\n        },\n    },\n    {\n        $limit: 1000,\n    },\n];\n\nmsg.payload = [GeneralBetsPipeline];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 600,
        "wires": [
            [
                "a16a17c27bd71bd6",
                "16001f67efa309e1",
                "81f5f6ed3582f4a7"
            ]
        ]
    },
    {
        "id": "5bd19c03c084c56e",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "output query",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 660,
        "wires": []
    },
    {
        "id": "6a4c7c8a5d485e67",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "Split Message",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 660,
        "wires": []
    },
    {
        "id": "79223214381a0e94",
        "type": "link out",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "SBCheck Ph1 : OUT : Transform1 : Split Messages > Line Type Sorter",
        "mode": "link",
        "links": [
            "c99ea954399ff73e"
        ],
        "x": 1645,
        "y": 600,
        "wires": []
    },
    {
        "id": "c4b93446aa230ff6",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "EXTRACT : Receive POST",
        "func": "// PRIOR TO SET FIELDS - COMING FROM RAWDBS\nvar idVar = msg.payload.message._id;\n\nmsg.extractMessage = {\n    announce: 'Received POST request at:',\n    timestamp: msg.timestamp,\n    _id: idVar,\n    item: msg.payload.message,\n};\n\n//1. Timestamp ----------------\n\n// GENERATE A TIMESTAMP (SPECIFIC TO PIPELINE)\n// Generate a timestamp for every incoming message\n\n\n// Retrieve the last stored message's timestamp\nvar lastTimestamp = flow.get(\"sortedBetsCheckConditions_lastTimestamp\") || 0;\n\n// Check if the incoming message is newer\nif (msg.timestamp > lastTimestamp) {\n    // Update the context with the new message payload and timestamp\n    flow.set(\"sortedBetsCheckConditions_rememberedPayload\", msg.payload);\n    flow.set(\"sortedBetsCheckConditions_lastTimestamp\", msg.timestamp);\n} else {\n    // Ignore the message, as it's older than what we have stored\n}\n\n//2. QUEUE ----------------\n\n// Retrieve the existing queue or initialize a new one\nvar messageQueue = flow.get(\"sortedBetsCheckConditions_messageQueue\") || [];\n\n// Add the incoming message to the queue\nmessageQueue.push({ payload: msg.payload});\n\n// Update the queue in the context\nflow.set(\"sortedBetsCheckConditions_messageQueue\", messageQueue);\n\n// Time limit in milliseconds (10 minutes)\nconst timeLimit = 10 * 60 * 1000; // 10 minutes * 60 seconds * 1000 milliseconds\n\n// Filter the queue to keep only messages from the last 10 minutes\nmessageQueue = messageQueue.filter(item => Date.now() - item.payload.timestamp <= timeLimit);\n\n// Save the updated queue back to the node context\nflow.set('sortedBetsCheckConditions_messageQueue', messageQueue);\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 600,
        "wires": [
            [
                "7e905be2ddbf209f"
            ]
        ]
    },
    {
        "id": "4ca12deadd3be409",
        "type": "http in",
        "z": "5fa172c20f49443b",
        "g": "dd2f628224cbb4c3",
        "name": "",
        "url": "/SortedBetsCheckConditions",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 540,
        "y": 540,
        "wires": [
            [
                "c4b93446aa230ff6"
            ]
        ]
    },
    {
        "id": "273cefe442d4e299",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "Debug COMPARE",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1710,
        "y": 820,
        "wires": []
    },
    {
        "id": "118cd677cd25eb05",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "803b92c8ed55dc13",
        "name": "Load: Pack to HTTP",
        "func": "\nvar incomingMessage = msg;\n\n\n//===================================\nmsg.statusCode = 200; // Set HTTP status code to 200 OK\nmsg.headers = {\n    \"Content-Type\": \"text/plain\" // Set Content-Type header to text/plain\n};\n// Skip the Sort\nmsg.payload = {\n    extractMessage: incomingMessage.extractMessage,\n    finalMessage: incomingMessage.transform2Message,\n    transform1Message: incomingMessage.transform1Message,\n    _msgid: incomingMessage._msgid\n};\n\nmsg.req = incomingMessage.req;\nmsg.res = incomingMessage.res;\n//========================\n// EXECUTION FUNCTIONS\n\nnode.send(msg);\nreturn null\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 1060,
        "wires": [
            [
                "75d6aaab0021d346",
                "3bdb39087ef4d457"
            ]
        ]
    },
    {
        "id": "75d6aaab0021d346",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "803b92c8ed55dc13",
        "name": "Debug RESPONSE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1000,
        "wires": []
    },
    {
        "id": "3bdb39087ef4d457",
        "type": "http response",
        "z": "5fa172c20f49443b",
        "g": "803b92c8ed55dc13",
        "name": "HTTP RESP 2",
        "statusCode": "",
        "headers": {},
        "x": 1720,
        "y": 1060,
        "wires": []
    },
    {
        "id": "6c93cf3ab8ccd07f",
        "type": "link out",
        "z": "5fa172c20f49443b",
        "g": "b7f2bcc8b657be27",
        "name": "SBCheck Ph2: OUT :  > Load: Pack to HTTP",
        "mode": "link",
        "links": [
            "62e4b98de6625a13"
        ],
        "x": 1785,
        "y": 880,
        "wires": []
    },
    {
        "id": "62e4b98de6625a13",
        "type": "link in",
        "z": "5fa172c20f49443b",
        "g": "803b92c8ed55dc13",
        "name": "SBCheck Ph3 : IN : Compare > Load: Pack to HTTP",
        "links": [
            "6c93cf3ab8ccd07f"
        ],
        "x": 415,
        "y": 1060,
        "wires": [
            [
                "118cd677cd25eb05"
            ]
        ]
    },
    {
        "id": "272b6d76a23994ba",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "EXTRACT : Receive POST",
        "func": "// PRIOR TO SET FIELDS - COMING FROM RAWDBS\nlet incomingMessage = msg;\n\nmsg.extractMessage = {\n    announce: 'Received POST request at:',\n    timestamp: msg.timestamp,\n    originalMessage: msg.payload,\n};\n\nmsg.scraped_bet = {\n    scraped_line: incomingMessage.payload.scrapeResults.scraped_line,\n    scraped_points: incomingMessage.payload.scrapeResults.scraped_points,\n    scraped_odds: incomingMessage.payload.scrapeResults.scraped_odds,\n    scraped_lineType: incomingMessage.payload.scrapeResults.scraped_linetype, // Note the lowercase 't' in 'linetype'\n    scraped_game_number: incomingMessage.payload.scrapeResults.scraped_game_number,\n    scraped_team: incomingMessage.payload.scrapeResults.scraped_team,\n    scraped_sport: incomingMessage.payload.scrapeResults.scraped_sport,\n    scraped_timestamp: incomingMessage.payload.scrapeResults.scraped_timestamp\n};\n\nmsg.fullMessage = incomingMessage.payload.fullBet;\n\n//1. Timestamp ----------------\n\n// GENERATE A TIMESTAMP (SPECIFIC TO PIPELINE)\n// Generate a timestamp for every incoming message\n\n\n// Retrieve the last stored message's timestamp\nvar lastTimestamp = flow.get(\"BetInputCheck_lastTimestamp\") || 0;\n\n// Check if the incoming message is newer\nif (msg.timestamp > lastTimestamp) {\n    // Update the context with the new message payload and timestamp\n    flow.set(\"BetInputCheck_rememberedPayload\", msg.payload);\n    flow.set(\"BetInputCheck_lastTimestamp\", msg.timestamp);\n} else {\n    // Ignore the message, as it's older than what we have stored\n}\n\n//2. QUEUE ----------------\n\n// Retrieve the existing queue or initialize a new one\nvar messageQueue = flow.get(\"BetInputCheck_messageQueue\") || [];\n\n// Add the incoming message to the queue\nmessageQueue.push({ payload: msg.payload});\n\n// Update the queue in the context\nflow.set(\"BetInputCheck_messageQueue\", messageQueue);\n\n// Time limit in milliseconds (10 minutes)\nconst timeLimit = 10 * 60 * 1000; // 10 minutes * 60 seconds * 1000 milliseconds\n\n// Filter the queue to keep only messages from the last 10 minutes\nmessageQueue = messageQueue.filter(item => Date.now() - item.payload.timestamp <= timeLimit);\n\n// Save the updated queue back to the node context\nflow.set('BetInputCheck_messageQueue', messageQueue);\n\ndelete msg.payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2570,
        "y": 600,
        "wires": [
            [
                "f4d0bfed3d6727e6",
                "5f817b78b5dfe714"
            ]
        ]
    },
    {
        "id": "9d42e07bd472374f",
        "type": "comment",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Outputs one at a time",
        "info": "",
        "x": 2310,
        "y": 960,
        "wires": []
    },
    {
        "id": "aab5da598ff97b79",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: LineType Sorter",
        "func": "var incomingMessage = msg;\n//--------------------------------------\n// OUTPUT TO LINE TYPE CALCULATORS\n// Define output names and their corresponding indexes\nconst outputMapping = {\n    \"POINTSPREAD\": 0,\n    \"TOTAL\": 1,\n    \"MONEYLINE\": 2,\n    // Add more output names and indexes as needed\n};\n\nlet outputIndex;\n\nfunction outputMappedSend(currentResult, outputIndex) {\n    // Create an array to store messages for each output, initialized with null values\n    const outputs = Array(Object.keys(outputMapping).length).fill(null);\n    \n    \n    // Construct a new message object for the output\n    var outputMessage = {\n        req: incomingMessage.req, // Spread operator to copy existing msg properties\n        res: incomingMessage.res,\n        transform1Message: currentResult,\n        extractMessage: incomingMessage.extractMessage,\n        fullMessage: incomingMessage.fullMessage\n    };\n    delete outputMessage.transform1Message.extractMessage;\n    delete outputMessage.transform1Message.extractMessage;\n    delete outputMessage.transform1Message.req;\n    delete outputMessage.transform1Message.res;\n    \n\n    \n\n    // Ensure the extractMessage doesn't carry over unnecessary properties\n    if (outputMessage.extractMessage) {\n//        delete outputMessage.transform1Message.extractMessage;\n    }\n\n    // Assign the new message to the appropriate output based on the index\n    outputs[outputIndex] = outputMessage;\n\n    // Send the messages. Only the targeted output index will have a non-null message.\n    node.send([outputs]);\n}\n\n//------------\n//SWITCH\n\nlet currentResult = incomingMessage;\n\n// Determine the index of the desired output based on the LineType\nswitch (incomingMessage.scraped_bet_1.scraped_lineType) {\n    case 'POINTSPREAD':\n        outputIndex = outputMapping[\"POINTSPREAD\"];\n        outputMappedSend(currentResult, outputIndex);\n        break;\n    case 'TOTAL':\n        outputIndex = outputMapping[\"TOTAL\"];\n        outputMappedSend(currentResult, outputIndex);\n        break;\n    case 'MONEYLINE':\n        outputIndex = outputMapping[\"MONEYLINE\"];\n        outputMappedSend(currentResult, outputIndex);\n        break;\n    default:\n        // Handle default case (optional)\n        node.warn('Unknown LineType: ', incomingMessage);\n}",
        "outputs": 3,
        "timeout": "",
        "noerr": 3,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2240,
        "y": 900,
        "wires": [
            [
                "b4dca9fd7958c13f",
                "12551b69148dc875"
            ],
            [
                "18ee888a0e0c3587"
            ],
            [
                "740d874372634aa9"
            ]
        ],
        "outputLabels": [
            "POINTSPREAD",
            "TOTAL",
            "MONEYLINE"
        ]
    },
    {
        "id": "6d7830c85b50c511",
        "type": "link in",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": " BetInputCheck Ph2: IN : Transform1 : Split Messages > Line Type Sorter",
        "links": [
            "74c06399d74963b0"
        ],
        "x": 1985,
        "y": 900,
        "wires": [
            [
                "aab5da598ff97b79"
            ]
        ]
    },
    {
        "id": "b4dca9fd7958c13f",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Pointspread",
        "func": "// 3. Check Bet \n    // If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n    // If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n    // Then calculate line ; vig ; outcomes\n    // Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n    // Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform1Message = incomingMessageVar.transform1Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform1Message.scraped_bet_1['scraped_sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n        \n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n        \n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n    \n    return result;\n}\n\n// Function to convert scraped_points to an integer if it is a string\nfunction convertScrapedPoints(betKey) {\n    let scrapedPoints = transform1Message[betKey].scraped_points;\n    if (typeof scrapedPoints === 'string') {\n        scrapedPoints = parseInt(scrapedPoints, 10); // Convert to integer with base 10\n    }\n    transform1Message[betKey].scraped_points = scrapedPoints;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    //REPLACE HERE\n    convertScrapedPoints('scraped_bet_1');\n    convertScrapedPoints('scraped_bet_2');\n    main.PointspreadPointsDifference = transform1Message['scraped_bet_1'].scraped_points + transform1Message['scraped_bet_2'].scraped_points;\n\n    node.log(SportsSettingsVar);\n    main.PointspreadRangeMin = SportsSettingsVar[main.sport].PointspreadRangeMin;\n    main.PointspreadRangeMax = SportsSettingsVar[main.sport].PointspreadRangeMax;\n\n    // Calculate Range Rating\n    main.PointspreadPointsDifferenceRating = main.PointspreadPointsDifference / main.PointspreadRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n    \n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n    \n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        // REPLACE HERE\n        main.line[i] = transform1Message[`scraped_bet_${i}`];        \n        main.line[i].lineValue = transform1Message[`scraped_bet_${i}`][`scraped_odds`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win; \n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;            \n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n    \n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n    \n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n    \n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n \n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n    \n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n    \n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.PointspreadPointsDifference >= main.PointspreadRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }   \n    // B: If Arb Less than Range min & greater than 0\n    else if (main.PointspreadPointsDifference < main.PointspreadRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15){\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.PointspreadPointsDifference < main.PointspreadRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else{\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\"){\n        main.line[1].stake = globalStake; \n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\"){\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1/100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2/100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform1Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 7,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2640,
        "y": 880,
        "wires": [
            [
                "b753d113f1e07d62",
                "aa6c72150d31fb90"
            ]
        ]
    },
    {
        "id": "12551b69148dc875",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Debug PspreadSorter",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2650,
        "y": 840,
        "wires": []
    },
    {
        "id": "18ee888a0e0c3587",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Totals",
        "func": "// 3. Check Bet \n// If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n// If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n// Then calculate line ; vig ; outcomes\n// Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n// Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform1Message = incomingMessageVar.transform1Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform1Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n// Function to convert scraped_points to an integer if it is a string\nfunction convertScrapedPoints(betKey) {\n    let scrapedPoints = transform1Message[betKey].scraped_points;\n    if (typeof scrapedPoints === 'string') {\n        scrapedPoints = parseInt(scrapedPoints, 10); // Convert to integer with base 10\n    }\n    transform1Message[betKey].scraped_points = scrapedPoints;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    // REPLACE HERE\n    convertScrapedPoints('scraped_bet_1');\n    convertScrapedPoints('scraped_bet_2');\n    main.TotalsPointsDifference = transform1Message['scraped_bet_1'].scraped_points + transform1Message['scraped_bet_2'].scraped_points;\n\n    main.TotalsRangeMin = SportsSettingsVar[main.sport].TotalsRangeMin;\n    main.TotalsRangeMax = SportsSettingsVar[main.sport].TotalsRangeMax;\n\n    // Calculate Range Rating\n    main.TotalsPointsDifferenceRating = main.TotalsPointsDifference / main.TotalsRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        // REPLACE HERE\n        main.line[i] = transform1Message[`scraped_bet_${i}`];\n        main.line[i].lineValue = transform1Message[`scraped_bet_${i}`][`scraped_odds`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.TotalsPointsDifference >= main.TotalsRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.TotalsPointsDifference < main.TotalsRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.TotalsPointsDifference < main.TotalsRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform1Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 7,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2630,
        "y": 920,
        "wires": [
            [
                "aa6c72150d31fb90"
            ]
        ]
    },
    {
        "id": "740d874372634aa9",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Moneyline",
        "func": "// 3. Check Bet \n// If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n// If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n// Then calculate line ; vig ; outcomes\n// Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n// Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform1Message = incomingMessageVar.transform1Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform1Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n// Function to convert scraped_points to an integer if it is a string\nfunction convertScrapedPoints(betKey) {\n    let scrapedPoints = transform1Message[betKey].scraped_points;\n    if (typeof scrapedPoints === 'string') {\n        scrapedPoints = parseInt(scrapedPoints, 10); // Convert to integer with base 10\n    }\n    transform1Message[betKey].scraped_points = scrapedPoints;\n}\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    //REPLACE HERE\n    convertScrapedPoints('scraped_bet_1');\n    convertScrapedPoints('scraped_bet_2');\n    main.MoneylineDifference = transform1Message['scraped_bet_1'].scraped_points + transform1Message['scraped_bet_2'].scraped_points\n\n    main.MoneylineRangeMin = SportsSettingsVar[main.sport].MoneylineRangeMin;\n    main.MoneylineRangeMax = SportsSettingsVar[main.sport].MoneylineRangeMax;\n\n    // Calculate Range Rating\n    main.MoneylineDifferenceRating = main.MoneylineDifference / main.MoneylineRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        // REPLACE HERE\n        main.line[i] = transform1Message[`scraped_bet_${i}`];\n        main.line[i].lineValue = transform1Message[`scraped_bet_${i}`][`scraped_odds`];\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.MoneylineDifference >= main.MoneylineRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MONEYLINEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.MoneylineDifference < main.MoneylineRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.MoneylineDifference < main.MoneylineRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform1Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 7,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2640,
        "y": 960,
        "wires": [
            [
                "aa6c72150d31fb90"
            ]
        ]
    },
    {
        "id": "b753d113f1e07d62",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Debug PSpread",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2950,
        "y": 880,
        "wires": []
    },
    {
        "id": "aa6c72150d31fb90",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Comparative Bets",
        "func": "\nvar incomingMessage = msg;\nvar betIDVar = msg._msgid;\nvar resultCounter = 1\nvar main = {};\nvar tenPercentStake = 10;\nvar vigMax = 5;\nvar arbPercentageRangeMin = 4;\nvar vigSplitRangeMin = 15;\nvar moneylineRangeMin = 21;\n\n//===================================\n// 1. BUFFER FUNCTIONS\nfunction updateBufferWithIncomingMessage(incomingMessage) {\n    // Initialize a buffer object if it doesn't exist\n    if (!context.get(\"buffer\")) {\n        context.set(\"buffer\", {});\n    }\n\n    // Initialize a timeout object to keep track of message timeouts\n    if (!context.get(\"timeouts\")) {\n        context.set(\"timeouts\", {});\n    }\n\n    // Retrieve the buffer and timeouts objects\n    let buffer = context.get(\"buffer\");\n    let timeouts = context.get(\"timeouts\");\n    const timeoutDuration = 60000; // Timeout duration in milliseconds (1 minute)\n\n    // Extract the message ID from the incoming message\n    var betIDVar = incomingMessage.fullMessage._id;\n\n    // Ensure buffer entry exists for the current message ID and initialize it as an empty array if it doesn't\n    if (!buffer[betIDVar]) {\n        buffer[betIDVar] = {};\n        buffer[betIDVar].messages = [];\n    }\n\n    // Add the incoming message to the buffer array for this betIDVar\n    buffer[betIDVar].messages.push(incomingMessage);\n\n    // Persist the updated buffer\n    context.set(\"buffer\", buffer);\n\n    // Return the relevant variables for use outside the function\n    return {\n        buffer, // Updated buffer object\n        timeouts, // Updated timeouts object\n        betIDVar // The message ID variable\n    };\n}\n\n// Call the function to update the buffer with the incoming message and capture the returned values\nvar { buffer, timeouts, betIDVar } = updateBufferWithIncomingMessage(incomingMessage);\n\n// Now `buffer`, `timeouts`, and `betIDVar` are available for use outside the function.\n\n// Assuming cleanupBuffer function is implemented elsewhere\nfunction cleanupBuffer(betIDVar) {\n    let buffer = context.get(\"buffer\");\n    let timeouts = context.get(\"timeouts\");\n\n    delete buffer[betIDVar];\n    context.set(\"buffer\", buffer);\n\n    if (timeouts[betIDVar]) {\n        clearTimeout(timeouts[betIDVar]);\n        delete timeouts[betIDVar];\n        context.set(\"timeouts\", timeouts);\n    }\n}\n\n//=========================\n// CALCULATION FUNCTIONS\n// 4. figure out which is the original message\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit \n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n// General function to extract and sort messages by a specified property path\nfunction extractAndSortByProperty(messages, propertyPath) {\n    // Split the property path into parts for nested properties\n    const pathParts = propertyPath.split('.');\n\n    // Map and extract the specified property value, handling nested properties\n    const extractedValues = messages.map((message, index) => {\n        let value = message.transform1Message;\n        for (const part of pathParts) {\n            value = value ? value[part] : undefined;\n        }\n        return { messageIndex: index, value };\n    });\n\n    // Filter out any undefined values that may not exist for the specified property\n    const filteredValues = extractedValues.filter(item => item.value !== undefined);\n\n    // Sort the filtered array by the specified property in descending order\n    filteredValues.sort((a, b) => b.value - a.value);\n\n    return filteredValues;\n}\n\n\nfunction calculateComparison(){\n// Calculate Within  PointSpread , Totals, Moneyline\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit\n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n    // -------------------\n\n    // Check if the incomingMessage.transform1Message is the main bet to compare all results\n    if (incomingMessage.transform1Message && incomingMessage.transform1Message._id == incomingMessage.extractMessage._id){\n        // Set Bet Type\n        main.BetType = incomingMessage.transform1Message.BetType; \n    }\n\n    // A: If MIDDLEBET\n    if (main.BetType == \"MIDDLEBET\"){\n\n        // Filter results by BetType\n        let middleBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"MIDDLEBET\"\n        );\n        // Check if it doesn't exist\n        if (middleBetMessages.length <= 0){\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else{\n            // Example: Sort by 'PointspreadPointsDifference'\n            let sortedByPointspread = extractAndSortByProperty(buffer[betIDVar].messages, 'PointspreadPointsDifference');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform1Message.PointspreadPointsDifference > sortedByPointspread[0])\n            {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else {\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // B: If ARBBET\n    if (main.BetType == \"ARBBET\") {\n       \n        // Filter results by BetType\n        let arbBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"ARBBET\"\n        );\n        // Check if it doesn't exist\n        if (arbBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else {\n            // Example: Sort by nested 'arbResults.ArbPercentage'\n            let sortedByArbPercentage = extractAndSortByProperty(buffer[betIDVar].messages, 'arbResults.ArbPercentage');\n\n            // Example: Sort by nested 'arbResults.ArbProfit1'\n            let sortedByArbProfit1 = extractAndSortByProperty(buffer[betIDVar].messages, 'arbResults.ArbProfit1');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform1Message.arbResults.ArbPercentage > (sortedByArbPercentage[0] + 3) || incomingMessage.transform1Message.arbResults.ArbProfit1 > (sortedByArbProfit1[0] + tenPercentStake)) {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else{\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // C: If Vigsplitbet\n    if (main.BetType == \"VIGSPLITBET\") {\n\n        // Filter results by BetType\n        let vigsplitBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"VIGSPLITBET\"\n        );\n        // Check if it doesn't exist\n        if (vigsplitBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n        // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n    // D: If Vigsplitbet\n    if (main.BetType == \"MONEYLINEBET\") {\n\n        // Filter results by BetType\n        let moneylineBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"MONEYLINEBET\"\n        );\n        // Check if it doesn't exist\n        if (moneylineBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n            // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n}\n\nfunction calculateProfit() {\n\n    // CHECK MIDDLEBET\n    if (incomingMessage.transform1Message.BetType == \"MIDDLEBET\"){\n        if (incomingMessage.transform1Message.PointspreadPointsDifference >= incomingMessage.transform1Message.PointspreadRangeMin)\n        {main.profitCheck = true;}\n        else{ main.profitCheck = false;}\n    }\n    // CHECK ARBBET\n    else if(incomingMessage.transform1Message.BetType == \"ARBBET\"){\n        if (incomingMessage.transform1Message.arbResults.ArbPercentage >= arbPercentageRangeMin)\n        { main.profitCheck = true; }\n        else { main.profitCheck = false; }      \n    }\n    // CHECK VIGSPLITBET\n    else if (incomingMessage.transform1Message.BetType == \"VIGSPLITBET\"){\n        if (incomingMessage.transform1Message.vigSplitProfit >= vigSplitRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK MONEYLINEBET\n    else if (incomingMessage.transform1Message.BetType == \"MONEYLINEBET\") {\n        if (incomingMessage.transform1Message.moneylineDifference > moneylineRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK VIGMAX\n    if (incomingMessage.transform1Message.TotalVig > vigMax){\n        main.profitCheck = false;\n    }\n\n}\n\n\n//========================\n// EXECUTION FUNCTIONS\n\n// If we have collected resultCounter messages for this betIDVar, process them\nif (buffer[betIDVar].messages.length === resultCounter) {\n\n\n        clearTimeout(timeouts[betIDVar]); // Important to clear timeout\n        context.set(\"timeouts\", timeouts); // Persist timeouts changes\n\n        // CALCULATE HERE\n        calculateComparison();\n        calculateProfit();\n        \n        // ADD ALL KEYS\n        for (const [key, value] of Object.entries(main)) {\n            incomingMessage.transform1Message[key] = value;\n        }\n        \n        // Prep Message and Send\n        var newMsg = {...msg};\n        newMsg.extractMessage = msg.extractMessage;\n        newMsg.transform1Message = incomingMessage.transform1Message;\n        newMsg.transformResults = incomingMessage.transformResults;\n        newMsg.main = main;\n\n        // Send the combined message on\n        node.send(newMsg);\n\n        // Cleanup buffer and timeouts for this betIDVar\n        cleanupBuffer(betIDVar);\n\n}\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 15,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 3000,
        "y": 940,
        "wires": [
            [
                "7f404f5ee3444148",
                "148caedec77ae2dc"
            ]
        ]
    },
    {
        "id": "148caedec77ae2dc",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": "Debug COMPARE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 3270,
        "y": 880,
        "wires": []
    },
    {
        "id": "7f404f5ee3444148",
        "type": "link out",
        "z": "5fa172c20f49443b",
        "g": "bf94ecd062e4e70d",
        "name": " BetInputCheck Ph2 : OUT : Compare > Load: Pack to HTTP",
        "mode": "link",
        "links": [
            "2e4fb60325f287ea"
        ],
        "x": 3355,
        "y": 940,
        "wires": []
    },
    {
        "id": "844825e531e70a8c",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "907bb0adef74d85a",
        "name": "Load: Pack to HTTP",
        "func": "\nvar incomingMessage = msg;\n\n\n//===================================\nmsg.statusCode = 200; // Set HTTP status code to 200 OK\nmsg.headers = {\n    \"Content-Type\": \"application/json\" // Set Content-Type header to text/plain\n};\n// Skip the Sort\nmsg.payload = {\n    extractMessage: incomingMessage.extractMessage,\n    finalMessage: incomingMessage.transform2Message,\n    transform1Message: incomingMessage.transform1Message,\n    _msgid: incomingMessage._msgid,\n};\n//delete msg.req;\n//delete msg.res;\n//msg.req = incomingMessage.transform1Message.scraped_bet_2.req;\n//msg.res = incomingMessage.transform1Message.scraped_bet_2.res;\n\nvar req2 = incomingMessage.transform1Message.scraped_bet_1.req;\nvar res2 = incomingMessage.transform1Message.scraped_bet_1.res; \n\ndelete msg.transform1Message.req;\ndelete msg.transform1Message.res;\ndelete msg.transform1Message.scraped_bet_1.req;\ndelete msg.transform1Message.scraped_bet_1.res;\ndelete msg.transform1Message.scraped_bet_2.req;\ndelete msg.transform1Message.scraped_bet_2.res;\n\n//========================\n// EXECUTION FUNCTIONS\n\nnode.send(msg);\n\n//msg.req = req2;\n//msg.res = res2;\n\n//node.send(msg);\nreturn null\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2970,
        "y": 1120,
        "wires": [
            [
                "8e05a6c56f99c187",
                "37c361494a477963"
            ]
        ]
    },
    {
        "id": "8e05a6c56f99c187",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "907bb0adef74d85a",
        "name": "Debug RESPONSE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 3290,
        "y": 1060,
        "wires": []
    },
    {
        "id": "2e4fb60325f287ea",
        "type": "link in",
        "z": "5fa172c20f49443b",
        "g": "907bb0adef74d85a",
        "name": "BetInputCheck Ph3: IN : Compare > Load: Pack to HTTP",
        "links": [
            "7f404f5ee3444148"
        ],
        "x": 1985,
        "y": 1120,
        "wires": [
            [
                "844825e531e70a8c"
            ]
        ]
    },
    {
        "id": "3172a5061aab2782",
        "type": "comment",
        "z": "5fa172c20f49443b",
        "g": "4126bd8cd63414e5",
        "name": "BETINPUTCHECK : Full Pseudocode",
        "info": "// TO PARSE:\n\n// 1. BOOK > GAME NUMBER > TIME \n// 2. SPORTS > LEAGUE > TEAM\n// 3. POINTS > LINE >   \n// 4. CHECK WAIT FOR OTHER LINE\n// 5. CHECK FOR ACCEPTABLE RANGE OF PROFIT\n// 6. IF SO, GO AHEAD",
        "x": 2110,
        "y": 460,
        "wires": []
    },
    {
        "id": "7f099d933bceb328",
        "type": "comment",
        "z": "5fa172c20f49443b",
        "g": "b93dd9f1ed02b46a",
        "name": "SortedBetsCheck : Full Pseudocode",
        "info": "// 3. Check Bet POINTS & PROFIT 3 different ways: Middle, VigSplit, Arb\n    // Point Spread ; If Totals; If Moneyline\n    // If Line type x (PS & Totals) =  then calculate points ; line ; profit ; vig loss\n    // If Line type y (ML) = calculate line ; profit ; vig loss\n    //--- (DUPLICATE AND DO IT TWICE TO BOTH PASSED AND COMPARE)\n    // filter by Sports\n    // if sports ; check the min and max, get the gap percentage\n    // line ; how much gap.\n\n//--------\n// Make a function also to calculate if it's a high Vigsplit.\n// Middle / Vigsplit / Arb / Moneyline\n\n// 4. Filter 5% or more / Filter 0 risk profit\n    // cut out vig loss > 5%\n    // Filter out 0 risk > Profit #\n\n//--------\n// 5. Check if x or y higher\n// 6. only push if higher 5% threshhold than highest bets in 2 categories.\n\n//================================\n// Later : Do a line scanner.\n// 10. QUERY MONGO, Slap a credit stop loss limit for accounts \n// 11. COME OUT WITH 1 or 2 bets arrays - use same books, different accounts(middle & vigsplit)\n\nmsg.payload = SportsSettingsVar;\nreturn msg;",
        "x": 530,
        "y": 460,
        "wires": []
    },
    {
        "id": "8dde91e674783ac8",
        "type": "comment",
        "z": "5fa172c20f49443b",
        "g": "4126bd8cd63414e5",
        "name": "DO NODE RED A>B>C TRACKING COMMENTS",
        "info": "",
        "x": 2530,
        "y": 460,
        "wires": []
    },
    {
        "id": "3b7490b20fbb7087",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "output response",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2540,
        "y": 520,
        "wires": []
    },
    {
        "id": "bd4fd4d1e09d770b",
        "type": "http response",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "HTTP RESP 0",
        "statusCode": "",
        "headers": {},
        "x": 3270,
        "y": 520,
        "wires": []
    },
    {
        "id": "74c06399d74963b0",
        "type": "link out",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": " BetInputCheck Ph1 : OUT : Transform1 : Split Messages > Line Type Sorter",
        "mode": "link",
        "links": [
            "6d7830c85b50c511"
        ],
        "x": 3275,
        "y": 600,
        "wires": []
    },
    {
        "id": "f4d0bfed3d6727e6",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "Debug POST",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 2910,
        "y": 540,
        "wires": []
    },
    {
        "id": "82f37f0f6985ba34",
        "type": "comment",
        "z": "5fa172c20f49443b",
        "g": "4126bd8cd63414e5",
        "name": "GIVE IT LINETYPE",
        "info": "",
        "x": 2940,
        "y": 680,
        "wires": []
    },
    {
        "id": "5f817b78b5dfe714",
        "type": "function",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "EXTRACT 2: Wait for 2 Bets",
        "func": "var incomingMessage = msg;\nvar betIDVar = msg.fullMessage._id;\nvar resultCounter = 2;\nvar tenPercentStake = 10;\nvar vigMax = 5;\nvar arbPercentageRangeMin = 4;\nvar vigSplitRangeMin = 15;\nvar moneylineRangeMin = 21;\n\n\n//===================================\n// 1. BUFFER FUNCTIONS\nfunction updateBufferWithIncomingMessage(incomingMessage) {\n    // Initialize a buffer object if it doesn't exist\n    if (!context.get(\"buffer\")) {\n        context.set(\"buffer\", {});\n    }\n\n    // Initialize a timeout object to keep track of message timeouts\n    if (!context.get(\"timeouts\")) {\n        context.set(\"timeouts\", {});\n    }\n\n    // Retrieve the buffer and timeouts objects\n    let buffer = context.get(\"buffer\");\n    let timeouts = context.get(\"timeouts\");\n    const timeoutDuration = 60000; // Timeout duration in milliseconds (1 minute)\n\n    // Extract the message ID from the incoming message\n    var betIDVar = incomingMessage.fullMessage._id;\n\n    // Ensure buffer entry exists for the current message ID and initialize it as an empty array if it doesn't\n    if (!buffer[betIDVar]) {\n        buffer[betIDVar] = {};\n        buffer[betIDVar].messages = [];\n    }\n\n    // Add the incoming message to the buffer array for this betIDVar\n    buffer[betIDVar].messages.push(incomingMessage);\n\n    // Persist the updated buffer\n    context.set(\"buffer\", buffer);\n\n    // Return the relevant variables for use outside the function\n    return {\n        buffer, // Updated buffer object\n        timeouts, // Updated timeouts object\n        betIDVar // The message ID variable\n    };\n}\n\n// Call the function to update the buffer with the incoming message and capture the returned values\nvar { buffer, timeouts, betIDVar } = updateBufferWithIncomingMessage(incomingMessage);\n\n// Now `buffer`, `timeouts`, and `betIDVar` are available for use outside the function.\n\n// Assuming cleanupBuffer function is implemented elsewhere\nfunction cleanupBuffer(betIDVar) {\n    let buffer = context.get(\"buffer\");\n    let timeouts = context.get(\"timeouts\");\n\n    delete buffer[betIDVar];\n    context.set(\"buffer\", buffer);\n\n    if (timeouts[betIDVar]) {\n        clearTimeout(timeouts[betIDVar]);\n        delete timeouts[betIDVar];\n        context.set(\"timeouts\", timeouts);\n    }\n}\n//============================================\n// 2. SORTING FUNCTIONS\n// General function to extract and sort messages by a specified property path\n\n//========================\n// 3. EXECUTION FUNCTIONS\n\n// Function to check for messages with a similar fullMessage._id, the same scraped_lineType, and matching team in the buffer\nfunction checkForSimilarity({ betIDVar, incomingMessage }) {\n    // Destructure incomingMessage for easier comparison\n    const {\n        fullMessage: { _id: fullMessageID },\n        scraped_bet: { scraped_lineType: lineType, scraped_timeStamp: timeStamp }\n    } = incomingMessage;\n\n    node.log(fullMessageID);\n    \n    // Filter messages in the buffer for the same betIDVar\n    let similarMessages = buffer[betIDVar].messages.filter(message =>\n        message.fullMessage && message.fullMessage._id === fullMessageID &&\n        message.scraped_bet.scraped_lineType === lineType &&\n        message.scraped_bet.scraped_timeStamp === timeStamp\n    );\n\n    if (similarMessages.length == 2) {\n        // Assuming `node`, `timeouts`, `context`, are available in the scope\n        node.log(\"Found similar message(s) with the same fullMessage._id, scraped_lineType, and team.\");\n        processSimilarMessages({node, similarMessages, betIDVar, timeouts, context});\n    } else {\n        node.log(\"No similar message found with matching criteria.\");\n    }\n}\n\nfunction processSimilarMessages({node, similarMessages, betIDVar, timeouts, context}) {\n    clearTimeout(timeouts[betIDVar]);\n    context.set(\"timeouts\", timeouts);\n\n    var newMsg = {...similarMessages[0]}; // Consider starting with an empty object or predefined structure\n\n    // Example of processing multiple messages, adjust according to actual requirements\n    similarMessages.forEach((message, index) => {\n        const details = {...message.scraped_bet};\n        newMsg[`scraped_bet_${index + 1}`] = details; // Dynamically name as scraped_bet_1, scraped_bet_2, etc.\n        newMsg[`scraped_bet_${index + 1}`]['req'] = message.req;\n        newMsg[`scraped_bet_${index + 1}`]['res'] = message.res;         \n    });\n    delete newMsg.scraped_bet;\n//    delete newMsg.req;    \n//    delete newMsg.res;    \n    \n    node.send(newMsg);\n    cleanupBuffer(betIDVar);        \n}\n\ncheckForSimilarity({ betIDVar, incomingMessage });",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2960,
        "y": 600,
        "wires": [
            [
                "74c06399d74963b0",
                "fb5587b589c5cd32"
            ]
        ]
    },
    {
        "id": "fb5587b589c5cd32",
        "type": "debug",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "Debug 2 Bets",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 3260,
        "y": 560,
        "wires": []
    },
    {
        "id": "24c74fc74752908c",
        "type": "websocket in",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "/ws/BetInputCheck",
        "server": "df8a615d6d2cd2e7",
        "client": "",
        "x": 2070,
        "y": 540,
        "wires": [
            [
                "054adb80f90a06e5"
            ]
        ]
    },
    {
        "id": "054adb80f90a06e5",
        "type": "json",
        "z": "5fa172c20f49443b",
        "g": "9e02f8f5e79de5a0",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 2310,
        "y": 560,
        "wires": [
            [
                "3b7490b20fbb7087",
                "272b6d76a23994ba"
            ]
        ]
    },
    {
        "id": "37c361494a477963",
        "type": "websocket out",
        "z": "5fa172c20f49443b",
        "g": "907bb0adef74d85a",
        "name": "ws/BetInputCheck",
        "server": "df8a615d6d2cd2e7",
        "client": "",
        "x": 3290,
        "y": 1120,
        "wires": []
    },
    {
        "id": "fa59f6c4d6ce4b69",
        "type": "mongodb4",
        "z": "5fa172c20f49443b",
        "g": "db1664ca19e007e4",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "SportsSettings",
        "operation": "find",
        "output": "toArray",
        "maxTimeMS": "0",
        "handleDocId": false,
        "name": "SportsSettings.find.toArray",
        "x": 1180,
        "y": 260,
        "wires": [
            [
                "ce4d24263c44e46c"
            ]
        ]
    },
    {
        "id": "50b5ebf17c38bd1c",
        "type": "function",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "Check Chrome and Navigate",
        "func": "// Retrieve initializeController function from context\nconst initializeControllerFn = context.get('initializeController');\n\nif (typeof initializeControllerFn !== 'function') {\n    node.error('initializeController is not a function. Reinitializing...');\n    // Reinitialize if the function is not found\n    context.set('initializeController', initializeController(context));\n}\n\n// Retrieve or initialize the controller\nlet controller;\ntry {\n    controller = await initializeControllerFn();\n} catch (error) {\n    node.error('Failed to initialize controller: ' + error.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Initialization failed\" });\n    return null;\n}\n\n// Main logic\ntry {\n    await controller.handleMessage(msg);\n    if (controller.isReady) {\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Controller ready\" });\n\n        // Check if the page has been navigated to\n        if (controller.lastNavigatedUrl === 'https://chat.openai.com') {\n            msg.siteLoaded = true;\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Site loaded\" });\n        }\n    } else {\n        node.status({ fill: \"yellow\", shape: \"ring\", text: \"Waiting for Chrome\" });\n    }\n} catch (error) {\n    node.error('Error processing message: ' + error.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Error processing message\" });\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 1,
        "initialize": "// Define the ChromeController class\nclass ChromeController {\n    constructor() {\n        this.browser = null;\n        this.isReady = false;\n        this.lastNavigatedUrl = null;  // Add this line\n    }\n\n    async connectToBrowser() {\n        console.log('Attempting to connect to Chrome via CDP on port 27000...');\n        this.browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        console.log('Successfully connected to Chrome via CDP on port 27000.');\n        this.isReady = true;\n    }\n\n    async logContextsAndPages() {\n        const contexts = this.browser.contexts();\n        console.log(`Found ${contexts.length} context(s).`);\n\n        for (let i = 0; i < contexts.length; i++) {\n            const context = contexts[i];\n            const pages = context.pages();\n            console.log(`Context ${i + 1} has ${pages.length} page(s).`);\n            for (let j = 0; j < pages.length; j++) {\n                console.log(`  Page ${j + 1}: ${pages[j].url()}`);\n            }\n        }\n\n        return contexts;\n    }\n\n    async getOrCreateContext() {\n        let contexts = this.browser.contexts();\n        if (contexts.length === 0) {\n            console.log('No contexts found, creating a new one.');\n            return await this.browser.newContext();\n        }\n        return contexts[0];\n    }\n\n    async getOrCreatePage(context) {\n        const pages = context.pages();\n        if (pages.length > 0) {\n            console.log('Found an open tab, using it.');\n            return pages[0];\n        } else {\n            console.log('No open tabs found, creating a new tab.');\n            return await context.newPage();\n        }\n    }\n\n    async navigateToChat(page) {\n        console.log('Navigating to ChatGPT...');\n        await page.goto('https://chat.openai.com', { waitUntil: 'networkidle' });\n        console.log('Navigated to ChatGPT using the connected Chrome instance.');\n        const title = await page.title();\n        console.log(`Page title after navigation: ${title}`);\n        this.lastNavigatedUrl = 'https://chat.openai.com';  // Add this line\n    }\n\n\n    async disconnectFromBrowser() {\n        if (this.browser) {\n            try {\n                await this.browser.close();\n                console.log('Closed the CDP connection to the browser.');\n            } catch (error) {\n                console.error('Error closing CDP connection:', error);\n            } finally {\n                this.browser = null;\n                this.isReady = false;\n            }\n        }\n    }\n\n    async handleMessage(message) {\n        console.log('Handling message:', JSON.stringify(message));\n        try {\n            if (typeof message === 'object' && message.chromeStarted === true) {\n                console.log('Chrome started. Connecting to the browser...');\n                await this.connectToBrowser();\n                await this.logContextsAndPages();\n                const context = await this.getOrCreateContext();\n                const page = await this.getOrCreatePage(context);\n                await this.navigateToChat(page);\n            } else if (typeof message === 'object' && message.chromeEnded === true) {\n                console.log('Chrome ended. Disconnecting from the browser...');\n                await this.disconnectFromBrowser();\n            } else {\n                console.log('Unrecognized message. Ignoring.');\n            }\n        } catch (error) {\n            console.error('Error handling message:', error);\n        }\n    }\n}\n\n\n/// Function to initialize the controller\nfunction initializeController(context) {\n    return async function () {\n        let controller = context.get('controller');\n        if (!controller) {\n            node.status({ fill: \"blue\", shape: \"dot\", text: \"Initializing controller...\" });\n            controller = new ChromeController();\n            context.set('controller', controller);\n        }\n        return controller;\n    }\n}\n\n// Store the initializeController function in the context\ncontext.set('initializeController', initializeController(context));\n\n// Set initial status\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Waiting for message\" });",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1000,
        "y": 320,
        "wires": [
            [
                "288cc212527de778",
                "fd5c9dd229e436a8"
            ]
        ]
    },
    {
        "id": "288cc212527de778",
        "type": "debug",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "targetType": "full",
        "x": 1230,
        "y": 320,
        "wires": []
    },
    {
        "id": "e0f37b3e31c3903c",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "chromeStarted",
        "props": [
            {
                "p": "chromeStarted",
                "v": "true",
                "vt": "bool"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 700,
        "y": 320,
        "wires": [
            [
                "50b5ebf17c38bd1c"
            ]
        ]
    },
    {
        "id": "47dc79bad9bac696",
        "type": "function",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "Start Chrome With Profile",
        "func": "// Function to detect the operating system\nfunction getOperatingSystem() {\n    const osPlatform = os.platform();\n    if (osPlatform === 'win32') {\n        return 'windows';\n    } else if (osPlatform === 'darwin') {\n        return 'mac';\n    } else if (osPlatform === 'linux') {\n        return 'linux';\n    } else {\n        console.error('Unsupported OS');\n        return 'unsupported';\n    }\n}\n\nlet chromePath = global.get('userRootPaths').chrome;\n\nconst chromeArgs = ['--remote-debugging-port=27000', '--profile-directory=Profile 4'];\n\n// Initialize context variables if they don't exist\nif (context.get('chromeRunning') === undefined) {\n    context.set('chromeRunning', false, 'file');\n}\nif (context.get('checkAttempts') === undefined) {\n    context.set('checkAttempts', 0, 'file');\n}\n\nconst maxAttempts = 10;\n\nfunction sendOutput(msg, fillColor, text) {\n    node.status({ fill: fillColor, shape: \"dot\", text: text });\n    console.log('[Chrome Starter] Sending output message:', msg);\n    node.send(msg);\n}\n\nfunction checkChromeRunning() {\n    let command;\n    let processName;\n    const osType = getOperatingSystem();\n\n    console.log(`[checkChromeRunning] Detected OS: ${osType}`);\n\n    if (osType === 'windows') {\n        // Simplified to only check if Chrome is running\n        command = 'tasklist /FI \"IMAGENAME eq chrome.exe\"';\n        processName = 'chrome.exe';\n    } else if (osType === 'mac') {\n        command = 'ps aux | grep \"[G]oogle Chrome Canary\"';\n        processName = 'Google Chrome Canary';\n    } else if (osType === 'linux') {\n        command = 'ps aux | grep \"[C]hrome\"';\n        processName = 'chrome';\n    } else {\n        console.error('[checkChromeRunning] Unsupported OS');\n        return;\n    }\n\n    console.log(`[checkChromeRunning] Executing command: ${command}`);\n\n    childProcess.exec(command, (error, stdout, stderr) => {\n        let checkAttempts = context.get('checkAttempts') || 0;\n\n        console.log(`[checkChromeRunning] Command output: ${stdout}`);\n        console.log(`[checkChromeRunning] Command error output (if any): ${stderr}`);\n        \n        if (error) {\n            console.error(`[checkChromeRunning] Command execution error: ${error.message}`);\n        }\n\n        if (stdout.toLowerCase().includes(processName.toLowerCase())) {\n            console.log('[Chrome Starter] Chrome Canary process found running');\n            context.set('chromeRunning', true, 'file');\n            context.set('checkAttempts', 0, 'file');\n            sendOutput({\n                payload: \"Chrome started successfully (verified running)\",\n                chromeStarted: true,\n                error: null,\n                errorMessage: null\n            }, \"green\", \"Chrome started (verified)\");\n        } else {\n            console.log(`[Chrome Starter] Chrome Canary process not found, attempt ${checkAttempts + 1}`);\n            checkAttempts++;\n            context.set('checkAttempts', checkAttempts, 'file');\n            if (checkAttempts >= maxAttempts) {\n                console.log('[Chrome Starter] Max attempts reached, Chrome start failed');\n                context.set('chromeRunning', false, 'file');\n                context.set('checkAttempts', 0, 'file');\n                sendOutput({\n                    payload: \"Chrome failed to start (process not found after multiple attempts)\",\n                    chromeStarted: false,\n                    error: new Error(\"Chrome process not found after multiple attempts\"),\n                    errorMessage: \"Chrome process not found after multiple attempts\"\n                }, \"red\", \"Chrome start failed\");\n            } else {\n                setTimeout(checkChromeRunning, 2000);\n            }\n        }\n    });\n}\n\n\n\nfunction startChrome() {\n    if (context.get('chromeRunning')) {\n        console.log('[Chrome Starter] Chrome is already running');\n        sendOutput({\n            payload: \"Chrome is already running\",\n            chromeStarted: true,\n            error: null,\n            errorMessage: null\n        }, \"green\", \"Chrome already running\");\n        return;\n    }\n\n    console.log('[Chrome Starter] Initiating Chrome start process');\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Starting Chrome...\" });\n    console.log('[Chrome Starter] Executing command:', chromePath, chromeArgs.join(' '));\n\n    // Add a 300ms delay before starting Chrome\n    setTimeout(() => {\n        try {\n            const chromeProcess = childProcess.spawn(chromePath, chromeArgs, {\n                detached: true,\n                stdio: 'ignore'\n            });\n\n            chromeProcess.on('error', (err) => {\n                console.error('[Chrome Starter] Failed to start Chrome:', err);\n                sendOutput({\n                    payload: `Failed to start Chrome: ${err.message}`,\n                    chromeStarted: false,\n                    error: err,\n                    errorMessage: err.message\n                }, \"red\", \"Chrome start error\");\n            });\n\n            chromeProcess.unref();\n\n            // Start checking immediately after spawning the process\n            setTimeout(checkChromeRunning, 1000);\n        } catch (err) {\n            console.error('[Chrome Starter] Error when trying to start Chrome:', err);\n            sendOutput({\n                payload: `Error when trying to start Chrome: ${err.message}`,\n                chromeStarted: false,\n                error: err,\n                errorMessage: err.message\n            }, \"red\", \"Chrome start error\");\n        }\n    }, 300); // 300ms delay before starting Chrome\n}\n\nfunction endChromeProcess(chromePath) {\n    if (!context.get('chromeRunning')) {\n        console.log('[Chrome Starter] No Chrome Canary process to end');\n        sendOutput({\n            payload: \"No Chrome Canary process to end\",\n            chromeEnded: false,\n            error: null,\n            errorMessage: null\n        }, \"yellow\", \"No Chrome Canary process\");\n        return;\n    }\n\n    if (!chromePath) {\n        console.error('[Chrome Starter] chromePath is undefined or null');\n        sendOutput({\n            payload: \"chromePath is undefined\",\n            chromeEnded: false,\n            error: true,\n            errorMessage: 'chromePath is undefined or null'\n        }, \"red\", \"Error\");\n        return;\n    }\n\n    console.log('[Chrome Starter] Gracefully ending Chrome Canary process');\n\n    const osType = getOperatingSystem();\n\n    if (osType === 'windows') {\n        // Ensure chromePath is properly escaped for the command line\n        const escapedChromePath = chromePath.replace(/\\\\/g, '\\\\\\\\');\n        const command = `wmic process where \"name='chrome.exe' and commandline like '%${escapedChromePath}%'\" call terminate`;\n        childProcess.exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error closing Chrome Canary processes:', stderr || error);\n                forceKillChrome();\n                return;\n            }\n\n            console.log('[Chrome Starter] Chrome Canary processes closed, waiting briefly for processes to end');\n            setTimeout(checkChromeProcesses, 2000); // Wait 2 seconds before checking\n        });\n    } else if (osType === 'mac' || osType === 'linux') {\n        // Use pgrep to find the process ID and then send a quit signal\n        childProcess.exec(`pgrep -f \"${chromePath}\"`, (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error finding Chrome Canary processes:', stderr || error);\n                forceKillChrome();\n                return;\n            }\n\n            const pids = stdout.trim().split('\\n').filter(pid => pid.trim() !== '');\n            if (pids.length > 0) {\n                console.log(`[Chrome Starter] Found Chrome Canary process(es): ${pids.join(', ')}. Attempting to gracefully quit each...`);\n                pids.forEach(pid => {\n                    childProcess.exec(`kill -15 ${pid}`, (error, stdout, stderr) => {\n                        if (error) {\n                            console.error(`[Chrome Starter] Error sending quit signal to PID ${pid}:`, stderr || error);\n                        } else {\n                            console.log(`[Chrome Starter] Quit signal sent to PID ${pid}.`);\n                        }\n                    });\n                });\n\n                // Delay to allow processes to quit gracefully\n                setTimeout(checkChromeProcesses, 5000); // 5 seconds before checking\n            } else {\n                console.log('[Chrome Starter] No Chrome Canary process found to quit');\n                sendOutput({\n                    payload: \"No Chrome Canary process found to quit\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"yellow\", \"No Chrome Canary process found\");\n            }\n        });\n    } else {\n        console.error('[Chrome Starter] Unsupported OS detected');\n    }\n}\n\n\nfunction checkChromeProcesses() {\n    const osType = getOperatingSystem();\n\n    if (osType === 'windows') {\n        childProcess.exec('tasklist /FI \"IMAGENAME eq chrome.exe\" /FO CSV /NH /FI \"WINDOWTITLE eq Google Chrome Canary\"', (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error checking Chrome Canary processes:', error);\n                forceKillChrome();\n                return;\n            }\n\n            const chromeProcesses = stdout.split('\\n').filter(line => line.includes('chrome.exe'));\n\n            if (chromeProcesses.length === 0) {\n                console.log('[Chrome Starter] All Chrome Canary processes ended successfully');\n                context.set('chromeRunning', false, 'file');\n                sendOutput({\n                    payload: \"Chrome Canary processes ended successfully\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"blue\", \"Chrome Canary ended\");\n            } else {\n                console.log('[Chrome Starter] Chrome Canary processes still running, force killing');\n                forceKillChrome();\n            }\n        });\n    } else if (osType === 'mac' || osType === 'linux') {\n        childProcess.exec('pgrep -f \"Google Chrome Canary\"', (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error checking Chrome Canary processes:', error);\n                forceKillChrome();\n                return;\n            }\n\n            const chromeProcesses = stdout.split('\\n').filter(line => line.trim() !== '');\n\n            if (chromeProcesses.length === 0) {\n                console.log('[Chrome Starter] All Chrome Canary processes ended successfully');\n                context.set('chromeRunning', false, 'file');\n                sendOutput({\n                    payload: \"Chrome Canary processes ended successfully\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"blue\", \"Chrome Canary ended\");\n            } else {\n                console.log('[Chrome Starter] Chrome Canary processes still running, force killing');\n                forceKillChrome();\n            }\n        });\n    } else {\n        console.error('Unsupported OS');\n    }\n}\n\nfunction forceKillChrome() {\n    const osType = getOperatingSystem();\n\n    console.log(`[Chrome Starter] Detected OS: ${osType}`);\n\n    if (osType === 'windows') {\n        console.log('[Chrome Starter] Attempting to force kill Chrome Canary on Windows using taskkill...');\n        childProcess.exec('taskkill /F /IM chrome.exe /FI \"WINDOWTITLE eq Google Chrome Canary\"', (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error force killing Chrome Canary process:', error);\n                console.error('[Chrome Starter] Command output:', stdout);\n                console.error('[Chrome Starter] Command error output:', stderr);\n                sendOutput({\n                    payload: \"Error ending Chrome Canary process\",\n                    chromeEnded: false,\n                    error: error,\n                    errorMessage: error.message || JSON.stringify(error)\n                }, \"red\", \"Error ending Chrome Canary\");\n            } else {\n                console.log('[Chrome Starter] Chrome Canary process force killed successfully. Command output:', stdout);\n                context.set('chromeRunning', false, 'file');\n                sendOutput({\n                    payload: \"Chrome Canary process force killed successfully\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"blue\", \"Chrome Canary ended (forced)\");\n            }\n        });\n    } else if (osType === 'mac' || osType === 'linux') {\n        console.log(`[Chrome Starter] Attempting to find Chrome Canary processes on ${osType} using pgrep...`);\n        childProcess.exec('pgrep -f \"Google Chrome Canary\"', (error, stdout, stderr) => {\n            console.log('[Chrome Starter] pgrep command output:', stdout);\n            console.log('[Chrome Starter] pgrep command error output:', stderr);\n            const pids = stdout.trim().split('\\n');\n\n            if (pids.length === 0 || pids[0] === '') {\n                console.log('[Chrome Starter] No Chrome Canary process found to kill');\n                sendOutput({\n                    payload: \"No Chrome Canary process found to kill\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"yellow\", \"No Chrome Canary process found\");\n            } else {\n                console.log(`[Chrome Starter] Found Chrome Canary process(es): ${pids.join(', ')}. Attempting to force kill each...`);\n                \n                let killErrors = [];\n                let killSuccess = false;\n\n                pids.forEach(pid => {\n                    console.log(`[Chrome Starter] Attempting to kill process ID: ${pid}`);\n                    childProcess.exec(`kill -9 ${pid}`, (error, stdout, stderr) => {\n                        if (error) {\n                            console.error(`[Chrome Starter] Error force killing Chrome Canary process with PID ${pid}:`, error);\n                            console.error(`[Chrome Starter] kill command output for PID ${pid}:`, stdout);\n                            console.error(`[Chrome Starter] kill command error output for PID ${pid}:`, stderr);\n                            killErrors.push(`Error killing PID ${pid}: ${error.message}`);\n                        } else {\n                            console.log(`[Chrome Starter] Successfully killed Chrome Canary process with PID ${pid}.`);\n                            killSuccess = true;\n                        }\n                    });\n                });\n\n                setTimeout(() => {\n                    if (killSuccess) {\n                        context.set('chromeRunning', false, 'file');\n                        sendOutput({\n                            payload: \"Chrome Canary process(es) force killed successfully\",\n                            chromeEnded: true,\n                            error: null,\n                            errorMessage: null\n                        }, \"blue\", \"Chrome Canary ended (forced)\");\n                    } else {\n                        sendOutput({\n                            payload: \"Failed to end some or all Chrome Canary processes\",\n                            chromeEnded: false,\n                            error: new Error(killErrors.join('\\n')),\n                            errorMessage: killErrors.join('\\n')\n                        }, \"red\", \"Error ending Chrome Canary\");\n                    }\n                }, 1000);  // Delay to allow all kill commands to complete\n            }\n        });\n    } else {\n        console.error('[Chrome Starter] Unsupported OS detected');\n    }\n}\n\nfunction restartChromeProcess() {\n    console.log('[Chrome Starter] Restart process initiated');\n\n    if (!context.get('chromeRunning')) {\n        console.log('[Chrome Starter] Chrome Canary is not running. Starting new instance.');\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Starting Chrome...\" });\n        startChrome();\n        return;\n    }\n\n    console.log('[Chrome Starter] Restarting Chrome Canary process');\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Restarting Chrome Canary...\"});\n\n    // First, end the Chrome Canary process\n    endChromeProcess(chromePath);\n\n    // Wait for the end process to complete before starting\n    const checkAndStart = setInterval(() => {\n        if (!context.get('chromeRunning')) {\n            clearInterval(checkAndStart);\n            console.log('[Chrome Starter] Chrome Canary process ended, now starting...');\n            setTimeout(startChrome, 1000); // Wait an additional second before starting\n        }\n    }, 500); // Check every 500ms\n\n    // Set a timeout to prevent infinite waiting\n    setTimeout(() => {\n        clearInterval(checkAndStart);\n        if (context.get('chromeRunning')) {\n            console.log('[Chrome Starter] Restart failed: Could not end Chrome Canary process');\n            sendOutput({\n                payload: \"Restart failed: Could not end Chrome Canary process\",\n                chromeRestarted: false,\n                error: new Error(\"Could not end Chrome Canary process during restart\"),\n                errorMessage: \"Could not end Chrome Canary process during restart\"\n            }, \"red\", \"Restart failed\");\n        }\n    }, 30000); // 30 second timeout\n}\n\n// Main execution logic\nif (msg.payload === \"endProcess\") {\n    endChromeProcess(chromePath);\n} else if (msg.payload === \"startChrome\") {\n    if (!context.get('chromeRunning')) {\n        startChrome();\n    } else {\n        console.log('[Chrome Starter] Chrome Canary is already running.');\n        sendOutput({\n            payload: \"Chrome Canary is already running\",\n            chromeStarted: true,\n            error: null,\n            errorMessage: null\n        }, \"green\", \"Chrome Canary already running\");\n    }\n} else if (msg.payload === \"checkStatus\") {\n    sendOutput({\n        payload: context.get('chromeRunning') ? \"Chrome Canary is running\" : \"Chrome Canary is not running\",\n        chromeRunning: context.get('chromeRunning'),\n        error: null,\n        errorMessage: null\n    }, context.get('chromeRunning') ? \"green\" : \"yellow\", context.get('chromeRunning') ? \"Chrome Canary running\" : \"Chrome Canary not running\");\n} else if (msg.payload === \"restartProcess\") {\n    restartChromeProcess();\n} else {\n    node.error(\"Invalid command. Use 'startChrome', 'endProcess', 'checkStatus', or 'restartProcess'.\");\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "childProcess",
                "module": "child_process"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 730,
        "y": 220,
        "wires": [
            [
                "9d108a65765227a4",
                "50b5ebf17c38bd1c"
            ]
        ]
    },
    {
        "id": "41c65bc386f2efd0",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "startChrome",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "startChrome",
        "payloadType": "str",
        "x": 470,
        "y": 160,
        "wires": [
            [
                "47dc79bad9bac696"
            ]
        ]
    },
    {
        "id": "9d108a65765227a4",
        "type": "debug",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "Chrome Starter Debugger",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1030,
        "y": 220,
        "wires": []
    },
    {
        "id": "6df159f6597c93d8",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "endProcess",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "endProcess",
        "payloadType": "str",
        "x": 470,
        "y": 220,
        "wires": [
            [
                "47dc79bad9bac696"
            ]
        ]
    },
    {
        "id": "c05684c26ae329fa",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "restartProcess",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "restartProcess",
        "payloadType": "str",
        "x": 460,
        "y": 280,
        "wires": [
            [
                "47dc79bad9bac696"
            ]
        ]
    },
    {
        "id": "0a1fb772d6168db0",
        "type": "comment",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "Always make sure to set chatgpt appearance to dark;",
        "info": "Sign in via ch.peterlee@gmail.com\nAlways make sure to set chatgpt appearance to dark\nMake sure to allow clipboard",
        "x": 1100,
        "y": 280,
        "wires": []
    },
    {
        "id": "f84a1fc23c1d17b5",
        "type": "switch",
        "z": "25ffd91f1979976d",
        "name": "Check Sequence Complete",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Sequence Complete",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 540,
        "y": 540,
        "wires": [
            [
                "4dee6b92a8444360"
            ]
        ]
    },
    {
        "id": "1d526a46c84a5ffd",
        "type": "debug",
        "z": "25ffd91f1979976d",
        "name": "Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1270,
        "y": 700,
        "wires": []
    },
    {
        "id": "ef425a21d4aec03a",
        "type": "function",
        "z": "25ffd91f1979976d",
        "name": "Run Prompt",
        "func": "console.log('[Run Prompt] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPrompt = context.runPrompt || {};\ncontext.runPrompt.isStopRequested = msg.payload === \"stop\";\n\nconsole.log('context.runPrompt:', context.runPrompt);\n\nlet browser, browserContext, currentPage;\nconsole.log('[Run Prompt] Initial state:', { browser, browserContext, currentPage });\n\nasync function connectAndSetupPage() {\n    console.log('[Run Prompt] Entering connectAndSetupPage');\n    if (!browser) {\n        console.log('[Run Prompt] Browser not initialized, connecting...');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        console.log('[Run Prompt] Browser connected');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt] Browser context obtained');\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n        console.log('[Run Prompt] Current page set');\n    }\n    //    console.log('[Run Prompt] Exiting connectAndSetupPage:', { browser, browserContext, currentPage });\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    console.log('[Run Prompt] Entering getCurrentPage');\n    if (!browserContext) {\n        console.log('[Run Prompt] Browser context not found, creating new one');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt] New browser context created');\n    }\n    const pages = await browserContext.pages();\n    console.log('[Run Prompt] Number of pages:', pages.length);\n    const currentPage = pages[pages.length - 1];\n    //console.log('[Run Prompt] Exiting getCurrentPage, current page:', currentPage);\n    return currentPage;\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n\n        if (shouldClick) {\n            await button.click();\n\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    console.log('[Run Prompt] Entering reloadPageIfNecessary:', { retryCount });\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        console.log('[Run Prompt] Should reload:', shouldReload);\n        shouldReload && await page.reload({ waitUntil: 'networkidle' });\n        console.log('[Run Prompt] Page reloaded:', shouldReload);\n    } catch (error) {\n        console.log(`[Run Prompt] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    console.log('[Run Prompt] Entering waitForResponseCompletion');\n    console.log('[Run Prompt] Initializing variables');\n\n    let previousLength = 0, currentLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    console.log(`[Run Prompt] Max stable count: ${maxStableCount}, Max wait time: ${maxWaitTime}ms`);\n\n    while (Date.now() - startTime < maxWaitTime) {\n        console.log(`[Run Prompt] Elapsed time: ${Date.now() - startTime}ms`);\n\n        if (context.runPrompt.isStopRequested) {\n            console.log('[Run Prompt] Stop requested. Halting response completion.');\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            console.log('[Run Prompt] Attempting to get current page');\n            const page = await getCurrentPage();\n            console.log('[Run Prompt] Successfully got current page');\n\n            // Check for scroll-to-bottom button and click if visible\n            console.log('[Run Prompt] Checking for scroll-to-bottom button');\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                console.log('[Run Prompt] Scroll-to-bottom button clicked, waiting for scroll animation');\n                await page.waitForTimeout(1000); // Wait for scroll animation\n                console.log('[Run Prompt] Scroll animation wait complete');\n            } else {\n                console.log('[Run Prompt] Scroll-to-bottom button not found or not clicked');\n            }\n\n            console.log('[Run Prompt] Waiting for article selector');\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            console.log('[Run Prompt] Article selector found');\n\n            console.log('[Run Prompt] Querying for articles');\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n            console.log(`[Run Prompt] Found ${articles.length} articles`);\n\n            if (articles.length === 0) {\n                console.log('[Run Prompt] No articles found, waiting...');\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt] Attempting to extract content from last article');\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n                console.log('[Run Prompt] Content extracted successfully');\n            } catch (error) {\n                console.log('[Run Prompt] Error extracting content:', error.message);\n                console.log('[Run Prompt] Falling back to article.innerText()');\n                responseText = await lastArticle.innerText();\n                console.log('[Run Prompt] Fallback content extraction complete');\n            }\n\n            currentLength = responseText.length;\n            console.log(`[Run Prompt] Current response length: ${currentLength}`);\n            if (currentLength == 0) {\n                console.log('[Run Prompt] No content found in the response');\n            }\n\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n            console.log(`[Run Prompt] Is response stable: ${isStable}, Stable count: ${stableCount}`);\n\n            if (stableCount >= maxStableCount) {\n                console.log('[Run Prompt] Response appears to be complete');\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            console.log('[Run Prompt] Waiting for 2 seconds before next iteration');\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            console.log(`[Run Prompt] Error in waitForResponseCompletion: ${error.message}`);\n            console.log('[Run Prompt] Error stack:', error.stack);\n            console.log('[Run Prompt] Waiting for 3 seconds before retrying');\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    console.log('[Run Prompt] Max wait time exceeded. Returning current response.');\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    console.log('[Run Prompt] Entering extractResponseText');\n    let responseText = '';\n    let lastArticle;\n\n    try {\n        // Find all articles within the h-full div\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        console.log(`[Run Prompt] Found ${articles.length} articles`);\n\n        if (articles.length > 0) {\n            // Get the last article\n            lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt] Selected the last article');\n        } else {\n            throw new Error('No articles found');\n        }\n\n        // Find and click the copy button\n        const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n        if (copyButton) {\n            await copyButton.click();\n            await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n\n            // Get clipboard contents\n            responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            console.log('[Run Prompt] Response extracted from clipboard');\n        } else {\n            console.log('[Run Prompt] Copy button not found, falling back to original method');\n            const markdownDiv = await lastArticle.$('div.markdown');\n            if (markdownDiv) {\n                responseText = await markdownDiv.innerText();\n            } else {\n                throw new Error('Markdown div not found');\n            }\n        }\n    } catch (error) {\n        console.log('[Run Prompt] Error extracting content:', error.message);\n        try {\n            if (!lastArticle) {\n                lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n                if (!lastArticle) {\n                    throw new Error('Unable to find last article');\n                }\n            }\n            const textBaseElement = await lastArticle.$('.text-base');\n            if (textBaseElement) {\n                responseText = await textBaseElement.innerText();\n                console.log('[Run Prompt] Response extracted using alternative selector');\n            } else {\n                throw new Error('Alternative selector not found');\n            }\n        } catch (innerError) {\n            console.log('[Run Prompt] Alternative selector also failed, using entire article content');\n            if (lastArticle) {\n                responseText = await lastArticle.innerText();\n            } else {\n                console.log('[Run Prompt] Failed to extract any content');\n                responseText = '';\n            }\n        }\n    }\n\n    console.log('[Run Prompt] Exiting extractResponseText, response length:', responseText.length);\n    return responseText;\n}\n\nasync function stopGeneration() {\n    console.log('[Run Prompt] Entering stopGeneration');\n    context.runPrompt.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n    console.log('[Run Prompt] Exiting stopGeneration');\n}\n\nfunction clearStopRequestedState() {\n    context.runPrompt.isStopRequested = false;\n    console.log('[Run Prompt] Stop requested state cleared.');\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close().then(() => console.log('[Run Prompt] Browser closed'));\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage  // Set _continuation to true for the last message\n    };\n\n    const secondOutput = {\n        payload: result.payload,\n        status: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage === true\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPrompt(msg) {\n    console.log('[Run Prompt] Entering runPrompt');\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        console.log('[Run Prompt] Got current page in runPrompt');\n\n        const newChatButton = await page.$('nav > a.flex.py-3.px-3.items-center.gap-3.rounded-md:has-text(\"New chat\")');\n        if (newChatButton) {\n            console.log('[Run Prompt] Found new chat button, clicking...');\n            await newChatButton.click();\n            await page.waitForLoadState('networkidle');\n            console.log('[Run Prompt] Clicked new chat button');\n        } else {\n            console.log('[Run Prompt] New chat button not found');\n        }\n\n        await clickButtonIfVisible('button:has-text(\"Continue generating\")', true);\n\n        const promptText = msg.payload || 'Give me a recipe for biscuits';\n        console.log('[Run Prompt] Entering prompt:', promptText);\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n        await page.click('button[data-testid=\"send-button\"]');\n        console.log('[Run Prompt] Sent prompt');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n        console.log('[Run Prompt] Exiting runPrompt');\n        return responseText;\n    } catch (error) {\n        console.log(`[Run Prompt] Error in runPrompt: ${error.message}`);\n        console.log('[Run Prompt] Error stack:', error.stack);\n        throw error;\n    }\n}\n\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPrompt.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPrompt(msg);\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    console.log('This is the last step');\n    return msg.currentStep === msg.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    }; \n}\n\nfunction handleError(error) {\n    return {\n        payload: 'Error occurred: ' + error.message,\n        status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n        error: error.message\n    };\n}\n\nasync function executeScript(msg) {\n    console.log('[Run Prompt] Entering executeScript');\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n        \n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n            console.log('last step result: ', result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\n\n\nexecuteScript(msg);\n\nreturn null;\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 20,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1050,
        "y": 760,
        "wires": [
            [
                "1d526a46c84a5ffd",
                "2627327664c06a39"
            ],
            [
                "29c689da2e213293",
                "4348e7ddc1a7962a"
            ]
        ]
    },
    {
        "id": "29c689da2e213293",
        "type": "function",
        "z": "25ffd91f1979976d",
        "name": "Sequence Controller",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet prompts = context.get('prompts') || [];\nlet currentStep = context.get('currentStep') || 0;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\nfunction loadPrompts() {\n\n    const username = os.userInfo().username;\n\n    // Join DOCUMENTS_PATH with the specific folder structure\n    const filePath = msg.filePath\n    //const filePath = path.join(DOCUMENTS_PATH, 'Sync', 'PeterMainVault', '9 - Prompts', 'Execute', 'OtherPrompts.md');\n    console.log('File path:', filePath);\n\n    try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        const sections = content.split('\\n# ');\n\n        prompts = sections.slice(1).map(section => {\n            const [title, ...bodyLines] = section.split('\\n');\n            return {\n                title: title.trim(),\n                body: bodyLines.join('\\n').trim()\n            };\n        });\n\n        context.set('prompts', prompts);\n        console.log(`[Sequence Controller] Loaded ${prompts.length} prompts`);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${prompts.length} prompts` });\n    } catch (error) {\n        console.error(`[Sequence Controller] Failed to load prompts: ${error.message}`);\n        node.error(`Failed to load prompts from ${filePath}: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to load prompts\" });\n    }\n}\n\nfunction processNextPrompt() {\n    console.log(`[Sequence Controller] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < prompts.length) {\n        const msg = {\n            currentStep: currentStep,\n            totalSteps: prompts.length,  // Add this line\n            promptConfig: prompts[currentStep],\n            payload: prompts[currentStep].body,\n            _continuation: true\n        };\n        console.log(`[Sequence Controller] Sending prompt ${currentStep + 1} of ${prompts.length}`);\n        node.send(msg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${prompts.length}` });\n    } else {\n        console.log('[Sequence Controller] All prompts processed. Stopping.');\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[Sequence Controller] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[Sequence Controller] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    prompts = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('prompts', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, Prompts Unloaded\" });\n    // Send message to the Playwright function node if not last msg\n    if (msg._continuation == true){node.send({ payload: \"stop\" });}\n\n}\n\n// Load prompts if they haven't been loaded yet\nif (!prompts.length) {\n    loadPrompts();\n}\n\nif (msg._continuation) {\n    console.log(`[Sequence Controller] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.status === \"done\" || msg.status === \"End of Sequence\") {\n            console.log('[Sequence Controller] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            currentStep++;\n            context.set('currentStep', currentStep);\n            processNextPrompt();\n        } else if (msg.status === \"error\") {\n            console.log(`[Sequence Controller] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[Sequence Controller] Received new message with payload: ${msg.payload}`);\n    if (msg.status === \"start\") {\n        startProcessing();\n    } else if (msg.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.status === \"reload\") {\n        loadPrompts();\n    } else if (msg.status === \"Sequence Complete\") {\n        stopProcessing();\n        console.log('[Sequence Controller] All prompts processed. Stopping.'); \n        node.status({ fill: \"green\", shape: \"dot\", text: \"All prompts processed. Stopping.\" });\n    } else {\n        console.log(`[Sequence Controller] Unrecognized message: ${msg.payload}`);\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 780,
        "y": 760,
        "wires": [
            [
                "ef425a21d4aec03a"
            ]
        ]
    },
    {
        "id": "bc24d1d9d2540519",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "name": "Start Sequence",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "start",
        "payloadType": "str",
        "x": 500,
        "y": 740,
        "wires": [
            [
                "29c689da2e213293"
            ]
        ]
    },
    {
        "id": "de499bd492d5a04a",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "name": "Stop Sequence",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "stop",
        "payloadType": "str",
        "x": 500,
        "y": 780,
        "wires": [
            [
                "29c689da2e213293"
            ]
        ]
    },
    {
        "id": "1d01dfd62ac31e64",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "name": "Reload Sequence",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "reload",
        "payloadType": "str",
        "x": 490,
        "y": 820,
        "wires": [
            [
                "29c689da2e213293"
            ]
        ]
    },
    {
        "id": "c7604cad143a9875",
        "type": "inject",
        "z": "25ffd91f1979976d",
        "name": "Start Process",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "jumpTo",
                "v": "",
                "vt": "num"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "start",
        "payloadType": "str",
        "x": 390,
        "y": 480,
        "wires": [
            [
                "fd5c9dd229e436a8"
            ]
        ]
    },
    {
        "id": "4dee6b92a8444360",
        "type": "function",
        "z": "25ffd91f1979976d",
        "name": "queueManager",
        "func": "// Initialize queue if not already done\nlet fileQueue = context.get('fileQueue') || [];\n\n// Check if msg.files is not empty\nif (msg.files && msg.files.length > 0) {\n    fileQueue = msg.files;\n    context.set('fileQueue', fileQueue);\n}\n\n// Initialize queue position\nlet queuePosition = context.get('queuePosition') || 0;\n\n// Check for stop command\nif (msg.payload === 'stop') {\n    let remainingItems = fileQueue.slice(queuePosition);\n\n    // Send a message for each remaining item\n    remainingItems.forEach((file, index) => {\n        node.send({\n            payload: file,\n            queuePosition: queuePosition + index,\n            totalSpots: fileQueue.length,\n            stopMessage: true\n        });\n    });\n\n    // Clear the queue and reset the position\n    context.set('fileQueue', []);\n    context.set('queuePosition', 0);\n\n    // Update node status\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Queue stopped and cleared\" });\n\n    // Send a final message indicating the queue has been stopped and cleared\n    return { payload: 'Queue stopped and cleared', stopMessage: true };\n}\n\n// Handle jumpTo logic\nif (msg.hasOwnProperty('jumpTo') && msg.jumpTo >= 0 && msg.jumpTo < fileQueue.length) {\n    queuePosition = msg.jumpTo;\n    context.set('queuePosition', queuePosition);\n}\n\n// Update node status to show current position in queue\nnode.status({ fill: \"blue\", shape: \"dot\", text: `Position: ${queuePosition + 1}/${fileQueue.length}` });\n\n// Check if there are files left to process\nif (queuePosition < fileQueue.length) {\n    msg.payload = fileQueue[queuePosition];\n    msg.queuePosition = queuePosition;\n    msg.totalSpots = fileQueue.length;\n    queuePosition += 1;\n    context.set('queuePosition', queuePosition);\n} else {\n    msg.payload = 'Queue is empty';\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Queue is empty\" });\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 800,
        "y": 540,
        "wires": [
            [
                "28ddafa6508fe319"
            ]
        ]
    },
    {
        "id": "7418888940c4f538",
        "type": "debug",
        "z": "25ffd91f1979976d",
        "name": "Processed Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1250,
        "y": 540,
        "wires": []
    },
    {
        "id": "28ddafa6508fe319",
        "type": "function",
        "z": "25ffd91f1979976d",
        "name": "queueOutput",
        "func": "if (msg.payload !== 'Queue is empty') {\n    let lastMessage = (msg.queuePosition === msg.totalSpots - 1);\n    let processedFile = {\n        payload: \"start\",\n        status: \"start\",        \n        filePath: msg.payload, \n        queuePosition: msg.queuePosition, \n        totalSpots: msg.totalSpots, \n        lastMessage: lastMessage \n    };\n    let completionMessage = { payload: 'Sequence Complete' };\n\n    // Update node status to show if it's the last message\n    if (lastMessage) {\n        node.status({fill: \"green\", shape: \"dot\", text: \"Last Message\"});\n    } else {\n        node.status({fill: \"yellow\", shape: \"dot\", text: `Queue Position: ${msg.queuePosition + 1}/${msg.totalSpots}`});\n    }\n\n    return [processedFile];\n}\nreturn [null, null];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 990,
        "y": 540,
        "wires": [
            [
                "7418888940c4f538",
                "29c689da2e213293"
            ]
        ]
    },
    {
        "id": "fd5c9dd229e436a8",
        "type": "function",
        "z": "25ffd91f1979976d",
        "name": "File Paths",
        "func": "const username = os.userInfo().username;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\n// Join DOCUMENTS_PATH with the specific folder structure\nconst filePath1 = path.join(cimaPrompts, 'Hyperprompts', 'shortTest.md');\nconst filePath2 = path.join(cimaPrompts, 'Hyperprompts', 'shortTest2.md');\n\nlet files = [filePath1, filePath2, \"file3.txt\"];\n\nmsg.files = files;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 580,
        "y": 480,
        "wires": [
            [
                "4dee6b92a8444360"
            ]
        ]
    },
    {
        "id": "4348e7ddc1a7962a",
        "type": "link out",
        "z": "25ffd91f1979976d",
        "name": "link out 2",
        "mode": "link",
        "links": [
            "12fac23c827ca14a"
        ],
        "x": 1245,
        "y": 820,
        "wires": []
    },
    {
        "id": "12fac23c827ca14a",
        "type": "link in",
        "z": "25ffd91f1979976d",
        "name": "LO: Seq Complete Signal",
        "links": [
            "4348e7ddc1a7962a"
        ],
        "x": 365,
        "y": 540,
        "wires": [
            [
                "f84a1fc23c1d17b5"
            ]
        ]
    },
    {
        "id": "d9a3ca46d7a25ecb",
        "type": "comment",
        "z": "25ffd91f1979976d",
        "name": "2. Manages the Queue",
        "info": "2. Manages the Queue",
        "x": 440,
        "y": 420,
        "wires": []
    },
    {
        "id": "605afeb07790bcef",
        "type": "comment",
        "z": "25ffd91f1979976d",
        "g": "ad9ab3ccb98c5479",
        "name": "1. Initializes Chrome",
        "info": "",
        "x": 450,
        "y": 120,
        "wires": []
    },
    {
        "id": "eca6dd4bd3db52b1",
        "type": "comment",
        "z": "25ffd91f1979976d",
        "name": "Output according to the mode!",
        "info": "",
        "x": 1340,
        "y": 660,
        "wires": []
    },
    {
        "id": "2627327664c06a39",
        "type": "function",
        "z": "25ffd91f1979976d",
        "name": "Outputter",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1280,
        "y": 760,
        "wires": [
            []
        ]
    },
    {
        "id": "d99ecfbefcf0e8d5",
        "type": "comment",
        "z": "6fd22f15cd2422d0",
        "name": "preset debug prompt + Content",
        "info": "",
        "x": 2410,
        "y": 220,
        "wires": []
    },
    {
        "id": "31b8288b02620cfb",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "Check Chrome and Navigate",
        "func": "// Retrieve initializeController function from context\nconst initializeControllerFn = context.get('initializeController');\n\nif (typeof initializeControllerFn !== 'function') {\n    node.error('initializeController is not a function. Reinitializing...');\n    // Reinitialize if the function is not found\n    context.set('initializeController', initializeController(context));\n}\n\n// Retrieve or initialize the controller\nlet controller;\ntry {\n    controller = await initializeControllerFn();\n} catch (error) {\n    node.error('Failed to initialize controller: ' + error.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Initialization failed\" });\n    return null;\n}\n\n// Main logic\ntry {\n    await controller.handleMessage(msg);\n    if (controller.isReady) {\n        node.status({ fill: \"green\", shape: \"dot\", text: \"Controller ready\" });\n\n        // Check if the page has been navigated to\n        if (controller.lastNavigatedUrl === 'https://chat.openai.com') {\n            msg.siteLoaded = true;\n            node.status({ fill: \"green\", shape: \"dot\", text: \"Site loaded\" });\n        }\n    } else {\n        node.status({ fill: \"yellow\", shape: \"ring\", text: \"Waiting for Chrome\" });\n    }\n} catch (error) {\n    node.error('Error processing message: ' + error.message);\n    node.status({ fill: \"red\", shape: \"ring\", text: \"Error processing message\" });\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 1,
        "initialize": "// Define the ChromeController class\nclass ChromeController {\n    constructor() {\n        this.browser = null;\n        this.isReady = false;\n        this.lastNavigatedUrl = null;  // Add this line\n    }\n\n    async connectToBrowser() {\n        console.log('Attempting to connect to Chrome via CDP on port 27000...');\n        this.browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        console.log('Successfully connected to Chrome via CDP on port 27000.');\n        this.isReady = true;\n    }\n\n    async logContextsAndPages() {\n        const contexts = this.browser.contexts();\n        console.log(`Found ${contexts.length} context(s).`);\n\n        for (let i = 0; i < contexts.length; i++) {\n            const context = contexts[i];\n            const pages = context.pages();\n            console.log(`Context ${i + 1} has ${pages.length} page(s).`);\n            for (let j = 0; j < pages.length; j++) {\n                console.log(`  Page ${j + 1}: ${pages[j].url()}`);\n            }\n        }\n\n        return contexts;\n    }\n\n    async getOrCreateContext() {\n        let contexts = this.browser.contexts();\n        if (contexts.length === 0) {\n            console.log('No contexts found, creating a new one.');\n            return await this.browser.newContext();\n        }\n        return contexts[0];\n    }\n\n    async getOrCreatePage(context) {\n        const pages = context.pages();\n        if (pages.length > 0) {\n            console.log('Found an open tab, using it.');\n            return pages[0];\n        } else {\n            console.log('No open tabs found, creating a new tab.');\n            return await context.newPage();\n        }\n    }\n\n    async navigateToChat(page) {\n        console.log('Navigating to ChatGPT...');\n        await page.goto('https://chat.openai.com', { waitUntil: 'networkidle' });\n        console.log('Navigated to ChatGPT using the connected Chrome instance.');\n        const title = await page.title();\n        console.log(`Page title after navigation: ${title}`);\n        this.lastNavigatedUrl = 'https://chat.openai.com';  // Add this line\n    }\n\n\n    async disconnectFromBrowser() {\n        if (this.browser) {\n            try {\n                await this.browser.close();\n                console.log('Closed the CDP connection to the browser.');\n            } catch (error) {\n                console.error('Error closing CDP connection:', error);\n            } finally {\n                this.browser = null;\n                this.isReady = false;\n            }\n        }\n    }\n\n    async handleMessage(message) {\n        console.log('Handling message:', JSON.stringify(message));\n        try {\n            if (typeof message === 'object' && message.chromeStarted === true) {\n                console.log('Chrome started. Connecting to the browser...');\n                await this.connectToBrowser();\n                await this.logContextsAndPages();\n                const context = await this.getOrCreateContext();\n                const page = await this.getOrCreatePage(context);\n                await this.navigateToChat(page);\n            } else if (typeof message === 'object' && message.chromeEnded === true) {\n                console.log('Chrome ended. Disconnecting from the browser...');\n                await this.disconnectFromBrowser();\n            } else {\n                console.log('Unrecognized message. Ignoring.');\n            }\n        } catch (error) {\n            console.error('Error handling message:', error);\n        }\n    }\n}\n\n\n/// Function to initialize the controller\nfunction initializeController(context) {\n    return async function () {\n        let controller = context.get('controller');\n        if (!controller) {\n            node.status({ fill: \"blue\", shape: \"dot\", text: \"Initializing controller...\" });\n            controller = new ChromeController();\n            context.set('controller', controller);\n        }\n        return controller;\n    }\n}\n\n// Store the initializeController function in the context\ncontext.set('initializeController', initializeController(context));\n\n// Set initial status\nnode.status({ fill: \"yellow\", shape: \"ring\", text: \"Waiting for message\" });",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1100,
        "y": 360,
        "wires": [
            [
                "d058aac6d68b73c4"
            ]
        ]
    },
    {
        "id": "d058aac6d68b73c4",
        "type": "debug",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "false",
        "targetType": "full",
        "x": 1350,
        "y": 360,
        "wires": []
    },
    {
        "id": "1f102993cb2cd091",
        "type": "inject",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "chromeStarted",
        "props": [
            {
                "p": "chromeStarted",
                "v": "true",
                "vt": "bool"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "x": 800,
        "y": 360,
        "wires": [
            [
                "31b8288b02620cfb"
            ]
        ]
    },
    {
        "id": "4df1f5d4059f8e19",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "Start Chrome With Profile",
        "func": "// Function to detect the operating system\nfunction getOperatingSystem() {\n    const osPlatform = os.platform();\n    if (osPlatform === 'win32') {\n        return 'windows';\n    } else if (osPlatform === 'darwin') {\n        return 'mac';\n    } else if (osPlatform === 'linux') {\n        return 'linux';\n    } else {\n        console.error('Unsupported OS');\n        return 'unsupported';\n    }\n}\n\nlet chromePath = global.get('userRootPaths').chrome;\n\nconst chromeArgs = ['--remote-debugging-port=27000', '--profile-directory=Profile 4'];\n\n// Initialize context variables if they don't exist\nif (context.get('chromeRunning') === undefined) {\n    context.set('chromeRunning', false, 'file');\n}\nif (context.get('checkAttempts') === undefined) {\n    context.set('checkAttempts', 0, 'file');\n}\n\nconst maxAttempts = 10;\n\nfunction sendOutput(msg, fillColor, text) {\n    node.status({ fill: fillColor, shape: \"dot\", text: text });\n    console.log('[Chrome Starter] Sending output message:', msg);\n    node.send(msg);\n}\n\nfunction checkChromeRunning() {\n    let command;\n    let processName;\n    const osType = getOperatingSystem();\n\n    console.log(`[checkChromeRunning] Detected OS: ${osType}`);\n\n    if (osType === 'windows') {\n        // Simplified to only check if Chrome is running\n        command = 'tasklist /FI \"IMAGENAME eq chrome.exe\"';\n        processName = 'chrome.exe';\n    } else if (osType === 'mac') {\n        command = 'ps aux | grep \"[G]oogle Chrome Canary\"';\n        processName = 'Google Chrome Canary';\n    } else if (osType === 'linux') {\n        command = 'ps aux | grep \"[C]hrome\"';\n        processName = 'chrome';\n    } else {\n        console.error('[checkChromeRunning] Unsupported OS');\n        return;\n    }\n\n    console.log(`[checkChromeRunning] Executing command: ${command}`);\n\n    childProcess.exec(command, (error, stdout, stderr) => {\n        let checkAttempts = context.get('checkAttempts') || 0;\n\n        console.log(`[checkChromeRunning] Command output: ${stdout}`);\n        console.log(`[checkChromeRunning] Command error output (if any): ${stderr}`);\n        \n        if (error) {\n            console.error(`[checkChromeRunning] Command execution error: ${error.message}`);\n        }\n\n        if (stdout.toLowerCase().includes(processName.toLowerCase())) {\n            console.log('[Chrome Starter] Chrome Canary process found running');\n            context.set('chromeRunning', true, 'file');\n            context.set('checkAttempts', 0, 'file');\n            sendOutput({\n                payload: \"Chrome started successfully (verified running)\",\n                chromeStarted: true,\n                error: null,\n                errorMessage: null\n            }, \"green\", \"Chrome started (verified)\");\n        } else {\n            console.log(`[Chrome Starter] Chrome Canary process not found, attempt ${checkAttempts + 1}`);\n            checkAttempts++;\n            context.set('checkAttempts', checkAttempts, 'file');\n            if (checkAttempts >= maxAttempts) {\n                console.log('[Chrome Starter] Max attempts reached, Chrome start failed');\n                context.set('chromeRunning', false, 'file');\n                context.set('checkAttempts', 0, 'file');\n                sendOutput({\n                    payload: \"Chrome failed to start (process not found after multiple attempts)\",\n                    chromeStarted: false,\n                    error: new Error(\"Chrome process not found after multiple attempts\"),\n                    errorMessage: \"Chrome process not found after multiple attempts\"\n                }, \"red\", \"Chrome start failed\");\n            } else {\n                setTimeout(checkChromeRunning, 2000);\n            }\n        }\n    });\n}\n\n\n\nfunction startChrome() {\n    if (context.get('chromeRunning')) {\n        console.log('[Chrome Starter] Chrome is already running');\n        sendOutput({\n            payload: \"Chrome is already running\",\n            chromeStarted: true,\n            error: null,\n            errorMessage: null\n        }, \"green\", \"Chrome already running\");\n        return;\n    }\n\n    console.log('[Chrome Starter] Initiating Chrome start process');\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Starting Chrome...\" });\n    console.log('[Chrome Starter] Executing command:', chromePath, chromeArgs.join(' '));\n\n    // Add a 300ms delay before starting Chrome\n    setTimeout(() => {\n        try {\n            const chromeProcess = childProcess.spawn(chromePath, chromeArgs, {\n                detached: true,\n                stdio: 'ignore'\n            });\n\n            chromeProcess.on('error', (err) => {\n                console.error('[Chrome Starter] Failed to start Chrome:', err);\n                sendOutput({\n                    payload: `Failed to start Chrome: ${err.message}`,\n                    chromeStarted: false,\n                    error: err,\n                    errorMessage: err.message\n                }, \"red\", \"Chrome start error\");\n            });\n\n            chromeProcess.unref();\n\n            // Start checking immediately after spawning the process\n            setTimeout(checkChromeRunning, 1000);\n        } catch (err) {\n            console.error('[Chrome Starter] Error when trying to start Chrome:', err);\n            sendOutput({\n                payload: `Error when trying to start Chrome: ${err.message}`,\n                chromeStarted: false,\n                error: err,\n                errorMessage: err.message\n            }, \"red\", \"Chrome start error\");\n        }\n    }, 300); // 300ms delay before starting Chrome\n}\n\nfunction endChromeProcess(chromePath) {\n    if (!context.get('chromeRunning')) {\n        console.log('[Chrome Starter] No Chrome Canary process to end');\n        sendOutput({\n            payload: \"No Chrome Canary process to end\",\n            chromeEnded: false,\n            error: null,\n            errorMessage: null\n        }, \"yellow\", \"No Chrome Canary process\");\n        return;\n    }\n\n    if (!chromePath) {\n        console.error('[Chrome Starter] chromePath is undefined or null');\n        sendOutput({\n            payload: \"chromePath is undefined\",\n            chromeEnded: false,\n            error: true,\n            errorMessage: 'chromePath is undefined or null'\n        }, \"red\", \"Error\");\n        return;\n    }\n\n    console.log('[Chrome Starter] Gracefully ending Chrome Canary process');\n\n    const osType = getOperatingSystem();\n\n    if (osType === 'windows') {\n        // Ensure chromePath is properly escaped for the command line\n        const escapedChromePath = chromePath.replace(/\\\\/g, '\\\\\\\\');\n        const command = `wmic process where \"name='chrome.exe' and commandline like '%${escapedChromePath}%'\" call terminate`;\n        childProcess.exec(command, (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error closing Chrome Canary processes:', stderr || error);\n                forceKillChrome();\n                return;\n            }\n\n            console.log('[Chrome Starter] Chrome Canary processes closed, waiting briefly for processes to end');\n            setTimeout(checkChromeProcesses, 2000); // Wait 2 seconds before checking\n        });\n    } else if (osType === 'mac' || osType === 'linux') {\n        // Use pgrep to find the process ID and then send a quit signal\n        childProcess.exec(`pgrep -f \"${chromePath}\"`, (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error finding Chrome Canary processes:', stderr || error);\n                forceKillChrome();\n                return;\n            }\n\n            const pids = stdout.trim().split('\\n').filter(pid => pid.trim() !== '');\n            if (pids.length > 0) {\n                console.log(`[Chrome Starter] Found Chrome Canary process(es): ${pids.join(', ')}. Attempting to gracefully quit each...`);\n                pids.forEach(pid => {\n                    childProcess.exec(`kill -15 ${pid}`, (error, stdout, stderr) => {\n                        if (error) {\n                            console.error(`[Chrome Starter] Error sending quit signal to PID ${pid}:`, stderr || error);\n                        } else {\n                            console.log(`[Chrome Starter] Quit signal sent to PID ${pid}.`);\n                        }\n                    });\n                });\n\n                // Delay to allow processes to quit gracefully\n                setTimeout(checkChromeProcesses, 5000); // 5 seconds before checking\n            } else {\n                console.log('[Chrome Starter] No Chrome Canary process found to quit');\n                sendOutput({\n                    payload: \"No Chrome Canary process found to quit\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"yellow\", \"No Chrome Canary process found\");\n            }\n        });\n    } else {\n        console.error('[Chrome Starter] Unsupported OS detected');\n    }\n}\n\n\nfunction checkChromeProcesses() {\n    const osType = getOperatingSystem();\n\n    if (osType === 'windows') {\n        childProcess.exec('tasklist /FI \"IMAGENAME eq chrome.exe\" /FO CSV /NH /FI \"WINDOWTITLE eq Google Chrome Canary\"', (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error checking Chrome Canary processes:', error);\n                forceKillChrome();\n                return;\n            }\n\n            const chromeProcesses = stdout.split('\\n').filter(line => line.includes('chrome.exe'));\n\n            if (chromeProcesses.length === 0) {\n                console.log('[Chrome Starter] All Chrome Canary processes ended successfully');\n                context.set('chromeRunning', false, 'file');\n                sendOutput({\n                    payload: \"Chrome Canary processes ended successfully\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"blue\", \"Chrome Canary ended\");\n            } else {\n                console.log('[Chrome Starter] Chrome Canary processes still running, force killing');\n                forceKillChrome();\n            }\n        });\n    } else if (osType === 'mac' || osType === 'linux') {\n        childProcess.exec('pgrep -f \"Google Chrome Canary\"', (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error checking Chrome Canary processes:', error);\n                forceKillChrome();\n                return;\n            }\n\n            const chromeProcesses = stdout.split('\\n').filter(line => line.trim() !== '');\n\n            if (chromeProcesses.length === 0) {\n                console.log('[Chrome Starter] All Chrome Canary processes ended successfully');\n                context.set('chromeRunning', false, 'file');\n                sendOutput({\n                    payload: \"Chrome Canary processes ended successfully\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"blue\", \"Chrome Canary ended\");\n            } else {\n                console.log('[Chrome Starter] Chrome Canary processes still running, force killing');\n                forceKillChrome();\n            }\n        });\n    } else {\n        console.error('Unsupported OS');\n    }\n}\n\nfunction forceKillChrome() {\n    const osType = getOperatingSystem();\n\n    console.log(`[Chrome Starter] Detected OS: ${osType}`);\n\n    if (osType === 'windows') {\n        console.log('[Chrome Starter] Attempting to force kill Chrome Canary on Windows using taskkill...');\n        childProcess.exec('taskkill /F /IM chrome.exe /FI \"WINDOWTITLE eq Google Chrome Canary\"', (error, stdout, stderr) => {\n            if (error) {\n                console.error('[Chrome Starter] Error force killing Chrome Canary process:', error);\n                console.error('[Chrome Starter] Command output:', stdout);\n                console.error('[Chrome Starter] Command error output:', stderr);\n                sendOutput({\n                    payload: \"Error ending Chrome Canary process\",\n                    chromeEnded: false,\n                    error: error,\n                    errorMessage: error.message || JSON.stringify(error)\n                }, \"red\", \"Error ending Chrome Canary\");\n            } else {\n                console.log('[Chrome Starter] Chrome Canary process force killed successfully. Command output:', stdout);\n                context.set('chromeRunning', false, 'file');\n                sendOutput({\n                    payload: \"Chrome Canary process force killed successfully\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"blue\", \"Chrome Canary ended (forced)\");\n            }\n        });\n    } else if (osType === 'mac' || osType === 'linux') {\n        console.log(`[Chrome Starter] Attempting to find Chrome Canary processes on ${osType} using pgrep...`);\n        childProcess.exec('pgrep -f \"Google Chrome Canary\"', (error, stdout, stderr) => {\n            console.log('[Chrome Starter] pgrep command output:', stdout);\n            console.log('[Chrome Starter] pgrep command error output:', stderr);\n            const pids = stdout.trim().split('\\n');\n\n            if (pids.length === 0 || pids[0] === '') {\n                console.log('[Chrome Starter] No Chrome Canary process found to kill');\n                sendOutput({\n                    payload: \"No Chrome Canary process found to kill\",\n                    chromeEnded: true,\n                    error: null,\n                    errorMessage: null\n                }, \"yellow\", \"No Chrome Canary process found\");\n            } else {\n                console.log(`[Chrome Starter] Found Chrome Canary process(es): ${pids.join(', ')}. Attempting to force kill each...`);\n                \n                let killErrors = [];\n                let killSuccess = false;\n\n                pids.forEach(pid => {\n                    console.log(`[Chrome Starter] Attempting to kill process ID: ${pid}`);\n                    childProcess.exec(`kill -9 ${pid}`, (error, stdout, stderr) => {\n                        if (error) {\n                            console.error(`[Chrome Starter] Error force killing Chrome Canary process with PID ${pid}:`, error);\n                            console.error(`[Chrome Starter] kill command output for PID ${pid}:`, stdout);\n                            console.error(`[Chrome Starter] kill command error output for PID ${pid}:`, stderr);\n                            killErrors.push(`Error killing PID ${pid}: ${error.message}`);\n                        } else {\n                            console.log(`[Chrome Starter] Successfully killed Chrome Canary process with PID ${pid}.`);\n                            killSuccess = true;\n                        }\n                    });\n                });\n\n                setTimeout(() => {\n                    if (killSuccess) {\n                        context.set('chromeRunning', false, 'file');\n                        sendOutput({\n                            payload: \"Chrome Canary process(es) force killed successfully\",\n                            chromeEnded: true,\n                            error: null,\n                            errorMessage: null\n                        }, \"blue\", \"Chrome Canary ended (forced)\");\n                    } else {\n                        sendOutput({\n                            payload: \"Failed to end some or all Chrome Canary processes\",\n                            chromeEnded: false,\n                            error: new Error(killErrors.join('\\n')),\n                            errorMessage: killErrors.join('\\n')\n                        }, \"red\", \"Error ending Chrome Canary\");\n                    }\n                }, 1000);  // Delay to allow all kill commands to complete\n            }\n        });\n    } else {\n        console.error('[Chrome Starter] Unsupported OS detected');\n    }\n}\n\nfunction restartChromeProcess() {\n    console.log('[Chrome Starter] Restart process initiated');\n\n    if (!context.get('chromeRunning')) {\n        console.log('[Chrome Starter] Chrome Canary is not running. Starting new instance.');\n        node.status({ fill: \"blue\", shape: \"dot\", text: \"Starting Chrome...\" });\n        startChrome();\n        return;\n    }\n\n    console.log('[Chrome Starter] Restarting Chrome Canary process');\n    node.status({ fill: \"blue\", shape: \"dot\", text: \"Restarting Chrome Canary...\"});\n\n    // First, end the Chrome Canary process\n    endChromeProcess(chromePath);\n\n    // Wait for the end process to complete before starting\n    const checkAndStart = setInterval(() => {\n        if (!context.get('chromeRunning')) {\n            clearInterval(checkAndStart);\n            console.log('[Chrome Starter] Chrome Canary process ended, now starting...');\n            setTimeout(startChrome, 1000); // Wait an additional second before starting\n        }\n    }, 500); // Check every 500ms\n\n    // Set a timeout to prevent infinite waiting\n    setTimeout(() => {\n        clearInterval(checkAndStart);\n        if (context.get('chromeRunning')) {\n            console.log('[Chrome Starter] Restart failed: Could not end Chrome Canary process');\n            sendOutput({\n                payload: \"Restart failed: Could not end Chrome Canary process\",\n                chromeRestarted: false,\n                error: new Error(\"Could not end Chrome Canary process during restart\"),\n                errorMessage: \"Could not end Chrome Canary process during restart\"\n            }, \"red\", \"Restart failed\");\n        }\n    }, 30000); // 30 second timeout\n}\n\n// Main execution logic\nif (msg.payload === \"endProcess\") {\n    endChromeProcess(chromePath);\n} else if (msg.payload === \"startChrome\") {\n    if (!context.get('chromeRunning')) {\n        startChrome();\n    } else {\n        console.log('[Chrome Starter] Chrome Canary is already running.');\n        sendOutput({\n            payload: \"Chrome Canary is already running\",\n            chromeStarted: true,\n            error: null,\n            errorMessage: null\n        }, \"green\", \"Chrome Canary already running\");\n    }\n} else if (msg.payload === \"checkStatus\") {\n    sendOutput({\n        payload: context.get('chromeRunning') ? \"Chrome Canary is running\" : \"Chrome Canary is not running\",\n        chromeRunning: context.get('chromeRunning'),\n        error: null,\n        errorMessage: null\n    }, context.get('chromeRunning') ? \"green\" : \"yellow\", context.get('chromeRunning') ? \"Chrome Canary running\" : \"Chrome Canary not running\");\n} else if (msg.payload === \"restartProcess\") {\n    restartChromeProcess();\n} else {\n    node.error(\"Invalid command. Use 'startChrome', 'endProcess', 'checkStatus', or 'restartProcess'.\");\n}\n\nreturn null;\n",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "childProcess",
                "module": "child_process"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 830,
        "y": 260,
        "wires": [
            [
                "529ac81730214a31",
                "31b8288b02620cfb"
            ]
        ]
    },
    {
        "id": "d11e099b958aeb59",
        "type": "inject",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "startChrome",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "startChrome",
        "payloadType": "str",
        "x": 570,
        "y": 200,
        "wires": [
            [
                "4df1f5d4059f8e19"
            ]
        ]
    },
    {
        "id": "529ac81730214a31",
        "type": "debug",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "Chrome Starter Debugger",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1130,
        "y": 260,
        "wires": []
    },
    {
        "id": "cd155de25c64c785",
        "type": "inject",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "endProcess",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "endProcess",
        "payloadType": "str",
        "x": 570,
        "y": 260,
        "wires": [
            [
                "4df1f5d4059f8e19"
            ]
        ]
    },
    {
        "id": "99fe35068c9a6c78",
        "type": "inject",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "restartProcess",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "restartProcess",
        "payloadType": "str",
        "x": 560,
        "y": 320,
        "wires": [
            [
                "4df1f5d4059f8e19"
            ]
        ]
    },
    {
        "id": "0fa9e9c17cfacb08",
        "type": "comment",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "Always make sure to set chatgpt appearance to dark;",
        "info": "Sign in via ch.peterlee@gmail.com\nAlways make sure to set chatgpt appearance to dark\nMake sure to allow clipboard",
        "x": 1200,
        "y": 320,
        "wires": []
    },
    {
        "id": "2aaa4823845f8d59",
        "type": "comment",
        "z": "6fd22f15cd2422d0",
        "g": "800948336d4baaaa",
        "name": "1. Initializes Chrome",
        "info": "",
        "x": 550,
        "y": 160,
        "wires": []
    },
    {
        "id": "b4ebf83385bd4ae0",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "name": "function 1",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 2360,
        "y": 280,
        "wires": [
            []
        ]
    },
    {
        "id": "4d910338dc678e98",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "name": "function 2",
        "func": "async function nodeTest (msg){\nnode.send([msg, msg]);\n}\n\nawait nodeTest(msg);",
        "outputs": 2,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1760,
        "y": 260,
        "wires": [
            [
                "3847b83049aabd0f"
            ],
            [
                "aa3401a9603c2b7d"
            ]
        ]
    },
    {
        "id": "3847b83049aabd0f",
        "type": "debug",
        "z": "6fd22f15cd2422d0",
        "name": "debug 2",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 240,
        "wires": []
    },
    {
        "id": "1deadd63088e3fa9",
        "type": "inject",
        "z": "6fd22f15cd2422d0",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 1600,
        "y": 260,
        "wires": [
            [
                "4d910338dc678e98"
            ]
        ]
    },
    {
        "id": "aa3401a9603c2b7d",
        "type": "debug",
        "z": "6fd22f15cd2422d0",
        "name": "debug 3",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1940,
        "y": 300,
        "wires": []
    },
    {
        "id": "d248b33ccca637ad",
        "type": "delay",
        "z": "6fd22f15cd2422d0",
        "name": "Wait for Stabilization",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "outputs": 1,
        "x": 500,
        "y": 700,
        "wires": [
            [
                "525ededf5411f55d"
            ]
        ]
    },
    {
        "id": "5c727f3ec5f88e5a",
        "type": "comment",
        "z": "6fd22f15cd2422d0",
        "name": "preset debug prompt + Content",
        "info": "",
        "x": 1410,
        "y": 1100,
        "wires": []
    },
    {
        "id": "e338d17044c66a7f",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "name": "function 3",
        "func": "\nreturn msg;",
        "outputs": 1,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1380,
        "y": 1160,
        "wires": [
            []
        ]
    },
    {
        "id": "f0d6f8739b76928b",
        "type": "debug",
        "z": "6fd22f15cd2422d0",
        "name": "debug 4",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1600,
        "y": 840,
        "wires": []
    },
    {
        "id": "dff61d0f228f4c95",
        "type": "saveflow",
        "z": "6fd22f15cd2422d0",
        "name": "",
        "path": "",
        "enabled": false,
        "exporttype": "original",
        "x": 300,
        "y": 700,
        "wires": [
            [
                "d248b33ccca637ad"
            ]
        ]
    },
    {
        "id": "1cdad3d653c0e5fa",
        "type": "inject",
        "z": "6fd22f15cd2422d0",
        "g": "d8cc715c64703cde",
        "name": "Trigger Event",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 530,
        "y": 520,
        "wires": [
            [
                "51e86c26bd777951"
            ]
        ]
    },
    {
        "id": "51e86c26bd777951",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "d8cc715c64703cde",
        "name": "Run Script",
        "func": "// Custom script logic\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 530,
        "y": 580,
        "wires": [
            [
                "525ededf5411f55d"
            ]
        ]
    },
    {
        "id": "525ededf5411f55d",
        "type": "file in",
        "z": "6fd22f15cd2422d0",
        "g": "d8cc715c64703cde",
        "name": "Read Log File",
        "filename": "C:\\Users\\LOU\\.node-red\\logs\\node-red.log",
        "filenameType": "str",
        "format": "utf8",
        "sendError": false,
        "allProps": false,
        "x": 780,
        "y": 620,
        "wires": [
            [
                "458713510b3edb94"
            ]
        ]
    },
    {
        "id": "458713510b3edb94",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "d8cc715c64703cde",
        "name": "Filter Logs by Timestamp",
        "func": "// Ensure logs is an array of lines\nlet logs = Array.isArray(msg.payload) ? msg.payload : msg.payload.split('\\n');\n\nlet lastIndex = -1;\nlet totalOccurrences = 0;\n\n// Find the last occurrence and count total occurrences\nfor (let i = logs.length - 1; i >= 0; i--) {\n    if (logs[i].includes(\"[INFO] default - Started flows\")) {\n        if (lastIndex === -1) {\n            lastIndex = i;\n        }\n        totalOccurrences++;\n    }\n}\n\nif (lastIndex !== -1) {\n    // Calculate the line number (add 1 because array indices start at 0)\n    let lineNumber = lastIndex + 1;\n\n    // Log and store the line number\n    console.log(`Last occurrence of \"[INFO] default - Started flows\" is on line ${lineNumber}`);\n    msg.lastStartedFlowsLineNumber = lineNumber;\n    msg.payload = \"loaded logs\"\n    // Slice the array from the found index to the end\n    msg.log = logs.slice(lastIndex).join('\\n');\n} else {\n    // If the line is not found, keep all logs and add a warning\n    msg.log = logs.join('\\n');\n    msg.warning = \"The line '[INFO] default - Started flows' was not found in the logs.\";\n}\n\n// Log the total number of occurrences\nconsole.log(`Total occurrences of \"[INFO] default - Started flows\": ${totalOccurrences}`);\nmsg.totalStartedFlowsOccurrences = totalOccurrences;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1030,
        "y": 620,
        "wires": [
            [
                "27692842a0727548"
            ]
        ]
    },
    {
        "id": "27692842a0727548",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "d8cc715c64703cde",
        "name": "File Paths",
        "func": "const username = os.userInfo().username;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\n// Join DOCUMENTS_PATH with the specific folder structure\nconst filePath1 = path.join(cimaPrompts, 'DebugPrompts', 'Debug1.md');\n\nmsg.inputContext = {};\nmsg.promptSectionContext = {};\nmsg.inputContext.filePath = filePath1;\nmsg.promptSectionContext.status = \"start\";\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1340,
        "y": 620,
        "wires": [
            [
                "eca15312159d4910"
            ]
        ]
    },
    {
        "id": "fa21567ba22fdb93",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "abb6cb8cc176530d",
        "name": "Run Prompt Main",
        "func": "console.log('[Run Prompt Main] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPromptSection = context.runPromptSection || {};\ncontext.runPromptSection.isStopRequested = msg.payload === \"stop\";\nmsg.promptSectionContext.responseCount = msg.promptSectionContext.responseCount || 0;\n\nlet browser, browserContext, currentPage;\n\nasync function connectAndSetupPage() {\n    if (!browser) {\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n    }\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    if (!browserContext) {\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n    }\n    const pages = await browserContext.pages();\n    return pages[pages.length - 1];\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n        if (shouldClick) {\n            await button.click();\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        if (shouldReload) await page.reload({ waitUntil: 'networkidle' });\n    } catch (error) {\n        console.error(`[Run Prompt Main] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    let previousLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    while (Date.now() - startTime < maxWaitTime) {\n        if (context.runPromptSection.isStopRequested) {\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            const page = await getCurrentPage();\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                await page.waitForTimeout(1000); // Wait for scroll animation\n            }\n\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n\n            if (articles.length === 0) {\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n            } catch (error) {\n                responseText = await lastArticle.innerText();\n            }\n\n            const currentLength = responseText.length;\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n\n            if (stableCount >= maxStableCount) {\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    let responseText = '';\n    try {\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        if (articles.length > 0) {\n            const lastArticle = articles[articles.length - 1];\n            const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n            if (copyButton) {\n                await copyButton.click();\n                await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n                responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            } else {\n                const markdownDiv = await lastArticle.$('div.markdown');\n                responseText = markdownDiv ? await markdownDiv.innerText() : '';\n            }\n        }\n    } catch (error) {\n        try {\n            const lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n            const textBaseElement = await lastArticle.$('.text-base');\n            responseText = textBaseElement ? await textBaseElement.innerText() : '';\n        } catch (innerError) {\n            responseText = '';\n        }\n    }\n\n    return responseText;\n}\n\nasync function stopGeneration() {\n    context.runPromptSection.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n}\n\nfunction clearStopRequestedState() {\n    context.runPromptSection.isStopRequested = false;\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close();\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage\n    };\n    const secondOutput = {\n        ...msg,\n        payload: result.payload,\n        status: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPromptSection() {\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        const newChatButton = await page.$('nav > a.flex.py-3.px-3.items-center.gap-3.rounded-md:has-text(\"New chat\")');\n        if (newChatButton) {\n            await newChatButton.click();\n            await page.waitForLoadState('networkidle');\n        }\n\n        await clickButtonIfVisible('button:has-text(\"Continue generating\")', true);\n        const promptText = msg.payload || 'RPMain';\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n        await page.click('button[data-testid=\"send-button\"]');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n        msg.promptSectionContext.responseArray = msg.promptSectionContext.responseArray || [];\n        // Ensure responseText is a string\n        let stringResponseText = String(responseText);\n\n        // Add the new response to the array\n        msg.promptSectionContext.responseArray[msg.promptSectionContext.responseCount] = stringResponseText;\n        console.log('msg.promptSectionContext.responseArray :', msg.promptSectionContext.responseArray);\n        msg.promptSectionContext.responseCount += 1;\n        return responseText;\n    } catch (error) {\n        console.error(`[Run Prompt Main] Error in runPromptSection: ${error.message}`);\n        throw error;\n    }\n}\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPromptSection.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptSectionWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPromptSection();\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt Main] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    return msg.promptSectionContext.currentStep === msg.promptSectionContext.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    };\n}\n\n// Inside the cleanup function:\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close();\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        promptSectionContext: {\n            ...msg.promptSectionContext,\n            status: result.status.text,\n            _continuation: !isLastMessage,\n            _event: isLastMessage ? \"End of Sequence\" : msg.promptSectionContext._event,\n            currentStep: msg.promptSectionContext.currentStep,\n            totalSteps: msg.promptSectionContext.totalSteps,\n            promptConfig: msg.promptSectionContext.promptConfig\n        },\n        sidePromptContext: {\n            ...msg.sidePromptContext,\n            sidePromptCmdDone: null\n        },\n        inputContext: {\n            ...msg.inputContext\n        },\n        dynamicCmdContext: {\n            ...msg.dynamicCmdContext,\n            dynamicCmd: false,\n            dynamicCmdComplete: true,\n            processedResult: result.payload\n        }\n    };\n    const secondOutput = {\n        ...firstOutput,\n        promptSectionContext: {\n            ...firstOutput.promptSectionContext,\n            error: result.error\n        }\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function executeScript(msg) {\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n\n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptSectionWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\nexecuteScript(msg);\nreturn null;",
        "outputs": 2,
        "timeout": "",
        "noerr": 23,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1350,
        "y": 800,
        "wires": [
            [],
            [
                "f0d6f8739b76928b",
                "a593028ef3f4668a"
            ]
        ]
    },
    {
        "id": "71c927bf29b50bd2",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "abb6cb8cc176530d",
        "name": "sectionController",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet promptSections = context.get('promptSections') || [];\nlet currentStep = context.get('currentStep') || 0;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\nconsole.log(\"Initial promptSections.length : \", promptSections.length);\n\nfunction passedPromptSections() {\n    console.log('[sectionController] Starting passedPromptSections function');\n\n    try {\n        console.log('[sectionController] Checking for existing promptSections in context');\n        const existingPromptSections = context.get('promptSections');\n\n        if (!existingPromptSections || existingPromptSections.length === 0) {\n            console.log('[sectionController] No existing promptSections found in context');\n\n            if (!msg.promptSectionContext || !msg.promptSectionContext.promptSectionsArray) {\n                console.error('[sectionController] msg.promptSectionContext.promptSectionsArray is undefined or null');\n                throw new Error('msg.promptSectionContext.promptSectionsArray is undefined or null');\n            }\n\n            console.log(`[sectionController] Setting ${msg.promptSectionContext.promptSectionsArray.length} promptSections in context`);\n            context.set('promptSections', msg.promptSectionContext.promptSectionsArray);\n            promptSections = msg.promptSectionContext.promptSectionsArray;\n            console.log(`[sectionController] Set ${promptSections.length} promptSections in context`);\n            node.status({ fill: \"blue\", shape: \"dot\", text: `Set ${promptSections.length} promptSections` });\n        } else {\n            console.log(`[sectionController] ${existingPromptSections.length} promptSections already exist in context. Not overwriting.`);\n            node.status({ fill: \"yellow\", shape: \"dot\", text: \"promptSections already exist\" });\n            promptSections = existingPromptSections;\n        }\n\n        console.log(`[sectionController] Returning ${promptSections.length} promptSections`);\n        return promptSections;\n    } catch (error) {\n        console.error(`[sectionController] Failed to handle promptSections: ${error.message}`);\n        console.error(`[sectionController] Error stack: ${error.stack}`);\n        node.error(`Failed to handle promptSections: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to handle promptSections\" });\n        return null;\n    }\n}\n\nfunction processNextPrompt() {\n    console.log(`[sectionController] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < promptSections.length) {\n        const newMsg = {\n            ...msg,  // Spread all properties from the original msg\n            promptSectionContext: {\n                ...msg.promptSectionContext,\n                promptSectionsArray: promptSections,\n                currentStep: currentStep,\n                totalSteps: promptSections.length,\n                promptConfig: promptSections[currentStep],\n                status: \"processing\",\n                _continuation: true,\n                _event: \"\",\n            },\n            payload: promptSections[currentStep].body,\n            sidePromptContext: {\n                ...msg.sidePromptContext,\n                sidePromptCmdDone: null\n            },\n            inputContext: {\n                ...msg.inputContext,\n                filePrompt: \"\",\n                filePath: \"\"\n            },\n            dynamicCmdContext: {\n                ...msg.dynamicCmdContext,\n                dynamicCmd: false,\n                dynamicCmdComplete: false,\n                commandsArray: [],\n                currentOutputType: \"mainPrompt\",\n                cmdExecTime: Date.now(),\n                processedResult: null\n            }\n        };\n        console.log(`[sectionController] Sending prompt ${currentStep + 1} of ${promptSections.length}`);\n        node.send(newMsg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${promptSections.length}` });\n    } else {\n        console.log('[sectionController] All promptSections processed. Stopping.');\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[sectionController] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[sectionController] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    promptSections = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('promptSections', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, promptSections Unloaded\" });\n    // Send message to the Playwright function node if not last msg\n    if (msg.promptSectionContext && msg.promptSectionContext._continuation == true) {\n        node.send({\n            ...msg,\n            payload: \"stop\",\n            promptSectionContext: {\n                ...msg.promptSectionContext,\n                status: \"stop\"\n            }\n        });\n    }\n}\n\nif (msg.promptSectionContext && msg.promptSectionContext._continuation) {\n    console.log(`[sectionController] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.promptSectionContext.status === \"done\" || msg.promptSectionContext._event === \"End of Sequence\") {\n            console.log('[sectionController] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            currentStep++;\n            context.set('currentStep', currentStep);\n            processNextPrompt();\n        } else if (msg.promptSectionContext.status === \"error\") {\n            console.log(`[sectionController] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[sectionController] Received new message with payload: ${msg.payload}`);\n    if (msg.promptSectionContext && msg.promptSectionContext.status === \"start\") {\n        // Load promptSections if they haven't been loaded yet\n        if (!promptSections.length) {\n            passedPromptSections();\n            console.log(\"promptSections.length : \", promptSections.length);\n        }\n        startProcessing();\n    } else if (msg.promptSectionContext && msg.promptSectionContext.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.promptSectionContext && msg.promptSectionContext.status === \"reload\") {\n        passedPromptSections();\n    } else if (msg.promptSectionContext && msg.promptSectionContext._event === \"End of Sequence\") {\n        stopProcessing();\n        console.log('[sectionController] All promptSections processed. Stopping.');\n        node.status({ fill: \"green\", shape: \"dot\", text: \"All promptSections processed. Stopping.\" });\n    } else {\n        console.log(`[sectionController] Unrecognized message: ${msg.payload}`);\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 750,
        "y": 800,
        "wires": [
            [
                "a5f31990c3510d5f"
            ]
        ]
    },
    {
        "id": "eca15312159d4910",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "abb6cb8cc176530d",
        "name": "promptLoader",
        "func": "function shouldSkipLoading(msg) {\n    if (msg.inputContext.filePrompt === false) {\n        console.log('[promptLoader] Skipping file prompt loading');\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Skipped file prompt loading\" });\n        return true;\n    }\n    return false;\n}\n\nfunction getFilePath(msg) {\n    if (!msg.inputContext.filePath) {\n        throw new Error('[promptLoader] msg.inputContext.filePath is not defined');\n    }\n    const filePath = msg.inputContext.filePath;\n    console.log('[promptLoader] File path:', filePath);\n    return filePath;\n}\n\nfunction parsePromptSection(section) {\n    const [title, ...bodyLines] = section.split('\\n');\n    let body = bodyLines.join('\\n').trim();\n\n    console.log(`[promptLoader] Parsing prompt section: ${title}`);\n    console.log(`[promptLoader] Body: ${body.substring(0, 100)}...`); // Log first 100 chars to avoid cluttering\n\n    return {\n        title: title.trim(),\n        body: body\n    };\n}\n\nfunction parsePromptsFromContent(content) {\n    const sections = content.split('\\n# ');\n    return sections.slice(1).map(section => parsePromptSection(section));\n}\n\nfunction loadPrompts(msg) {\n    if (shouldSkipLoading(msg)) {\n        return null;\n    }\n\n    try {\n        const filePath = getFilePath(msg);\n        const content = fs.readFileSync(filePath, 'utf8');\n        let prompts = parsePromptsFromContent(content);\n\n        console.log(`[promptLoader] Loaded ${prompts.length} prompts`);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${prompts.length} prompts` });\n\n        return prompts;\n    } catch (error) {\n        console.error(`[promptLoader] Failed to load prompts: ${error.message}`);\n        node.error(`Failed to load prompts: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to load prompts\" });\n        return null;\n    }\n}\n\n// Usage\ntry {\n    const promptSectionsArray = loadPrompts(msg);\n    console.log('[promptLoader] promptSectionsArray length:', promptSectionsArray ? promptSectionsArray.length : 0);\n\n    if (promptSectionsArray) {\n        // Create a new object with all properties of the original message\n        const newMsg = { ...msg };\n        // Update the promptSectionsArray in the promptSectionContext\n        newMsg.promptSectionContext.promptSectionsArray = promptSectionsArray;\n        return newMsg;\n    } else {\n        // If prompts weren't loaded successfully, return the original message\n        return msg;\n    }\n} catch (error) {\n    console.error(`[promptLoader] Unexpected error: ${error.message}`);\n    node.error(`Unexpected error: ${error.message}`);\n    return null;\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 520,
        "y": 800,
        "wires": [
            [
                "71c927bf29b50bd2"
            ]
        ]
    },
    {
        "id": "9ff7d5131f370507",
        "type": "link in",
        "z": "6fd22f15cd2422d0",
        "g": "abb6cb8cc176530d",
        "name": "SC: Out",
        "links": [
            "a593028ef3f4668a"
        ],
        "x": 585,
        "y": 860,
        "wires": [
            [
                "71c927bf29b50bd2"
            ]
        ]
    },
    {
        "id": "a593028ef3f4668a",
        "type": "link out",
        "z": "6fd22f15cd2422d0",
        "g": "abb6cb8cc176530d",
        "name": "SC: In",
        "mode": "link",
        "links": [
            "9ff7d5131f370507"
        ],
        "x": 1445,
        "y": 860,
        "wires": []
    },
    {
        "id": "a5f31990c3510d5f",
        "type": "subflow:dynamicCmdSubflow",
        "z": "6fd22f15cd2422d0",
        "g": "abb6cb8cc176530d",
        "name": "",
        "x": 1050,
        "y": 800,
        "wires": [
            [
                "fa21567ba22fdb93"
            ]
        ]
    },
    {
        "id": "0f16fc5b36d46fd6",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "Run Prompt Main",
        "func": "console.log('[Run Prompt Main] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPrompt = context.runPrompt || {};\ncontext.runPrompt.isStopRequested = msg.payload === \"stop\";\ncontext.runPrompt.responseCount = context.runPrompt.responseCount || 0;\n\nlet browser, browserContext, currentPage;\n\nasync function connectAndSetupPage() {\n    if (!browser) {\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n    }\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    if (!browserContext) {\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n    }\n    const pages = await browserContext.pages();\n    return pages[pages.length - 1];\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n        if (shouldClick) {\n            await button.click();\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        if (shouldReload) await page.reload({ waitUntil: 'networkidle' });\n    } catch (error) {\n        console.error(`[Run Prompt Main] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    let previousLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    while (Date.now() - startTime < maxWaitTime) {\n        if (context.runPrompt.isStopRequested) {\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            const page = await getCurrentPage();\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                await page.waitForTimeout(1000); // Wait for scroll animation\n            }\n\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n\n            if (articles.length === 0) {\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n            } catch (error) {\n                responseText = await lastArticle.innerText();\n            }\n\n            const currentLength = responseText.length;\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n\n            if (stableCount >= maxStableCount) {\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    let responseText = '';\n    try {\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        if (articles.length > 0) {\n            const lastArticle = articles[articles.length - 1];\n            const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n            if (copyButton) {\n                await copyButton.click();\n                await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n                responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            } else {\n                const markdownDiv = await lastArticle.$('div.markdown');\n                responseText = markdownDiv ? await markdownDiv.innerText() : '';\n            }\n        }\n    } catch (error) {\n        try {\n            const lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n            const textBaseElement = await lastArticle.$('.text-base');\n            responseText = textBaseElement ? await textBaseElement.innerText() : '';\n        } catch (innerError) {\n            responseText = '';\n        }\n    }\n\n    return responseText;\n}\n\nasync function stopGeneration() {\n    context.runPrompt.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n}\n\nfunction clearStopRequestedState() {\n    context.runPrompt.isStopRequested = false;\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close();\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage\n    };\n    const secondOutput = {\n        ...msg,\n        payload: result.payload,\n        status: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPrompt() {\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        const newChatButton = await page.$('nav > a.flex.py-3.px-3.items-center.gap-3.rounded-md:has-text(\"New chat\")');\n        if (newChatButton) {\n            await newChatButton.click();\n            await page.waitForLoadState('networkidle');\n        }\n\n        await clickButtonIfVisible('button:has-text(\"Continue generating\")', true);\n        const promptText = msg.payload || 'RPMain';\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n        await page.click('button[data-testid=\"send-button\"]');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n    \n        msg[`response${context.runPrompt.responseCount}`] = responseText;\n        context.runPrompt.responseCount += 1;\n        return responseText;\n    } catch (error) {\n        console.error(`[Run Prompt Main] Error in runPrompt: ${error.message}`);\n        throw error;\n    }\n}\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPrompt.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPrompt();\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt Main] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    return msg.currentStep === msg.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    };\n}\n\nfunction handleError(error) {\n    return {\n        payload: 'Error occurred: ' + error.message,\n        status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n        error: error.message\n    };\n}\n\nasync function executeScript(msg) {\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n\n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\nexecuteScript(msg);\nreturn null;\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 20,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1350,
        "y": 1340,
        "wires": [
            [],
            [
                "191dd36382069a70"
            ]
        ]
    },
    {
        "id": "0c1dbed619779ab1",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "sectionController",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet prompts = context.get('prompts') || [];\nlet currentStep = context.get('currentStep') || 0;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\nconsole.log(\"Initial prompts.length : \", prompts.length);\n\nfunction passedPrompts() {\n    console.log('[sectionController] Starting passedPrompts function');\n\n    try {\n        console.log('[sectionController] Checking for existing prompts in context');\n        const existingPrompts = context.get('prompts');\n\n        // Check if there's no existing 'prompts' in the context\n        if (!existingPrompts || existingPrompts.length === 0) {\n            console.log('[sectionController] No existing prompts found in context');\n\n            if (!msg.promptsArray) {\n                console.error('[sectionController] msg.promptsArray is undefined or null');\n                throw new Error('msg.promptsArray is undefined or null');\n            }\n\n            console.log(`[sectionController] Setting ${msg.promptsArray.length} prompts in context`);\n            // If no existing prompts, set the passed array in the context\n            context.set('prompts', msg.promptsArray);\n            prompts = msg.promptsArray;\n            console.log(`[sectionController] Set ${prompts.length} prompts in context`);\n            node.status({ fill: \"blue\", shape: \"dot\", text: `Set ${prompts.length} prompts` });\n        } else {\n            console.log(`[sectionController] ${existingPrompts.length} prompts already exist in context. Not overwriting.`);\n            node.status({ fill: \"yellow\", shape: \"dot\", text: \"Prompts already exist\" });\n            prompts = existingPrompts;\n        }\n\n        console.log(`[sectionController] Returning ${prompts.length} prompts`);\n        return prompts;\n    } catch (error) {\n        console.error(`[sectionController] Failed to handle prompts: ${error.message}`);\n        console.error(`[sectionController] Error stack: ${error.stack}`);\n        node.error(`Failed to handle prompts: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to handle prompts\" });\n        return null;\n    }\n}\n\nfunction processNextPrompt() {\n    console.log(`[sectionController] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < prompts.length) {\n        const newMsg = {\n            ...msg,  // Spread all properties from the original msg\n            currentStep: currentStep,\n            totalSteps: prompts.length,\n            promptConfig: prompts[currentStep],\n            payload: prompts[currentStep].body,\n            _continuation: true\n        };\n        console.log(`[sectionController] Sending prompt ${currentStep + 1} of ${prompts.length}`);\n        node.send(newMsg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${prompts.length}` });\n    } else {\n        console.log('[sectionController] All prompts processed. Stopping.');\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[sectionController] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[sectionController] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    prompts = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('prompts', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, Prompts Unloaded\" });\n    // Send message to the Playwright function node if not last msg\n    if (msg._continuation == true) {\n        node.send({ ...msg, payload: \"stop\" , status: \"stop\"});  // Include all original msg properties\n    }\n}\n\nif (msg._continuation) {\n    console.log(`[sectionController] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.status === \"done\" || msg.status === \"End of Sequence\") {\n            console.log('[sectionController] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            currentStep++;\n            context.set('currentStep', currentStep);\n            processNextPrompt();\n        } else if (msg.status === \"error\") {\n            console.log(`[sectionController] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[sectionController] Received new message with payload: ${msg.payload}`);\n    if (msg.status === \"start\") {\n        // Load prompts if they haven't been loaded yet\n        if (!prompts.length) {\n            passedPrompts();\n            console.log(\"prompts.length : \", prompts.length);\n        }\n        startProcessing();\n    } else if (msg.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.status === \"reload\") {\n        passedPrompts();\n    } else if (msg.status === \"Sequence Complete\") {\n        stopProcessing();\n        console.log('[sectionController] All prompts processed. Stopping.'); \n        node.status({ fill: \"green\", shape: \"dot\", text: \"All prompts processed. Stopping.\" });\n    } else {\n        console.log(`[sectionController] Unrecognized message: ${msg.payload}`);\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 750,
        "y": 1340,
        "wires": [
            [
                "96d8b069f61a302a"
            ]
        ]
    },
    {
        "id": "59ed5a547f573b39",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "promptLoader",
        "func": "function shouldSkipLoading(msg) {\n    if (msg.filePrompt === false) {\n        console.log('[promptLoader] Skipping file prompt loading');\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Skipped file prompt loading\" });\n        return true;\n    }\n    return false;\n}\n\nfunction getFilePath(msg) {\n    if (!msg.filePath) {\n        throw new Error('[promptLoader] msg.filePath is not defined');\n    }\n    const filePath = msg.filePath;\n    console.log('[promptLoader] File path:', filePath);\n    return filePath;\n}\n\nfunction parsePromptSection(section) {\n    const [title, ...bodyLines] = section.split('\\n');\n    let body = bodyLines.join('\\n').trim();\n\n    console.log(`[promptLoader] Parsing prompt section: ${title}`);\n    console.log(`[promptLoader] Body: ${body.substring(0, 100)}...`); // Log first 100 chars to avoid cluttering\n\n    return {\n        title: title.trim(),\n        body: body\n    };\n}\n\nfunction parsePromptsFromContent(content) {\n    const sections = content.split('\\n# ');\n    return sections.slice(1).map(section => parsePromptSection(section));\n}\n\nfunction loadPrompts(msg) {\n    if (shouldSkipLoading(msg)) {\n        return null;\n    }\n\n    try {\n        const filePath = getFilePath(msg);\n        const content = fs.readFileSync(filePath, 'utf8');\n        let prompts = parsePromptsFromContent(content);\n\n        console.log(`[promptLoader] Loaded ${prompts.length} prompts`);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${prompts.length} prompts` });\n\n        return prompts;\n    } catch (error) {\n        console.error(`[promptLoader] Failed to load prompts: ${error.message}`);\n        node.error(`Failed to load prompts: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to load prompts\" });\n        return null;\n    }\n}\n\n// Usage\ntry {\n    const promptsArray = loadPrompts(msg);\n    console.log('[promptLoader] promptsArray length:', promptsArray ? promptsArray.length : 0);\n\n    if (promptsArray) {\n        // Create a new object with all properties of the original message\n        const newMsg = { ...msg };\n        // Add the promptsArray to the new message object\n        newMsg.promptsArray = promptsArray;\n        return newMsg;\n    } else {\n        // If prompts weren't loaded successfully, return the original message\n        return msg;\n    }\n} catch (error) {\n    console.error(`[promptLoader] Unexpected error: ${error.message}`);\n    node.error(`Unexpected error: ${error.message}`);\n    return null;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 520,
        "y": 1340,
        "wires": [
            [
                "0c1dbed619779ab1"
            ]
        ]
    },
    {
        "id": "3f22537a06d38167",
        "type": "link in",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "SC: Out",
        "links": [
            "191dd36382069a70"
        ],
        "x": 585,
        "y": 1400,
        "wires": [
            [
                "0c1dbed619779ab1"
            ]
        ]
    },
    {
        "id": "191dd36382069a70",
        "type": "link out",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "SC: In",
        "mode": "link",
        "links": [
            "3f22537a06d38167"
        ],
        "x": 1445,
        "y": 1400,
        "wires": []
    },
    {
        "id": "96d8b069f61a302a",
        "type": "subflow:dynamicCmdSubflow",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "",
        "x": 1080,
        "y": 1340,
        "wires": [
            [
                "0f16fc5b36d46fd6"
            ]
        ]
    },
    {
        "id": "9d05e7471fb032a1",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "Sequence Controller Side",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet prompts = context.get('prompts') || [];\nlet currentStep = context.get('currentStep') || 0;\n\nfunction processPrompts(inputPrompts) {\n    console.log('[Sequence Controller Side] Processing input prompts');\n\n    if (!Array.isArray(inputPrompts)) {\n        console.error('[Sequence Controller Side] Error: Input is not an array');\n        return [];\n    }\n\n    const processedPrompts = inputPrompts.map((prompt, index) => ({\n        title: `Prompt ${index + 1}`,\n        body: prompt,\n        sidePrompt: []\n    }));\n\n    context.set('prompts', processedPrompts);\n    console.log(`[Sequence Controller Side] Processed ${processedPrompts.length} prompts`);\n    node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${processedPrompts.length} prompts` });\n\n    return processedPrompts;\n}\n\nfunction processNextPrompt() {\n    console.log(`[Sequence Controller Side] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < prompts.length) {\n        const msg = {\n            currentStep: currentStep,\n            totalSteps: prompts.length,\n            promptConfig: prompts[currentStep],\n            payload: prompts[currentStep].body,\n            sidePrompt: prompts[currentStep].sidePrompt,\n            _continuation: true\n        };\n        console.log(`[Sequence Controller Side] Sending prompt ${currentStep + 1} of ${prompts.length}`);\n        node.send(msg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${prompts.length}` });\n        currentStep++;\n        context.set('currentStep', currentStep);\n    } else {\n        console.log('[Sequence Controller Side] All prompts processed. Stopping.');\n        node.send([null, { payload: \"Sequence Complete\", status: \"sidePromptCmdDone\" }]);\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[Sequence Controller Side] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[Sequence Controller Side] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    prompts = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('prompts', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, Prompts Unloaded\" });\n}\n\n// Main logic\nif (msg._continuation) {\n    console.log(`[Sequence Controller Side] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.status === \"done\" || msg.status === \"End of Sequence\") {\n            console.log('[Sequence Controller Side] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            processNextPrompt();\n        } else if (msg.status === \"error\") {\n            console.log(`[Sequence Controller Side] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[Sequence Controller Side] Received new message with payload: ${JSON.stringify(msg.payload)}`);\n    if (msg.status === \"start\") {\n        if (Array.isArray(msg.payload)) {\n            prompts = processPrompts(msg.payload);\n            startProcessing();\n        } else {\n            console.log('[Sequence Controller Side] Invalid input: payload is not an array of prompts');\n            node.status({ fill: \"red\", shape: \"ring\", text: \"Invalid input\" });\n        }\n    } else if (msg.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.status === \"Sequence Complete\") {\n        node.send([null, { ...msg, status: \"sidePromptCmdDone\" }]);\n        stopProcessing();\n    } else {\n        console.log(`[Sequence Controller Side] Unrecognized message: ${JSON.stringify(msg)}`);\n    }\n}\n\nreturn null;",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1070,
        "y": 1440,
        "wires": [
            [
                "7a0a725cdb252858"
            ],
            []
        ]
    },
    {
        "id": "7a0a725cdb252858",
        "type": "function",
        "z": "6fd22f15cd2422d0",
        "g": "1e5068284c73d985",
        "name": "Run Prompt Side",
        "func": "console.log('[Run Prompt Side] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPrompt = context.runPrompt || {};\ncontext.runPrompt.isStopRequested = msg.payload === \"stop\";\n\nconsole.log('context.runPrompt:', context.runPrompt);\n\nlet browser, browserContext, currentPage;\nconsole.log('[Run Prompt Side] Initial state:', { browser, browserContext, currentPage });\n\nasync function connectAndSetupPage() {\n    console.log('[Run Prompt Side] Entering connectAndSetupPage');\n    if (!browser) {\n        console.log('[Run Prompt Side] Browser not initialized, connecting...');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        console.log('[Run Prompt Side] Browser connected');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt Side] Browser context obtained');\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n        console.log('[Run Prompt Side] Current page set');\n    }\n    //    console.log('[Run Prompt Side] Exiting connectAndSetupPage:', { browser, browserContext, currentPage });\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    console.log('[Run Prompt Side] Entering getCurrentPage');\n    if (!browserContext) {\n        console.log('[Run Prompt Side] Browser context not found, creating new one');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt Side] New browser context created');\n    }\n    const pages = await browserContext.pages();\n    console.log('[Run Prompt Side] Number of pages:', pages.length);\n    const currentPage = pages[pages.length - 1];\n    //console.log('[Run Prompt Side] Exiting getCurrentPage, current page:', currentPage);\n    return currentPage;\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n\n        if (shouldClick) {\n            await button.click();\n\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    console.log('[Run Prompt Side] Entering reloadPageIfNecessary:', { retryCount });\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        console.log('[Run Prompt Side] Should reload:', shouldReload);\n        shouldReload && await page.reload({ waitUntil: 'networkidle' });\n        console.log('[Run Prompt Side] Page reloaded:', shouldReload);\n    } catch (error) {\n        console.log(`[Run Prompt Side] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    console.log('[Run Prompt Side] Entering waitForResponseCompletion');\n    console.log('[Run Prompt Side] Initializing variables');\n\n    let previousLength = 0, currentLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    console.log(`[Run Prompt Side] Max stable count: ${maxStableCount}, Max wait time: ${maxWaitTime}ms`);\n\n    while (Date.now() - startTime < maxWaitTime) {\n        console.log(`[Run Prompt Side] Elapsed time: ${Date.now() - startTime}ms`);\n\n        if (context.runPrompt.isStopRequested) {\n            console.log('[Run Prompt Side] Stop requested. Halting response completion.');\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            console.log('[Run Prompt Side] Attempting to get current page');\n            const page = await getCurrentPage();\n            console.log('[Run Prompt Side] Successfully got current page');\n\n            // Check for scroll-to-bottom button and click if visible\n            console.log('[Run Prompt Side] Checking for scroll-to-bottom button');\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                console.log('[Run Prompt Side] Scroll-to-bottom button clicked, waiting for scroll animation');\n                await page.waitForTimeout(1000); // Wait for scroll animation\n                console.log('[Run Prompt Side] Scroll animation wait complete');\n            } else {\n                console.log('[Run Prompt Side] Scroll-to-bottom button not found or not clicked');\n            }\n\n            console.log('[Run Prompt Side] Waiting for article selector');\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            console.log('[Run Prompt Side] Article selector found');\n\n            console.log('[Run Prompt Side] Querying for articles');\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n            console.log(`[Run Prompt Side] Found ${articles.length} articles`);\n\n            if (articles.length === 0) {\n                console.log('[Run Prompt Side] No articles found, waiting...');\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt Side] Attempting to extract content from last article');\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n                console.log('[Run Prompt Side] Content extracted successfully');\n            } catch (error) {\n                console.log('[Run Prompt Side] Error extracting content:', error.message);\n                console.log('[Run Prompt Side] Falling back to article.innerText()');\n                responseText = await lastArticle.innerText();\n                console.log('[Run Prompt Side] Fallback content extraction complete');\n            }\n\n            currentLength = responseText.length;\n            console.log(`[Run Prompt Side] Current response length: ${currentLength}`);\n            if (currentLength == 0) {\n                console.log('[Run Prompt Side] No content found in the response');\n            }\n\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n            console.log(`[Run Prompt Side] Is response stable: ${isStable}, Stable count: ${stableCount}`);\n\n            if (stableCount >= maxStableCount) {\n                console.log('[Run Prompt Side] Response appears to be complete');\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            console.log('[Run Prompt Side] Waiting for 2 seconds before next iteration');\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            console.log(`[Run Prompt Side] Error in waitForResponseCompletion: ${error.message}`);\n            console.log('[Run Prompt Side] Error stack:', error.stack);\n            console.log('[Run Prompt Side] Waiting for 3 seconds before retrying');\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    console.log('[Run Prompt Side] Max wait time exceeded. Returning current response.');\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    console.log('[Run Prompt Side] Entering extractResponseText');\n    let responseText = '';\n    let lastArticle;\n\n    try {\n        // Find all articles within the h-full div\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        console.log(`[Run Prompt Side] Found ${articles.length} articles`);\n\n        if (articles.length > 0) {\n            // Get the last article\n            lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt Side] Selected the last article');\n        } else {\n            throw new Error('No articles found');\n        }\n\n        // Find and click the copy button\n        const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n        if (copyButton) {\n            await copyButton.click();\n            await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n\n            // Get clipboard contents\n            responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            console.log('[Run Prompt Side] Response extracted from clipboard');\n        } else {\n            console.log('[Run Prompt Side] Copy button not found, falling back to original method');\n            const markdownDiv = await lastArticle.$('div.markdown');\n            if (markdownDiv) {\n                responseText = await markdownDiv.innerText();\n            } else {\n                throw new Error('Markdown div not found');\n            }\n        }\n    } catch (error) {\n        console.log('[Run Prompt Side] Error extracting content:', error.message);\n        try {\n            if (!lastArticle) {\n                lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n                if (!lastArticle) {\n                    throw new Error('Unable to find last article');\n                }\n            }\n            const textBaseElement = await lastArticle.$('.text-base');\n            if (textBaseElement) {\n                responseText = await textBaseElement.innerText();\n                console.log('[Run Prompt Side] Response extracted using alternative selector');\n            } else {\n                throw new Error('Alternative selector not found');\n            }\n        } catch (innerError) {\n            console.log('[Run Prompt Side] Alternative selector also failed, using entire article content');\n            if (lastArticle) {\n                responseText = await lastArticle.innerText();\n            } else {\n                console.log('[Run Prompt Side] Failed to extract any content');\n                responseText = '';\n            }\n        }\n    }\n\n    console.log('[Run Prompt Side] Exiting extractResponseText, response length:', responseText.length);\n    return responseText;\n}\n\nasync function stopGeneration() {\n    console.log('[Run Prompt Side] Entering stopGeneration');\n    context.runPrompt.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n    console.log('[Run Prompt Side] Exiting stopGeneration');\n}\n\nfunction clearStopRequestedState() {\n    context.runPrompt.isStopRequested = false;\n    console.log('[Run Prompt Side] Stop requested state cleared.');\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close().then(() => console.log('[Run Prompt Side] Browser closed'));\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage  // Set _continuation to true for the last message\n    };\n\n    const secondOutput = {\n        ...msg,\n        payload: result.payload,\n        status: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage === true\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPrompt() {\n    console.log('[Run Prompt Side] Entering runPrompt');\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        console.log('[Run Prompt Side] Got current page in runPrompt');\n\n        // ... (existing code for new chat button)\n        console.log('[Run Prompt Side] Full Msg:', msg);\n        const promptText = msg.payload || 'Sidefiring';\n        console.log('[Run Prompt Side] Entering prompt:', promptText);\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n\n        // Handle sidePrompt if present\n        if (msg.sidePrompt && msg.sidePrompt.length > 0) {\n            console.log('[Run Prompt Side] Handling sidePrompt');\n            const sidePromptText = msg.sidePrompt.join('\\n');\n            await page.evaluate((text) => {\n                const textarea = document.querySelector('#prompt-textarea');\n                textarea.value += '\\n\\n' + text;\n                textarea.dispatchEvent(new Event('input', { bubbles: true }));\n            }, sidePromptText);\n        }\n\n        await page.click('button[data-testid=\"send-button\"]');\n        console.log('[Run Prompt Side] Sent prompt');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n        console.log('[Run Prompt Side] Exiting runPrompt');\n        return responseText;\n    } catch (error) {\n        console.log(`[Run Prompt Side] Error in runPrompt: ${error.message}`);\n        console.log('[Run Prompt Side] Error stack:', error.stack);\n        throw error;\n    }\n}\n\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPrompt.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPrompt();\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt Side] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    console.log('This is the last step');\n    return msg.currentStep === msg.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    }; \n}\n\nfunction handleError(error) {\n    return {\n        payload: 'Error occurred: ' + error.message,\n        status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n        error: error.message\n    };\n}\n\nasync function executeScript(msg) {\n    console.log('[Run Prompt Side] Entering executeScript');\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n        \n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n            console.log('last step result: ', result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\n\n\nexecuteScript(msg);\n\nreturn null;\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 23,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1070,
        "y": 1520,
        "wires": [
            [],
            [
                "9d05e7471fb032a1"
            ],
            []
        ]
    },
    {
        "id": "1638a67c56865971",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "g": "6894234cd3cf5d07",
        "name": "Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 570,
        "y": 580,
        "wires": [
            [
                "8b89f329a82bfed6"
            ]
        ]
    },
    {
        "id": "8b89f329a82bfed6",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "6894234cd3cf5d07",
        "name": "Load Instructions",
        "func": "// Initialize instructions and index only once\nif (!context.get(\"instructions\")) {\n    context.set(\"instructions\", [\n        \"Reply with '1'.\",\n        \"Take the number in the following text and add with 2:\",\n        \"Take the number in the following text and add with 3:\"\n    ]);\n    context.set(\"index\", 0);\n}\n\n// Retrieve the current index and instructions\nlet instructions = context.get(\"instructions\");\nlet index = context.get(\"index\");\n\n// Check if the index has maxed out\nif (index >= instructions.length) {\n    // All instructions have been processed, stop the flow\n    return null;\n}\n\n// Set the current instruction as the next instruction\nmsg.nextInstruction = instructions[index];\n\n// Check if this is the first instruction\nif (index === 0) {\n    // Initialize payload with an empty string or a specific starting message\n    msg.payload = \"\";\n} else {\n    // For subsequent instructions, retain the current payload\n    msg.payload = msg.payload.message.content;\n}\n\n// Update the index for the next invocation\ncontext.set(\"index\", index + 1);\n\n// Check if this is the last instruction\nif (index + 1 >= instructions.length) {\n    // Return the message to output 2 for the final instruction\n    return [null, msg];\n}\n\n// Return the message to proceed to the next node (output 1)\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 720,
        "wires": [
            [
                "77f2f541c83fdbc3"
            ],
            [
                "4a2c4610f96ec367"
            ]
        ]
    },
    {
        "id": "77f2f541c83fdbc3",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "6894234cd3cf5d07",
        "name": "Process Instruction",
        "func": "// Combine the last output with the next instruction\nlet lastOutput = msg.payload || \"\";\nlet nextInstruction = msg.nextInstruction;\n\nconst parameters = \"Execute the following instruction exactly, only reply concisely with the answer, do not provide any other text.\"\n\n// Combine the output with the instruction\nlet modifiedMessage = \"Parameters: \" + parameters + \"\\n\\n\" + \"Instruction: \"  +  nextInstruction;\n\nif (lastOutput !== \"\") {\n    modifiedMessage = modifiedMessage + \"\\n\\n\" + \"Text: \" + lastOutput;\n}\n\n// Construct the payload for the Ollama Chat node\nmsg.payload = {\n    host: \"http://localhost:11434\",\n    model: \"llama3.1:8b\",\n    messages: [\n        { role: \"user\", content: modifiedMessage }\n    ]\n};\n\n// Pass the message on to the next node (Ollama Chat node)\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 640,
        "wires": [
            [
                "a7d8108a4e153280",
                "837ca3dddd6d3f88"
            ]
        ]
    },
    {
        "id": "a7d8108a4e153280",
        "type": "ollama-chat",
        "z": "b326d8d077e77e7a",
        "g": "6894234cd3cf5d07",
        "name": "Ollama Chat",
        "x": 1050,
        "y": 640,
        "wires": [
            [
                "8b89f329a82bfed6",
                "c4c16bdf71735fe1"
            ]
        ]
    },
    {
        "id": "c4c16bdf71735fe1",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "6894234cd3cf5d07",
        "name": "Staged Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 580,
        "wires": []
    },
    {
        "id": "4a2c4610f96ec367",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "6894234cd3cf5d07",
        "name": "Final Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 720,
        "wires": []
    },
    {
        "id": "837ca3dddd6d3f88",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "6894234cd3cf5d07",
        "name": "Prompts",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 720,
        "wires": []
    },
    {
        "id": "f7833adb07fe5494",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "g": "c803e0682d074b98",
        "name": "Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 1290,
        "y": 580,
        "wires": [
            [
                "58e089ec8917c51c"
            ]
        ]
    },
    {
        "id": "58e089ec8917c51c",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "c803e0682d074b98",
        "name": "Load Instructions",
        "func": "// Initialize instructions and index only once\nif (!context.get(\"instructions\")) {\n    context.set(\"instructions\", [\n        \"Reply with '1'.\",\n        \"Take the number in the following text and add with 2:\",\n        \"Take the number in the following text and add with 3:\"\n    ]);\n    context.set(\"index\", 0);\n}\n\n// Retrieve the current index and instructions\nlet instructions = context.get(\"instructions\");\nlet index = context.get(\"index\");\n\n// Check if the index has maxed out\nif (index >= instructions.length) {\n    // All instructions have been processed, stop the flow\n    return null;\n}\n\n// Set the current instruction as the next instruction\nmsg.nextInstruction = instructions[index];\n\n// Check if this is the first instruction\nif (index === 0) {\n    // Initialize payload with an empty string or a specific starting message\n    msg.payload = \"\";\n} else {\n    // For subsequent instructions, retain the current payload\n    msg.payload = msg.payload.message.content;\n}\n\n// Update the index for the next invocation\ncontext.set(\"index\", index + 1);\n\n// Check if this is the last instruction\nif (index + 1 >= instructions.length) {\n    // Return the message to output 2 for the final instruction\n    return [null, msg];\n}\n\n// Return the message to proceed to the next node (output 1)\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1330,
        "y": 720,
        "wires": [
            [
                "96d76c6fe0e4d003"
            ],
            [
                "5e1437b93e12f451"
            ]
        ]
    },
    {
        "id": "96d76c6fe0e4d003",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "c803e0682d074b98",
        "name": "Process Instruction",
        "func": "// Combine the last output with the next instruction\nlet lastOutput = msg.payload || \"\";\nlet nextInstruction = msg.nextInstruction;\n\nconst parameters = \"Execute the following instruction exactly, only reply concisely with the answer, do not provide any other text.\"\n\n// Combine the output with the instruction\nlet modifiedMessage = \"Parameters: \" + parameters + \"\\n\\n\" + \"Instruction: \"  +  nextInstruction;\n\nif (lastOutput !== \"\") {\n    modifiedMessage = modifiedMessage + \"\\n\\n\" + \"Text: \" + lastOutput;\n}\n\n// Construct the payload for the Ollama Chat node\nmsg.payload = {\n    host: \"http://localhost:11434\",\n    model: \"llama3.1:8b\",\n    messages: [\n        { role: \"user\", content: modifiedMessage }\n    ]\n};\n\n// Pass the message on to the next node (Ollama Chat node)\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 640,
        "wires": [
            [
                "c097527e1ff7411a",
                "724c55b43495a9e4"
            ]
        ]
    },
    {
        "id": "c097527e1ff7411a",
        "type": "ollama-chat",
        "z": "b326d8d077e77e7a",
        "g": "c803e0682d074b98",
        "name": "Ollama Chat",
        "x": 1770,
        "y": 640,
        "wires": [
            [
                "58e089ec8917c51c",
                "ef5902f3dabd7fff"
            ]
        ]
    },
    {
        "id": "ef5902f3dabd7fff",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "c803e0682d074b98",
        "name": "Staged Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1760,
        "y": 580,
        "wires": []
    },
    {
        "id": "5e1437b93e12f451",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "c803e0682d074b98",
        "name": "Final Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1550,
        "y": 720,
        "wires": []
    },
    {
        "id": "724c55b43495a9e4",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "c803e0682d074b98",
        "name": "Prompts",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1760,
        "y": 720,
        "wires": []
    },
    {
        "id": "dc807127b4407f93",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "g": "99c77abbc117cf9f",
        "name": "Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 1290,
        "y": 820,
        "wires": [
            [
                "5099ba28e81c2373"
            ]
        ]
    },
    {
        "id": "5099ba28e81c2373",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "99c77abbc117cf9f",
        "name": "Load Instructions",
        "func": "// Initialize instructions and index only once\nif (!context.get(\"instructions\")) {\n    context.set(\"instructions\", [\n        \"Reply with '1'.\",\n        \"Take the number in the following text and add with 2:\",\n        \"Take the number in the following text and add with 3:\"\n    ]);\n    context.set(\"index\", 0);\n}\n\n// Retrieve the current index and instructions\nlet instructions = context.get(\"instructions\");\nlet index = context.get(\"index\");\n\n// Check if the index has maxed out\nif (index >= instructions.length) {\n    // All instructions have been processed, stop the flow\n    return null;\n}\n\n// Set the current instruction as the next instruction\nmsg.nextInstruction = instructions[index];\n\n// Check if this is the first instruction\nif (index === 0) {\n    // Initialize payload with an empty string or a specific starting message\n    msg.payload = \"\";\n} else {\n    // For subsequent instructions, retain the current payload\n    msg.payload = msg.payload.message.content;\n}\n\n// Update the index for the next invocation\ncontext.set(\"index\", index + 1);\n\n// Check if this is the last instruction\nif (index + 1 >= instructions.length) {\n    // Return the message to output 2 for the final instruction\n    return [null, msg];\n}\n\n// Return the message to proceed to the next node (output 1)\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1330,
        "y": 960,
        "wires": [
            [
                "ad20311fd2c73a10"
            ],
            [
                "7c015af7f9489466"
            ]
        ]
    },
    {
        "id": "ad20311fd2c73a10",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "99c77abbc117cf9f",
        "name": "Process Instruction",
        "func": "// Combine the last output with the next instruction\nlet lastOutput = msg.payload || \"\";\nlet nextInstruction = msg.nextInstruction;\n\nconst parameters = \"Execute the following instruction exactly, only reply concisely with the answer, do not provide any other text.\"\n\n// Combine the output with the instruction\nlet modifiedMessage = \"Parameters: \" + parameters + \"\\n\\n\" + \"Instruction: \"  +  nextInstruction;\n\nif (lastOutput !== \"\") {\n    modifiedMessage = modifiedMessage + \"\\n\\n\" + \"Text: \" + lastOutput;\n}\n\n// Construct the payload for the Ollama Chat node\nmsg.payload = {\n    host: \"http://localhost:11434\",\n    model: \"llama3.1:8b\",\n    messages: [\n        { role: \"user\", content: modifiedMessage }\n    ]\n};\n\n// Pass the message on to the next node (Ollama Chat node)\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1570,
        "y": 880,
        "wires": [
            [
                "99c5558fb42f69fc",
                "995ad83b99377710"
            ]
        ]
    },
    {
        "id": "99c5558fb42f69fc",
        "type": "ollama-chat",
        "z": "b326d8d077e77e7a",
        "g": "99c77abbc117cf9f",
        "name": "Ollama Chat",
        "x": 1770,
        "y": 880,
        "wires": [
            [
                "5099ba28e81c2373",
                "83e01b980d591a8c"
            ]
        ]
    },
    {
        "id": "83e01b980d591a8c",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "99c77abbc117cf9f",
        "name": "Staged Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1760,
        "y": 820,
        "wires": []
    },
    {
        "id": "7c015af7f9489466",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "99c77abbc117cf9f",
        "name": "Final Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1550,
        "y": 960,
        "wires": []
    },
    {
        "id": "995ad83b99377710",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "99c77abbc117cf9f",
        "name": "Prompts",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1760,
        "y": 960,
        "wires": []
    },
    {
        "id": "0713676a3c782313",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "g": "4797c7b0a9eb125d",
        "name": "Start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 570,
        "y": 820,
        "wires": [
            [
                "c4e873678cb4c841"
            ]
        ]
    },
    {
        "id": "c4e873678cb4c841",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "4797c7b0a9eb125d",
        "name": "Load Instructions",
        "func": "// Initialize instructions and index only once\nif (!context.get(\"instructions\")) {\n    context.set(\"instructions\", [\n        \"Reply with '1'.\",\n        \"Take the number in the following text and add with 2:\",\n        \"Take the number in the following text and add with 3:\"\n    ]);\n    context.set(\"index\", 0);\n}\n\n// Retrieve the current index and instructions\nlet instructions = context.get(\"instructions\");\nlet index = context.get(\"index\");\n\n// Check if the index has maxed out\nif (index >= instructions.length) {\n    // All instructions have been processed, stop the flow\n    return null;\n}\n\n// Set the current instruction as the next instruction\nmsg.nextInstruction = instructions[index];\n\n// Check if this is the first instruction\nif (index === 0) {\n    // Initialize payload with an empty string or a specific starting message\n    msg.payload = \"\";\n} else {\n    // For subsequent instructions, retain the current payload\n    msg.payload = msg.payload.message.content;\n}\n\n// Update the index for the next invocation\ncontext.set(\"index\", index + 1);\n\n// Check if this is the last instruction\nif (index + 1 >= instructions.length) {\n    // Return the message to output 2 for the final instruction\n    return [null, msg];\n}\n\n// Return the message to proceed to the next node (output 1)\nreturn [msg, null];",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 610,
        "y": 960,
        "wires": [
            [
                "57a2da1d197a98db"
            ],
            [
                "f322d3b239caa967"
            ]
        ]
    },
    {
        "id": "57a2da1d197a98db",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "g": "4797c7b0a9eb125d",
        "name": "Process Instruction",
        "func": "// Combine the last output with the next instruction\nlet lastOutput = msg.payload || \"\";\nlet nextInstruction = msg.nextInstruction;\n\nconst parameters = \"Execute the following instruction exactly, only reply concisely with the answer, do not provide any other text.\"\n\n// Combine the output with the instruction\nlet modifiedMessage = \"Parameters: \" + parameters + \"\\n\\n\" + \"Instruction: \"  +  nextInstruction;\n\nif (lastOutput !== \"\") {\n    modifiedMessage = modifiedMessage + \"\\n\\n\" + \"Text: \" + lastOutput;\n}\n\n// Construct the payload for the Ollama Chat node\nmsg.payload = {\n    host: \"http://localhost:11434\",\n    model: \"llama3.1:8b\",\n    messages: [\n        { role: \"user\", content: modifiedMessage }\n    ]\n};\n\n// Pass the message on to the next node (Ollama Chat node)\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 850,
        "y": 880,
        "wires": [
            [
                "ac30414c6655dd06",
                "107a09284f0dc8c6"
            ]
        ]
    },
    {
        "id": "ac30414c6655dd06",
        "type": "ollama-chat",
        "z": "b326d8d077e77e7a",
        "g": "4797c7b0a9eb125d",
        "name": "Ollama Chat",
        "x": 1050,
        "y": 880,
        "wires": [
            [
                "c4e873678cb4c841",
                "d8a4a809a1dcaad1"
            ]
        ]
    },
    {
        "id": "d8a4a809a1dcaad1",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "4797c7b0a9eb125d",
        "name": "Staged Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 820,
        "wires": []
    },
    {
        "id": "f322d3b239caa967",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "4797c7b0a9eb125d",
        "name": "Final Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 830,
        "y": 960,
        "wires": []
    },
    {
        "id": "107a09284f0dc8c6",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "g": "4797c7b0a9eb125d",
        "name": "Prompts",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1040,
        "y": 960,
        "wires": []
    },
    {
        "id": "2ee6e52b32bbb793",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "name": "Trigger",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 870,
        "y": 420,
        "wires": [
            [
                "b8a5f92a7e4e2034"
            ]
        ]
    },
    {
        "id": "b8a5f92a7e4e2034",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "name": "Format Request",
        "func": "msg.headers = {\n    \"Content-Type\": \"application/json\"\n};\nmsg.payload = {\n  \"model\": \"llama3\",\n  \"prompt\": \"Why is the sky blue?\",\n  \"stream\": false\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 420,
        "wires": [
            [
                "df9fd86929d9774b"
            ]
        ]
    },
    {
        "id": "df9fd86929d9774b",
        "type": "http request",
        "z": "b326d8d077e77e7a",
        "name": "",
        "method": "POST",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://localhost:11434/api/generate",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": false,
        "headers": [],
        "x": 1260,
        "y": 420,
        "wires": [
            [
                "efbb96885d7f37a8"
            ]
        ]
    },
    {
        "id": "efbb96885d7f37a8",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "name": "",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1430,
        "y": 420,
        "wires": []
    },
    {
        "id": "98d7fcefabd34846",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "name": "Start Chat",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": "0",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 880,
        "y": 480,
        "wires": [
            [
                "e0b0c8acacbd9f29"
            ]
        ]
    },
    {
        "id": "e0b0c8acacbd9f29",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "name": "Format Payload",
        "func": "msg.payload = {\n    host: \"http://localhost:11434\",\n    model: \"phi\",\n    messages: [\n        { role: \"user\", content: \"Hello, how are you?\" }\n    ]\n};\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 480,
        "wires": [
            [
                "dfa75292bac70250"
            ]
        ]
    },
    {
        "id": "dfa75292bac70250",
        "type": "ollama-chat",
        "z": "b326d8d077e77e7a",
        "name": "",
        "x": 1270,
        "y": 480,
        "wires": [
            [
                "2220a0734e14e134"
            ]
        ]
    },
    {
        "id": "2220a0734e14e134",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "name": "Chat Response",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 1520,
        "y": 480,
        "wires": []
    },
    {
        "id": "68e01c0f4f370838",
        "type": "switch",
        "z": "b326d8d077e77e7a",
        "name": "Check Sequence Complete",
        "property": "payload",
        "propertyType": "msg",
        "rules": [
            {
                "t": "eq",
                "v": "Sequence Complete",
                "vt": "str"
            }
        ],
        "checkall": "true",
        "repair": false,
        "outputs": 1,
        "x": 1000,
        "y": 1220,
        "wires": [
            [
                "3018bdaa105da774"
            ]
        ]
    },
    {
        "id": "0c5c046902849256",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "name": "Debug",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1730,
        "y": 1500,
        "wires": []
    },
    {
        "id": "70c5fc6d4c26179e",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "name": "Run Prompt",
        "func": "console.log('[Run Prompt] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPrompt = context.runPrompt || {};\ncontext.runPrompt.isStopRequested = msg.payload === \"stop\";\n\nconsole.log('context.runPrompt:', context.runPrompt);\n\nlet browser, browserContext, currentPage;\nconsole.log('[Run Prompt] Initial state:', { browser, browserContext, currentPage });\n\nasync function connectAndSetupPage() {\n    console.log('[Run Prompt] Entering connectAndSetupPage');\n    if (!browser) {\n        console.log('[Run Prompt] Browser not initialized, connecting...');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        console.log('[Run Prompt] Browser connected');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt] Browser context obtained');\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n        console.log('[Run Prompt] Current page set');\n    }\n    //    console.log('[Run Prompt] Exiting connectAndSetupPage:', { browser, browserContext, currentPage });\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    console.log('[Run Prompt] Entering getCurrentPage');\n    if (!browserContext) {\n        console.log('[Run Prompt] Browser context not found, creating new one');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt] New browser context created');\n    }\n    const pages = await browserContext.pages();\n    console.log('[Run Prompt] Number of pages:', pages.length);\n    const currentPage = pages[pages.length - 1];\n    //console.log('[Run Prompt] Exiting getCurrentPage, current page:', currentPage);\n    return currentPage;\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n\n        if (shouldClick) {\n            await button.click();\n\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    console.log('[Run Prompt] Entering reloadPageIfNecessary:', { retryCount });\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        console.log('[Run Prompt] Should reload:', shouldReload);\n        shouldReload && await page.reload({ waitUntil: 'networkidle' });\n        console.log('[Run Prompt] Page reloaded:', shouldReload);\n    } catch (error) {\n        console.log(`[Run Prompt] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    console.log('[Run Prompt] Entering waitForResponseCompletion');\n    console.log('[Run Prompt] Initializing variables');\n\n    let previousLength = 0, currentLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    console.log(`[Run Prompt] Max stable count: ${maxStableCount}, Max wait time: ${maxWaitTime}ms`);\n\n    while (Date.now() - startTime < maxWaitTime) {\n        console.log(`[Run Prompt] Elapsed time: ${Date.now() - startTime}ms`);\n\n        if (context.runPrompt.isStopRequested) {\n            console.log('[Run Prompt] Stop requested. Halting response completion.');\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            console.log('[Run Prompt] Attempting to get current page');\n            const page = await getCurrentPage();\n            console.log('[Run Prompt] Successfully got current page');\n\n            // Check for scroll-to-bottom button and click if visible\n            console.log('[Run Prompt] Checking for scroll-to-bottom button');\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                console.log('[Run Prompt] Scroll-to-bottom button clicked, waiting for scroll animation');\n                await page.waitForTimeout(1000); // Wait for scroll animation\n                console.log('[Run Prompt] Scroll animation wait complete');\n            } else {\n                console.log('[Run Prompt] Scroll-to-bottom button not found or not clicked');\n            }\n\n            console.log('[Run Prompt] Waiting for article selector');\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            console.log('[Run Prompt] Article selector found');\n\n            console.log('[Run Prompt] Querying for articles');\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n            console.log(`[Run Prompt] Found ${articles.length} articles`);\n\n            if (articles.length === 0) {\n                console.log('[Run Prompt] No articles found, waiting...');\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt] Attempting to extract content from last article');\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n                console.log('[Run Prompt] Content extracted successfully');\n            } catch (error) {\n                console.log('[Run Prompt] Error extracting content:', error.message);\n                console.log('[Run Prompt] Falling back to article.innerText()');\n                responseText = await lastArticle.innerText();\n                console.log('[Run Prompt] Fallback content extraction complete');\n            }\n\n            currentLength = responseText.length;\n            console.log(`[Run Prompt] Current response length: ${currentLength}`);\n            if (currentLength == 0) {\n                console.log('[Run Prompt] No content found in the response');\n            }\n\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n            console.log(`[Run Prompt] Is response stable: ${isStable}, Stable count: ${stableCount}`);\n\n            if (stableCount >= maxStableCount) {\n                console.log('[Run Prompt] Response appears to be complete');\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            console.log('[Run Prompt] Waiting for 2 seconds before next iteration');\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            console.log(`[Run Prompt] Error in waitForResponseCompletion: ${error.message}`);\n            console.log('[Run Prompt] Error stack:', error.stack);\n            console.log('[Run Prompt] Waiting for 3 seconds before retrying');\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    console.log('[Run Prompt] Max wait time exceeded. Returning current response.');\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    console.log('[Run Prompt] Entering extractResponseText');\n    let responseText = '';\n    let lastArticle;\n\n    try {\n        // Find all articles within the h-full div\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        console.log(`[Run Prompt] Found ${articles.length} articles`);\n\n        if (articles.length > 0) {\n            // Get the last article\n            lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt] Selected the last article');\n        } else {\n            throw new Error('No articles found');\n        }\n\n        // Find and click the copy button\n        const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n        if (copyButton) {\n            await copyButton.click();\n            await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n\n            // Get clipboard contents\n            responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            console.log('[Run Prompt] Response extracted from clipboard');\n        } else {\n            console.log('[Run Prompt] Copy button not found, falling back to original method');\n            const markdownDiv = await lastArticle.$('div.markdown');\n            if (markdownDiv) {\n                responseText = await markdownDiv.innerText();\n            } else {\n                throw new Error('Markdown div not found');\n            }\n        }\n    } catch (error) {\n        console.log('[Run Prompt] Error extracting content:', error.message);\n        try {\n            if (!lastArticle) {\n                lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n                if (!lastArticle) {\n                    throw new Error('Unable to find last article');\n                }\n            }\n            const textBaseElement = await lastArticle.$('.text-base');\n            if (textBaseElement) {\n                responseText = await textBaseElement.innerText();\n                console.log('[Run Prompt] Response extracted using alternative selector');\n            } else {\n                throw new Error('Alternative selector not found');\n            }\n        } catch (innerError) {\n            console.log('[Run Prompt] Alternative selector also failed, using entire article content');\n            if (lastArticle) {\n                responseText = await lastArticle.innerText();\n            } else {\n                console.log('[Run Prompt] Failed to extract any content');\n                responseText = '';\n            }\n        }\n    }\n\n    console.log('[Run Prompt] Exiting extractResponseText, response length:', responseText.length);\n    return responseText;\n}\n\nasync function stopGeneration() {\n    console.log('[Run Prompt] Entering stopGeneration');\n    context.runPrompt.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n    console.log('[Run Prompt] Exiting stopGeneration');\n}\n\nfunction clearStopRequestedState() {\n    context.runPrompt.isStopRequested = false;\n    console.log('[Run Prompt] Stop requested state cleared.');\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close().then(() => console.log('[Run Prompt] Browser closed'));\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage  // Set _continuation to true for the last message\n    };\n\n    const secondOutput = {\n        payload: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage === true\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPrompt(msg) {\n    console.log('[Run Prompt] Entering runPrompt');\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        console.log('[Run Prompt] Got current page in runPrompt');\n\n        const newChatButton = await page.$('nav > a.flex.py-3.px-3.items-center.gap-3.rounded-md:has-text(\"New chat\")');\n        if (newChatButton) {\n            console.log('[Run Prompt] Found new chat button, clicking...');\n            await newChatButton.click();\n            await page.waitForLoadState('networkidle');\n            console.log('[Run Prompt] Clicked new chat button');\n        } else {\n            console.log('[Run Prompt] New chat button not found');\n        }\n\n        await clickButtonIfVisible('button:has-text(\"Continue generating\")', true);\n\n        const promptText = msg.payload || 'Give me a recipe for biscuits';\n        console.log('[Run Prompt] Entering prompt:', promptText);\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n        await page.click('button[data-testid=\"send-button\"]');\n        console.log('[Run Prompt] Sent prompt');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n        console.log('[Run Prompt] Exiting runPrompt');\n        return responseText;\n    } catch (error) {\n        console.log(`[Run Prompt] Error in runPrompt: ${error.message}`);\n        console.log('[Run Prompt] Error stack:', error.stack);\n        throw error;\n    }\n}\n\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPrompt.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPrompt(msg);\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    console.log('This is the last step');\n    return msg.currentStep === msg.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    }; \n}\n\nfunction handleError(error) {\n    return {\n        payload: 'Error occurred: ' + error.message,\n        status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n        error: error.message\n    };\n}\n\nasync function executeScript(msg) {\n    console.log('[Run Prompt] Entering executeScript');\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n        \n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n            console.log('last step result: ', result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\n\n\nexecuteScript(msg);\n\nreturn null;\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 20,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1530,
        "y": 1500,
        "wires": [
            [
                "0c5c046902849256"
            ],
            [
                "408594f2b61d8a63",
                "7dc720f11f8dbb13"
            ]
        ]
    },
    {
        "id": "408594f2b61d8a63",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "name": "Sequence Controller",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet prompts = context.get('prompts') || [];\nlet currentStep = context.get('currentStep') || 0;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\nfunction loadPrompts() {\n\n    const username = os.userInfo().username;\n\n    // Join DOCUMENTS_PATH with the specific folder structure\n    const filePath = msg.filePath\n    //const filePath = path.join(DOCUMENTS_PATH, 'Sync', 'PeterMainVault', '9 - Prompts', 'Execute', 'OtherPrompts.md');\n    console.log('File path:', filePath);\n\n    try {\n        const content = fs.readFileSync(filePath, 'utf8');\n        const sections = content.split('\\n# ');\n\n        prompts = sections.slice(1).map(section => {\n            const [title, ...bodyLines] = section.split('\\n');\n            return {\n                title: title.trim(),\n                body: bodyLines.join('\\n').trim()\n            };\n        });\n\n        context.set('prompts', prompts);\n        console.log(`[Sequence Controller] Loaded ${prompts.length} prompts`);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${prompts.length} prompts` });\n    } catch (error) {\n        console.error(`[Sequence Controller] Failed to load prompts: ${error.message}`);\n        node.error(`Failed to load prompts from ${filePath}: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to load prompts\" });\n    }\n}\n\nfunction processNextPrompt() {\n    console.log(`[Sequence Controller] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < prompts.length) {\n        const msg = {\n            currentStep: currentStep,\n            totalSteps: prompts.length,  // Add this line\n            promptConfig: prompts[currentStep],\n            payload: prompts[currentStep].body,\n            _continuation: true\n        };\n        console.log(`[Sequence Controller] Sending prompt ${currentStep + 1} of ${prompts.length}`);\n        node.send(msg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${prompts.length}` });\n    } else {\n        console.log('[Sequence Controller] All prompts processed. Stopping.');\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[Sequence Controller] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[Sequence Controller] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    prompts = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('prompts', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, Prompts Unloaded\" });\n    // Send message to the Playwright function node if not last msg\n    if (msg._continuation == true){node.send({ payload: \"stop\" });}\n\n}\n\n// Load prompts if they haven't been loaded yet\nif (!prompts.length) {\n    loadPrompts();\n}\n\nif (msg._continuation) {\n    console.log(`[Sequence Controller] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.payload === \"done\" || msg.payload === \"End of Sequence\") {\n            console.log('[Sequence Controller] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            currentStep++;\n            context.set('currentStep', currentStep);\n            processNextPrompt();\n        } else if (msg.payload === \"error\") {\n            console.log(`[Sequence Controller] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[Sequence Controller] Received new message with payload: ${msg.payload}`);\n    if (msg.payload === \"start\") {\n        startProcessing();\n    } else if (msg.payload === \"stop\") {\n        stopProcessing();\n    } else if (msg.payload === \"reload\") {\n        loadPrompts();\n    } else if (msg.payload === \"Sequence Complete\") {\n        stopProcessing();\n        console.log('[Sequence Controller] All prompts processed. Stopping.'); \n        node.status({ fill: \"green\", shape: \"dot\", text: \"All prompts processed. Stopping.\" });\n    } else {\n        console.log(`[Sequence Controller] Unrecognized message: ${msg.payload}`);\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1260,
        "y": 1500,
        "wires": [
            [
                "70c5fc6d4c26179e"
            ]
        ]
    },
    {
        "id": "149aab8559ee01a6",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "name": "Start Sequence",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "start",
        "payloadType": "str",
        "x": 980,
        "y": 1480,
        "wires": [
            [
                "408594f2b61d8a63"
            ]
        ]
    },
    {
        "id": "26b38ae32f902e96",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "name": "Stop Sequence",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "stop",
        "payloadType": "str",
        "x": 980,
        "y": 1520,
        "wires": [
            [
                "408594f2b61d8a63"
            ]
        ]
    },
    {
        "id": "71a0bd79547d86dd",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "name": "Reload Sequence",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "reload",
        "payloadType": "str",
        "x": 970,
        "y": 1560,
        "wires": [
            [
                "408594f2b61d8a63"
            ]
        ]
    },
    {
        "id": "fdc66ba25aa857c2",
        "type": "inject",
        "z": "b326d8d077e77e7a",
        "name": "Start Process",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "jumpTo",
                "v": "",
                "vt": "num"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "start",
        "payloadType": "str",
        "x": 870,
        "y": 1160,
        "wires": [
            [
                "dbbddf8e4f8a288e"
            ]
        ]
    },
    {
        "id": "3018bdaa105da774",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "name": "queueManager",
        "func": "// Initialize queue if not already done\nlet fileQueue;\n\n// Check if msg.files is not empty\nif (msg.files && msg.files.length > 0) {\n    fileQueue = msg.files;\n    context.set('fileQueue', fileQueue);\n} else {\n    fileQueue = context.get('fileQueue');\n}\n\n// Initialize queue position\nlet queuePosition = context.get('queuePosition') || 0;\n\n\n// Handle jumpTo logic\nif (msg.hasOwnProperty('jumpTo') && msg.jumpTo >= 0 && msg.jumpTo < fileQueue.length) {\n    queuePosition = msg.jumpTo;\n    context.set('queuePosition', queuePosition);\n}\n\n// Update node status to show current position in queue\nnode.status({fill: \"blue\", shape: \"dot\", text: `Position: ${queuePosition+1}/${fileQueue.length}`});\n\n// Check if there are files left to process\nif (queuePosition < fileQueue.length) {\n    msg.payload = fileQueue[queuePosition];\n    msg.queuePosition = queuePosition;\n    msg.totalSpots = fileQueue.length;\n    queuePosition += 1;\n    context.set('queuePosition', queuePosition);\n} else {\n    msg.payload = 'Queue is empty';\n    node.status({fill: \"red\", shape: \"ring\", text: \"Queue is empty\"});\n}\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1280,
        "y": 1220,
        "wires": [
            [
                "ee29f35e78e652e2"
            ]
        ]
    },
    {
        "id": "6dbb331617e99715",
        "type": "debug",
        "z": "b326d8d077e77e7a",
        "name": "Processed Output",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1730,
        "y": 1220,
        "wires": []
    },
    {
        "id": "ee29f35e78e652e2",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "name": "queueOutput",
        "func": "if (msg.payload !== 'Queue is empty') {\n    let lastMessage = (msg.queuePosition === msg.totalSpots - 1);\n    let processedFile = {\n        payload: \"start\",\n        filePath: msg.payload, \n        queuePosition: msg.queuePosition, \n        totalSpots: msg.totalSpots, \n        lastMessage: lastMessage \n    };\n    let completionMessage = { payload: 'Sequence Complete' };\n\n    // Update node status to show if it's the last message\n    if (lastMessage) {\n        node.status({fill: \"green\", shape: \"dot\", text: \"Last Message\"});\n    } else {\n        node.status({fill: \"yellow\", shape: \"dot\", text: `Queue Position: ${msg.queuePosition + 1}/${msg.totalSpots}`});\n    }\n\n    return [processedFile];\n}\nreturn [null, null];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1470,
        "y": 1220,
        "wires": [
            [
                "6dbb331617e99715",
                "408594f2b61d8a63"
            ]
        ]
    },
    {
        "id": "dbbddf8e4f8a288e",
        "type": "function",
        "z": "b326d8d077e77e7a",
        "name": "File Paths",
        "func": "const username = os.userInfo().username;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\n// Join DOCUMENTS_PATH with the specific folder structure\nconst filePath1 = path.join(cimaPrompts, 'Hyperprompts', 'shortTest.md');\nconst filePath2 = path.join(cimaPrompts, 'Hyperprompts', 'shortTest2.md');\n\nlet files = [filePath1, filePath2, \"file3.txt\"];\n\nmsg.files = files;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1060,
        "y": 1160,
        "wires": [
            [
                "3018bdaa105da774"
            ]
        ]
    },
    {
        "id": "7dc720f11f8dbb13",
        "type": "link out",
        "z": "b326d8d077e77e7a",
        "name": "link out 1",
        "mode": "link",
        "links": [
            "1750d31c2979e278"
        ],
        "x": 1685,
        "y": 1560,
        "wires": []
    },
    {
        "id": "1750d31c2979e278",
        "type": "link in",
        "z": "b326d8d077e77e7a",
        "name": "LO: Seq Complete Signal",
        "links": [
            "7dc720f11f8dbb13"
        ],
        "x": 845,
        "y": 1220,
        "wires": [
            [
                "68e01c0f4f370838"
            ]
        ]
    },
    {
        "id": "1b142c54719e8659",
        "type": "delay",
        "z": "ecd378f1d3401d0d",
        "name": "Wait for Stabilization",
        "pauseType": "delay",
        "timeout": "5",
        "timeoutUnits": "seconds",
        "rate": "1",
        "nbRateUnits": "1",
        "rateUnits": "second",
        "randomFirst": "1",
        "randomLast": "5",
        "randomUnits": "seconds",
        "drop": false,
        "outputs": 1,
        "x": 340,
        "y": 300,
        "wires": [
            [
                "eb2951843983362b"
            ]
        ]
    },
    {
        "id": "41b9b310d6f5f047",
        "type": "comment",
        "z": "ecd378f1d3401d0d",
        "name": "Full Flow",
        "info": "Concatenate:\n- Problem Event\n- Analyze Logs + Come up with \nproblems and solutions\n-- Prompt 1 + msg.payload (the logs)\n-- Prompt 2 - id & fix code + nodeCmd:\n (parse in Seq Cont, then \n dynamically get the code -\n  do in nodeCmd block of Run Prompt)\n-- Prompt 3 - check for issues \n- Redeploy\n- Run the code again",
        "x": 60,
        "y": 180,
        "wires": []
    },
    {
        "id": "1d30e3c979cfa196",
        "type": "saveflow",
        "z": "ecd378f1d3401d0d",
        "name": "",
        "path": "",
        "enabled": false,
        "exporttype": "original",
        "x": 140,
        "y": 300,
        "wires": [
            [
                "1b142c54719e8659"
            ]
        ]
    },
    {
        "id": "e91d9fb691116ece",
        "type": "debug",
        "z": "ecd378f1d3401d0d",
        "name": "debug 8",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1480,
        "y": 380,
        "wires": []
    },
    {
        "id": "8b79eb7951f13d35",
        "type": "inject",
        "z": "ecd378f1d3401d0d",
        "g": "7b7c1084c38a93ca",
        "name": "Trigger Event",
        "props": [],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 370,
        "y": 120,
        "wires": [
            [
                "1f9e9648a6fdea3e"
            ]
        ]
    },
    {
        "id": "1f9e9648a6fdea3e",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "7b7c1084c38a93ca",
        "name": "Run Script",
        "func": "// Custom script logic\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 350,
        "y": 180,
        "wires": [
            [
                "eb2951843983362b"
            ]
        ]
    },
    {
        "id": "eb2951843983362b",
        "type": "file in",
        "z": "ecd378f1d3401d0d",
        "g": "7b7c1084c38a93ca",
        "name": "Read Log File",
        "filename": "C:\\Users\\LOU\\.node-red\\logs\\node-red.log",
        "filenameType": "str",
        "format": "utf8",
        "sendError": false,
        "allProps": false,
        "x": 600,
        "y": 220,
        "wires": [
            [
                "4490085b05c634e4"
            ]
        ]
    },
    {
        "id": "4490085b05c634e4",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "7b7c1084c38a93ca",
        "name": "Filter Logs by Timestamp",
        "func": "// Ensure logs is an array of lines\nlet logs = Array.isArray(msg.payload) ? msg.payload : msg.payload.split('\\n');\n\nlet lastIndex = -1;\nlet totalOccurrences = 0;\n\n// Find the last occurrence and count total occurrences\nfor (let i = logs.length - 1; i >= 0; i--) {\n    if (logs[i].includes(\"[INFO] default - Started flows\")) {\n        if (lastIndex === -1) {\n            lastIndex = i;\n        }\n        totalOccurrences++;\n    }\n}\n\nif (lastIndex !== -1) {\n    // Calculate the line number (add 1 because array indices start at 0)\n    let lineNumber = lastIndex + 1;\n\n    // Log and store the line number\n    console.log(`Last occurrence of \"[INFO] default - Started flows\" is on line ${lineNumber}`);\n    msg.lastStartedFlowsLineNumber = lineNumber;\n    msg.payload = \"loaded logs\"\n    // Slice the array from the found index to the end\n    msg.log = logs.slice(lastIndex).join('\\n');\n} else {\n    // If the line is not found, keep all logs and add a warning\n    msg.log = logs.join('\\n');\n    msg.warning = \"The line '[INFO] default - Started flows' was not found in the logs.\";\n}\n\n// Log the total number of occurrences\nconsole.log(`Total occurrences of \"[INFO] default - Started flows\": ${totalOccurrences}`);\nmsg.totalStartedFlowsOccurrences = totalOccurrences;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 220,
        "wires": [
            [
                "3819d7a1bb987cd4"
            ]
        ]
    },
    {
        "id": "3819d7a1bb987cd4",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "7b7c1084c38a93ca",
        "name": "File Paths",
        "func": "const username = os.userInfo().username;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\n// Join DOCUMENTS_PATH with the specific folder structure\nconst filePath1 = path.join(cimaPrompts, 'DebugPrompts', 'Debug1.md');\n\nmsg.filePath = filePath1;\nmsg.status = \"start\";\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1140,
        "y": 220,
        "wires": [
            [
                "7735c94e771bdaf5"
            ]
        ]
    },
    {
        "id": "c1e5648ebbc40637",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "Run Prompt Main",
        "func": "console.log('[Run Prompt Main] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPrompt = context.runPrompt || {};\ncontext.runPrompt.isStopRequested = msg.payload === \"stop\";\ncontext.runPrompt.responseCount = context.runPrompt.responseCount || 0;\n\nlet browser, browserContext, currentPage;\n\nasync function connectAndSetupPage() {\n    if (!browser) {\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n    }\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    if (!browserContext) {\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n    }\n    const pages = await browserContext.pages();\n    return pages[pages.length - 1];\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n        if (shouldClick) {\n            await button.click();\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        if (shouldReload) await page.reload({ waitUntil: 'networkidle' });\n    } catch (error) {\n        console.error(`[Run Prompt Main] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    let previousLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    while (Date.now() - startTime < maxWaitTime) {\n        if (context.runPrompt.isStopRequested) {\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            const page = await getCurrentPage();\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                await page.waitForTimeout(1000); // Wait for scroll animation\n            }\n\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n\n            if (articles.length === 0) {\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n            } catch (error) {\n                responseText = await lastArticle.innerText();\n            }\n\n            const currentLength = responseText.length;\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n\n            if (stableCount >= maxStableCount) {\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    let responseText = '';\n    try {\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        if (articles.length > 0) {\n            const lastArticle = articles[articles.length - 1];\n            const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n            if (copyButton) {\n                await copyButton.click();\n                await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n                responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            } else {\n                const markdownDiv = await lastArticle.$('div.markdown');\n                responseText = markdownDiv ? await markdownDiv.innerText() : '';\n            }\n        }\n    } catch (error) {\n        try {\n            const lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n            const textBaseElement = await lastArticle.$('.text-base');\n            responseText = textBaseElement ? await textBaseElement.innerText() : '';\n        } catch (innerError) {\n            responseText = '';\n        }\n    }\n\n    return responseText;\n}\n\nasync function stopGeneration() {\n    context.runPrompt.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n}\n\nfunction clearStopRequestedState() {\n    context.runPrompt.isStopRequested = false;\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close();\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage\n    };\n    const secondOutput = {\n        ...msg,\n        payload: result.payload,\n        status: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPrompt() {\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        const newChatButton = await page.$('nav > a.flex.py-3.px-3.items-center.gap-3.rounded-md:has-text(\"New chat\")');\n        if (newChatButton) {\n            await newChatButton.click();\n            await page.waitForLoadState('networkidle');\n        }\n\n        await clickButtonIfVisible('button:has-text(\"Continue generating\")', true);\n        const promptText = msg.payload || 'Give me a recipe for biscuits';\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n        await page.click('button[data-testid=\"send-button\"]');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n    \n        msg[`response${context.runPrompt.responseCount}`] = responseText;\n        context.runPrompt.responseCount += 1;\n        return responseText;\n    } catch (error) {\n        console.error(`[Run Prompt Main] Error in runPrompt: ${error.message}`);\n        throw error;\n    }\n}\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPrompt.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPrompt();\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt Main] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    return msg.currentStep === msg.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    };\n}\n\nfunction handleError(error) {\n    return {\n        payload: 'Error occurred: ' + error.message,\n        status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n        error: error.message\n    };\n}\n\nasync function executeScript(msg) {\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n\n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\nexecuteScript(msg);\nreturn null;\n",
        "outputs": 2,
        "timeout": "",
        "noerr": 20,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1190,
        "y": 400,
        "wires": [
            [],
            [
                "e91d9fb691116ece",
                "cebfdb8ca306df09"
            ]
        ]
    },
    {
        "id": "ecb21505f2b71198",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "sectionController",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet prompts = context.get('prompts') || [];\nlet currentStep = context.get('currentStep') || 0;\nlet cimaPrompts = global.get('userRootPaths').cimaPrompts;\n\nconsole.log(\"Initial prompts.length : \", prompts.length);\n\nfunction passedPrompts() {\n    console.log('[sectionController] Starting passedPrompts function');\n\n    try {\n        console.log('[sectionController] Checking for existing prompts in context');\n        const existingPrompts = context.get('prompts');\n\n        // Check if there's no existing 'prompts' in the context\n        if (!existingPrompts || existingPrompts.length === 0) {\n            console.log('[sectionController] No existing prompts found in context');\n\n            if (!msg.promptsArray) {\n                console.error('[sectionController] msg.promptsArray is undefined or null');\n                throw new Error('msg.promptsArray is undefined or null');\n            }\n\n            console.log(`[sectionController] Setting ${msg.promptsArray.length} prompts in context`);\n            // If no existing prompts, set the passed array in the context\n            context.set('prompts', msg.promptsArray);\n            prompts = msg.promptsArray;\n            console.log(`[sectionController] Set ${prompts.length} prompts in context`);\n            node.status({ fill: \"blue\", shape: \"dot\", text: `Set ${prompts.length} prompts` });\n        } else {\n            console.log(`[sectionController] ${existingPrompts.length} prompts already exist in context. Not overwriting.`);\n            node.status({ fill: \"yellow\", shape: \"dot\", text: \"Prompts already exist\" });\n            prompts = existingPrompts;\n        }\n\n        console.log(`[sectionController] Returning ${prompts.length} prompts`);\n        return prompts;\n    } catch (error) {\n        console.error(`[sectionController] Failed to handle prompts: ${error.message}`);\n        console.error(`[sectionController] Error stack: ${error.stack}`);\n        node.error(`Failed to handle prompts: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to handle prompts\" });\n        return null;\n    }\n}\n\nfunction processNextPrompt() {\n    console.log(`[sectionController] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < prompts.length) {\n        const newMsg = {\n            ...msg,  // Spread all properties from the original msg\n            currentStep: currentStep,\n            totalSteps: prompts.length,\n            promptConfig: prompts[currentStep],\n            payload: prompts[currentStep].body,\n            _continuation: true\n        };\n        console.log(`[sectionController] Sending prompt ${currentStep + 1} of ${prompts.length}`);\n        node.send(newMsg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${prompts.length}` });\n    } else {\n        console.log('[sectionController] All prompts processed. Stopping.');\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[sectionController] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[sectionController] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    prompts = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('prompts', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, Prompts Unloaded\" });\n    // Send message to the Playwright function node if not last msg\n    if (msg._continuation == true) {\n        node.send({ ...msg, payload: \"stop\" });  // Include all original msg properties\n    }\n}\n\nif (msg._continuation) {\n    console.log(`[sectionController] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.status === \"done\" || msg.status === \"End of Sequence\") {\n            console.log('[sectionController] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            currentStep++;\n            context.set('currentStep', currentStep);\n            processNextPrompt();\n        } else if (msg.status === \"error\") {\n            console.log(`[sectionController] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[sectionController] Received new message with payload: ${msg.payload}`);\n    if (msg.status === \"start\") {\n        // Load prompts if they haven't been loaded yet\n        if (!prompts.length) {\n            passedPrompts();\n            console.log(\"prompts.length : \", prompts.length);\n        }\n        startProcessing();\n    } else if (msg.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.status === \"reload\") {\n        passedPrompts();\n    } else if (msg.status === \"Sequence Complete\") {\n        stopProcessing();\n        console.log('[sectionController] All prompts processed. Stopping.'); \n        node.status({ fill: \"green\", shape: \"dot\", text: \"All prompts processed. Stopping.\" });\n    } else {\n        console.log(`[sectionController] Unrecognized message: ${msg.payload}`);\n    }\n}\n\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 590,
        "y": 400,
        "wires": [
            [
                "a142d35aa4e7a75c"
            ]
        ]
    },
    {
        "id": "7735c94e771bdaf5",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "promptLoader",
        "func": "function shouldSkipLoading(msg) {\n    if (msg.filePrompt === false) {\n        console.log('[promptLoader] Skipping file prompt loading');\n        node.status({ fill: \"yellow\", shape: \"dot\", text: \"Skipped file prompt loading\" });\n        return true;\n    }\n    return false;\n}\n\nfunction getFilePath(msg) {\n    if (!msg.filePath) {\n        throw new Error('[promptLoader] msg.filePath is not defined');\n    }\n    const filePath = msg.filePath;\n    console.log('[promptLoader] File path:', filePath);\n    return filePath;\n}\n\nfunction parsePromptSection(section) {\n    const [title, ...bodyLines] = section.split('\\n');\n    let body = bodyLines.join('\\n').trim();\n\n    console.log(`[promptLoader] Parsing prompt section: ${title}`);\n    console.log(`[promptLoader] Body: ${body.substring(0, 100)}...`); // Log first 100 chars to avoid cluttering\n\n    return {\n        title: title.trim(),\n        body: body\n    };\n}\n\nfunction parsePromptsFromContent(content) {\n    const sections = content.split('\\n# ');\n    return sections.slice(1).map(section => parsePromptSection(section));\n}\n\nfunction loadPrompts(msg) {\n    if (shouldSkipLoading(msg)) {\n        return null;\n    }\n\n    try {\n        const filePath = getFilePath(msg);\n        const content = fs.readFileSync(filePath, 'utf8');\n        let prompts = parsePromptsFromContent(content);\n\n        console.log(`[promptLoader] Loaded ${prompts.length} prompts`);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${prompts.length} prompts` });\n\n        return prompts;\n    } catch (error) {\n        console.error(`[promptLoader] Failed to load prompts: ${error.message}`);\n        node.error(`Failed to load prompts: ${error.message}`);\n        node.status({ fill: \"red\", shape: \"ring\", text: \"Failed to load prompts\" });\n        return null;\n    }\n}\n\n// Usage\ntry {\n    const promptsArray = loadPrompts(msg);\n    console.log('[promptLoader] promptsArray length:', promptsArray ? promptsArray.length : 0);\n\n    if (promptsArray) {\n        // Create a new object with all properties of the original message\n        const newMsg = { ...msg };\n        // Add the promptsArray to the new message object\n        newMsg.promptsArray = promptsArray;\n        return newMsg;\n    } else {\n        // If prompts weren't loaded successfully, return the original message\n        return msg;\n    }\n} catch (error) {\n    console.error(`[promptLoader] Unexpected error: ${error.message}`);\n    node.error(`Unexpected error: ${error.message}`);\n    return null;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 360,
        "y": 400,
        "wires": [
            [
                "ecb21505f2b71198"
            ]
        ]
    },
    {
        "id": "a142d35aa4e7a75c",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "dynamicCmd",
        "func": "// Consolidated function to parse dynamic variables\nfunction parseDynamicVariables(text, msg, context, dynamicCmd) {\n    console.log('[parseDynamicVariables] Starting function');\n\n    if (!msg || typeof msg !== 'object') {\n        console.warn('[parseDynamicVariables] Warning: msg is not a valid object');\n        return text;\n    }\n\n    const objectReplacements = new Map();\n    let counter = 0;\n\n    function resolveValue(path) {\n        console.log(`[parseDynamicVariables] Resolving value for path: ${path}`);\n\n        // Handle execute() function\n        const executeMatch = path.match(/^execute\\((.*)\\)$/);\n        if (executeMatch) {\n            let command = executeMatch[1].trim();\n            try {\n                if (command.endsWith(';')) {\n                    command = command.slice(0, -1);\n                }\n                const dynamicFunction = new Function('context', 'msg', `return ${command}`);\n                const value = dynamicFunction(context, msg);\n                console.log(`[parseDynamicVariables] Executed command: ${command}, Result: ${value}`);\n                return value !== undefined ? value : `[${command} returned undefined]`;\n            } catch (error) {\n                console.error(`[parseDynamicVariables] Error executing command: ${error.message}`);\n                return `[Error executing command: ${error.message}]`;\n            }\n        }\n\n        // Handle {previousResponse}\n        if (path === '{previousResponse}') {\n            if (msg && typeof msg.currentStep !== 'undefined') {\n                const currentStep = msg.currentStep || 0;\n                const previousResponseNumber = currentStep - 1;\n                if (previousResponseNumber >= 0 && msg[`response${previousResponseNumber}`]) {\n                    return msg[`response${previousResponseNumber}`];\n                }\n            }\n            return '[Previous response not available]';\n        }\n\n        // Handle $<<commandTypeNumberResult>>$\n        const cmdResultMatch = path.match(/^(\\w+)(\\d+)Result$/);\n        if (cmdResultMatch && dynamicCmd) {\n            const [, cmdType, cmdNumber] = cmdResultMatch;\n            const targetCmd = dynamicCmd.sections.flatMap(section => section.commands)\n                .find(c => c.type === cmdType && c.number === cmdNumber);\n            if (targetCmd && targetCmd.result !== undefined) {\n                return targetCmd.result;\n            }\n            return `[No result found for ${cmdType}${cmdNumber}]`;\n        }\n\n        // Regular path traversal\n        const parts = path.split('.');\n        let value = msg;\n        const startIndex = parts[0] === 'msg' ? 1 : 0;\n        for (let i = startIndex; i < parts.length; i++) {\n            if (value && typeof value === 'object' && parts[i] in value) {\n                value = value[parts[i]];\n            } else {\n                console.warn(`[parseDynamicVariables] Warning: ${parts[i]} does not exist in the object`);\n                return `[${path} not available]`;\n            }\n        }\n        return value;\n    }\n\n    function handleUndefinedOrNull(path, value) {\n        if (value === undefined || value === null) {\n            console.warn(`[parseDynamicVariables] Warning: ${path} is ${value === undefined ? 'undefined' : 'null'}`);\n            return `[${path} not available]`;\n        }\n        return null;\n    }\n\n    function handleObject(path, value) {\n        if (typeof value === 'object') {\n            const marker = `__OBJECT_REPLACEMENT_${counter}__`;\n            objectReplacements.set(marker, value);\n            counter++;\n            return marker;\n        }\n        return null;\n    }\n\n    // Replace dynamic variables\n    const intermediateResult = text.replace(/\\$<<([^>]+)>>\\$|\\{([^}]+)\\}/g, (match, p1, p2) => {\n        const path = p1 || p2;\n        const value = resolveValue(path);\n\n        const undefinedOrNullResult = handleUndefinedOrNull(path, value);\n        if (undefinedOrNullResult) return undefinedOrNullResult;\n\n        const objectResult = handleObject(path, value);\n        if (objectResult) return objectResult;\n\n        return String(value);\n    });\n\n    // Replace object markers\n    let finalResult = intermediateResult;\n    for (const [marker, value] of objectReplacements) {\n        finalResult = finalResult.replace(marker, JSON.stringify(value));\n    }\n\n    console.log(`[parseDynamicVariables] Final result: ${finalResult}`);\n    return finalResult;\n}\n\n// 2. Generalized function to execute commands with added safety checks\nfunction executeCommands(commands, context, msg) {\n    let resultAccumulator = \"\";\n\n    commands.forEach((cmdBlock, index) => {\n        console.log(`[function:dynamicCmd] Executing command block: ${cmdBlock.name || `Command ${index + 1}`}`);\n        console.log(`[function:dynamicCmd] Command content: ${JSON.stringify(cmdBlock)}`);\n\n        if (cmdBlock.commands.length === 0) {\n            console.log(`[function:dynamicCmd] No commands found in: ${cmdBlock.name || `Command ${index + 1}`}`);\n        }\n\n        cmdBlock.commands.forEach(cmd => {\n            if (cmd.trim() === '') {\n                console.log(`[function:dynamicCmd] Skipping empty command.`);\n                return; // Skip empty commands\n            }\n\n            console.log(`[function:dynamicCmd] Executing command: ${cmd}`);\n\n            try {\n                // Dynamically create and execute the function with a timeout to prevent hanging\n                let result;\n                const dynamicFunction = new Function('context', 'msg', cmd);\n                const timeout = setTimeout(() => {\n                    throw new Error(\"Command execution timed out.\");\n                }, 5000); // Set a timeout of 5 seconds\n\n                result = dynamicFunction(context, msg);  // Pass context and execute the function\n                clearTimeout(timeout); // Clear the timeout if execution completes\n\n                // Check if the function returned a value\n                if (result !== undefined) {\n                    console.log(`[function:dynamicCmd] Command executed successfully with result: ${result}`);\n                    resultAccumulator += result + \"\\n\";  // Accumulate results\n                } else {\n                    console.log(`[function:dynamicCmd] Command executed successfully but returned no result.`);\n                }\n            } catch (error) {\n                console.error(`[function:dynamicCmd] Error executing command: ${error.message}`);\n                resultAccumulator += `[Error executing command: ${error.message}]\\n`; // Accumulate error message\n            }\n        });\n    });\n\n    console.log(`[function:dynamicCmd] Finished executing all commands. Final accumulated result: ${resultAccumulator.trim()}`);\n    return resultAccumulator.trim();\n}\n\n// Part 2: Command Processing and Side Prompt Handling\n\n// 3. Function to process compileCmd or packCmd\nfunction processCompileOrPackCmd(cmdArray, localResult, context, dynamicCmd, msg, cmdType) {\n    let compiledPrompt = \"\";\n    localResult = localResult || \"\";\n\n    console.log(`[processCompileOrPackCmd] Initial localResult: ${localResult}`);\n    console.log(`[processCompileOrPackCmd] Initial ${cmdType} array: ${JSON.stringify(cmdArray)}`);\n\n    cmdArray.forEach(cmd => {\n        console.log(`[processCompileOrPackCmd] Processing command: ${cmd}`);\n        cmd = parseDynamicVariables(cmd, msg, context, dynamicCmd);\n        compiledPrompt += cmd + \"\\n\";\n    });\n\n    console.log(`[processCompileOrPackCmd] Final ${cmdType} prompt:\\n${compiledPrompt}`);\n    return compiledPrompt;\n}\n\n// Function to process sidePrompt blocks\nasync function processSidePrompt(sidePromptCmds, context, msg) {\n    console.log(`[processSidePrompt] Starting processSidePrompt function.`);\n    console.log(`[processSidePrompt] Number of commands to process: ${sidePromptCmds.length}`);\n\n    // 1. Compile commands into loadedSidePrompt array\n    const loadedSidePrompt = sidePromptCmds.map(cmd => parseDynamicVariables(cmd, msg, context));\n\n    console.log(`[processSidePrompt] Compiled loadedSidePrompt: ${JSON.stringify(loadedSidePrompt)}`);\n\n    // 2. Send loadedSidePrompt out of output2\n    node.send([null, { payload: loadedSidePrompt, status: \"start\", sidePromptCmd: true }]);\n    console.log(`[processSidePrompt] Sent loadedSidePrompt to output2.`);\n\n    // 3. Wait for sidePrompt completion\n    console.log(`[processSidePrompt] Waiting for sidePrompt completion...`);\n    const result = await waitForSidePromptCompletion();\n   \n    console.log(`[processSidePrompt] SidePrompt completion received.`);\n\n    console.log(`[processSidePrompt] SidePrompt processing complete.`);\n    return { loadedSidePrompt, result };\n}\n\n// Function to wait for sidePrompt completion\nfunction waitForSidePromptCompletion() {\n    return new Promise((resolve) => {\n        // Set the global waiting state\n        global.waitingForSidePrompt = true;\n        console.log(`[waitForSidePromptCompletion] Set waitingForSidePrompt to true`);\n\n        // Function to check completion status\n        const checkCompletion = () => {\n            console.log(`[waitForSidePromptCompletion] Checking completion status...`);\n           \n            if (!global.waitingForSidePrompt) {\n                console.log(`[waitForSidePromptCompletion] Side prompt completed`);\n                resolve(global.sidePromptResult);\n            } else {\n                console.log(`[waitForSidePromptCompletion] Still waiting, will check again in 1300ms`);\n                setTimeout(checkCompletion, 1300);\n            }\n        };\n\n        // Start checking\n        checkCompletion();\n    });\n}\n\n// Helper function to set side prompt completion\nfunction setSidePromptCompletion(result) {\n    global.waitingForSidePrompt = false;\n    global.sidePromptResult = result;\n    console.log(`[setSidePromptCompletion] Set waitingForSidePrompt to false and stored result`);\n}\n\n// Function to process mainPromptCmd\nfunction processMainPromptCmd(mainPromptCmd, dynamicCmd, msg) {\n    console.log(`[processMainPromptCmd] Processing mainPromptCmd: ${JSON.stringify(mainPromptCmd)}`);\n    console.log(`[processMainPromptCmd] dynamicCmd structure: ${JSON.stringify(dynamicCmd, null, 2)}`);\n\n    let processedLines = [];\n    let indentLevel = 0;\n\n    for (let line of mainPromptCmd) {\n        console.log(`[processMainPromptCmd] Processing line: ${line}`);\n       \n        // Remove comments and trim whitespace\n        line = line.replace(/\\/\\/.*$/, '').trim();\n       \n        if (line === '') {\n            console.log(`[processMainPromptCmd] Skipping empty line`);\n            continue;\n        }\n\n        // Check for indent level\n        if (line.startsWith('-')) {\n            indentLevel = line.match(/^\\s*/)[0].length;\n            line = line.substring(indentLevel).trim();\n        }\n\n        // Parse dynamic variables\n        line = parseDynamicVariables(line, msg, context, dynamicCmd);\n\n        // Add appropriate indentation\n        line = ' '.repeat(indentLevel) + line;\n\n        console.log(`[processMainPromptCmd] Processed line: ${line}`);\n        processedLines.push(line);\n    }\n\n    // Join the processed lines into a single string with newline characters\n    const result = processedLines.join('\\n');\n\n    console.log(`[processMainPromptCmd] Processed mainPromptCmd result:\\n${result}`);\n    return result;\n}\n\n// 5. Function to execute the parsed commands block by block\nasync function executeCommandsBlockByBlock(dynamicCmd, context, msg, node) {\n    let finalResult = \"\";\n    console.log(`[executeCommandsBlockByBlock] Starting execution of commands`);\n    console.log(`[executeCommandsBlockByBlock] Number of sections: ${dynamicCmd.sections.length}`);\n\n    for (let sectionIndex = 0; sectionIndex < dynamicCmd.sections.length; sectionIndex++) {\n        const section = dynamicCmd.sections[sectionIndex];\n        console.log(`[executeCommandsBlockByBlock] Processing section ${sectionIndex + 1}`);\n        console.log(`[executeCommandsBlockByBlock] Number of commands in section: ${section.commands.length}`);\n\n        for (let commandIndex = 0; commandIndex < section.commands.length; commandIndex++) {\n            const command = section.commands[commandIndex];\n\n            console.log(`[executeCommandsBlockByBlock] Executing command block: ${command.type}${command.number}`);\n            console.log(`[executeCommandsBlockByBlock] Command content: ${JSON.stringify(command, null, 2)}`);\n\n            let result;\n\n            switch (command.type) {\n                case 'localCmd':\n                    try {\n                        const commandString = command.commands.join('\\n');\n                        console.log(`[executeCommandsBlockByBlock] Executing localCmd: ${commandString}`);\n                        const wrappedCommand = `(function() { ${commandString} })()`;\n                        result = eval(wrappedCommand);\n                        console.log(`[executeCommandsBlockByBlock] localCmd result: ${result}`);\n                    } catch (error) {\n                        console.error(`[executeCommandsBlockByBlock] Error executing localCmd: ${error.message}`);\n                        result = `[Error executing command: ${error.message}]`;\n                    }\n                    break;\n                case 'compileCmd':\n                case 'packCmd':\n                    console.log(`[executeCommandsBlockByBlock] Executing ${command.type}`);\n                    result = processCompileOrPackCmd(command.commands, finalResult, context, dynamicCmd, msg, command.type);\n                    console.log(`[executeCommandsBlockByBlock] ${command.type} result: ${JSON.stringify(result, null, 2)}`);\n                    break;\n                case 'sidePromptCmd':\n                    console.log(`[executeCommandsBlockByBlock] Executing sidePromptCmd`);\n                    const sidePromptResult = await processSidePrompt(command.commands, context, msg);\n                    command.loadedSidePrompt = sidePromptResult.loadedSidePrompt;\n                    command.result = sidePromptResult.result;\n                    result = command.result;\n                    console.log(`[executeCommandsBlockByBlock] SidePrompt execution complete`);\n                    console.log(`[executeCommandsBlockByBlock] SidePrompt result:`, JSON.stringify(command, null, 2));\n                    break;\n                case 'mainPromptCmd':\n                    console.log(`[executeCommandsBlockByBlock] Executing mainPromptCmd`);\n                    result = processMainPromptCmd(command.commands, dynamicCmd, msg);\n                    console.log(`[executeCommandsBlockByBlock] mainPromptCmd result:\\n${result}`);\n                    break;\n                default:\n                    console.log(`[executeCommandsBlockByBlock] Unknown command type: ${command.type}`);\n                    result = `[Unknown command type: ${command.type}]`;\n            }\n\n            command.result = result;\n            if (command.type === 'mainPromptCmd') {\n                finalResult = result; // For mainPromptCmd, set finalResult to the string result\n            } else {\n                finalResult += (finalResult ? \"\\n\" : \"\") + result; // For other commands, append to finalResult\n            }\n\n            console.log(`[executeCommandsBlockByBlock] Command execution complete`);\n            console.log(`[executeCommandsBlockByBlock] Updated state of ${command.type}${command.number}:`, JSON.stringify(command, null, 2));\n\n            // Update msg.dynamicCmd after each command execution\n            msg.dynamicCmd = JSON.parse(JSON.stringify(dynamicCmd));\n            console.log(`[executeCommandsBlockByBlock] Updated msg.dynamicCmd`);\n        }\n    }\n\n    console.log(`[executeCommandsBlockByBlock] All commands executed`);\n    console.log(`[executeCommandsBlockByBlock] Final state of dynamicCmd:`, JSON.stringify(dynamicCmd, null, 2));\n    console.log(`[executeCommandsBlockByBlock] Final result:\\n${finalResult}`);\n\n    return { result: finalResult, dynamicCmd: dynamicCmd };\n}\n\n// 6. Function to parse the input text and extract commands, while stripping out comments and handling indentation\n// Function to parse the input text and extract commands\nfunction parseInputText(inputText) {\n    console.log(`[parseInputText] Input text: ${inputText}`);\n    const lines = inputText.split('\\n');\n    console.log(`[parseInputText] Number of lines: ${lines.length}`);\n\n    let dynamicCmd = { sections: [] };\n    let currentCommand = null;\n    let isCapturingNestedCommand = false;\n    let nestedCommandBuffer = '';\n\n    const processLine = (line) => {\n        console.log(`[parseInputText] Processing line: '${line}'`);\n        line = line.replace(/\\/\\/.*$/, '').trim(); // Remove comments\n        console.log(`[parseInputText] Removed comment. New line: '${line}'`);\n\n        if (line === 'dynamicCmd') {\n            dynamicCmd.sections.push({ type: 'commandSet', commands: [] });\n            console.log(`[parseInputText] Detected 'dynamicCmd' section. Created new command set.`);\n            return;\n        }\n\n        if (line === '- commandSet') {\n            console.log(`[parseInputText] Detected commandSet line, ignoring.`);\n            return;\n        }\n\n        if (line.match(/^-\\s*(\\w+)(\\d+)/)) {\n            const [, cmdType, cmdNumber] = line.match(/^-\\s*(\\w+)(\\d+)/);\n            currentCommand = { type: cmdType, number: cmdNumber, commands: [] };\n            dynamicCmd.sections[dynamicCmd.sections.length - 1].commands.push(currentCommand);\n            console.log(`[parseInputText] Started new main command: ${cmdType} with number ${cmdNumber}`);\n        } else if (line.startsWith('- `')) {\n            isCapturingNestedCommand = true;\n            nestedCommandBuffer = line.substring(3);\n            console.log(`[parseInputText] Started capturing nested command`);\n        } else if (isCapturingNestedCommand) {\n            if (line.endsWith('`')) {\n                nestedCommandBuffer += line.substring(0, line.length - 1);\n                currentCommand.commands.push(nestedCommandBuffer);\n                isCapturingNestedCommand = false;\n                console.log(`[parseInputText] Finished capturing nested command: ${nestedCommandBuffer}`);\n            } else {\n                nestedCommandBuffer += line + '\\n';\n                console.log(`[parseInputText] Capturing nested command. Current buffer: ${nestedCommandBuffer}`);\n            }\n        } else if (line.startsWith('-') && currentCommand) {\n            const subCommand = line.substring(1).trim();\n            currentCommand.commands.push(subCommand);\n            console.log(`[parseInputText] Added sub-command: ${subCommand}`);\n        }\n    };\n\n    lines.forEach(processLine);\n\n    console.log(`[parseInputText] Finished parsing input text.`);\n    console.log(`[parseInputText] Final parsed dynamicCmd: ${JSON.stringify(dynamicCmd, null, 2)}`);\n\n    return dynamicCmd;\n}\n\n// 7. Main function to handle the entire process block by block\nasync function handleDynamicCmd(inputText, msg, node) {\n    console.log(\"[handleDynamicCmd] Starting handleDynamicCmd function.\");\n    console.log(`[handleDynamicCmd] Input text: ${inputText}`);\n\n    if (!/dynamicCmd/.test(inputText)) {\n        console.log(\"[handleDynamicCmd] No dynamicCmd section found. Parsing dynamic variables only.\");\n        msg.payload = parseDynamicVariables(inputText, msg, context);\n        msg.outputType = 1; // Send to output1 by default\n        console.log(`[handleDynamicCmd] Returning msg: ${JSON.stringify(msg)}`);\n        return msg;\n    }\n\n    try {\n        console.log(\"[handleDynamicCmd] Parsing input text.\");\n        let dynamicCmd = parseInputText(inputText);\n        console.log(`[handleDynamicCmd] Parsed dynamicCmd: ${JSON.stringify(dynamicCmd)}`);\n        let finalResult;\n        let outputType = 0; // Default to no output\n\n        if (!dynamicCmd || !dynamicCmd.sections || dynamicCmd.sections.length === 0) {\n            console.log(\"[handleDynamicCmd] No valid dynamicCmd sections found after parsing. Proceeding with dynamicVars parsing.\");\n            finalResult = parseDynamicVariables(inputText, msg, context);\n            outputType = 1; // Assume output1 for simple dynamic variable parsing\n            console.log(`[handleDynamicCmd] Dynamic variables parsed. Result: ${finalResult}`);\n        } else {\n            console.log(\"[handleDynamicCmd] dynamicCmd section found. Executing commands block by block.\");\n            const resultData = await executeCommandsBlockByBlock(dynamicCmd, context, msg, node);\n            finalResult = resultData.result;\n            msg.dynamicCmd = resultData.dynamicCmd;\n            console.log(`[handleDynamicCmd] Commands executed. Result: ${JSON.stringify(finalResult)}`);\n\n            // Determine output type based on the last command executed\n            const lastSection = dynamicCmd.sections[dynamicCmd.sections.length - 1];\n            const lastCommand = lastSection.commands[lastSection.commands.length - 1];\n            if (lastCommand.type === 'mainPromptCmd') {\n                outputType = 1;\n            } else if (lastCommand.type === 'sidePromptCmd') {\n                outputType = 2;\n            }\n            console.log(`[handleDynamicCmd] Determined output type: ${outputType}`);\n        }\n\n        msg.payload = finalResult || inputText;\n        msg.outputType = outputType;\n        console.log(`[handleDynamicCmd] Final msg payload: ${msg.payload}`);\n        console.log(`[handleDynamicCmd] Final msg outputType: ${msg.outputType}`);\n    } catch (error) {\n        console.error(`[handleDynamicCmd] Error occurred: ${error.message}`);\n        console.error(`[handleDynamicCmd] Error stack: ${error.stack}`);\n        msg.payload = `Error occurred: ${error.message}`;\n        msg.outputType = 1; // Send errors to output1\n    }\n\n    console.log(\"[handleDynamicCmd] Finished processing. Returning message.\");\n    console.log(`[handleDynamicCmd] Returning msg: ${JSON.stringify(msg)}`);\n    return msg;\n}\n\n// 8. Main function to process the incoming message\nasync function processMessage(msg, node) {\n    // Update the latest message\n    global.latestMsg = msg;\n    console.log(\"[processMessage] Starting processMessage function.\");\n    console.log(`[processMessage] Input msg: ${JSON.stringify(msg)}`);\n\n    // Check if this is a sidePrompt completion message\n    if (msg.sidePromptStatus === \"done\") {\n        console.log(\"[processMessage] Received sidePrompt completion message.\");\n        setSidePromptCompletion(msg.payload);\n        return [null, null]; // Don't send any message for sidePrompt completion\n    }\n\n    console.log(\"[processMessage] Processing message with handleDynamicCmd.\");\n    let processedMsg = await handleDynamicCmd(msg.payload, msg, node);\n    console.log(`[processMessage] Processed msg: ${JSON.stringify(processedMsg)}`);\n\n    // Send the processed result to the appropriate output\n    if (processedMsg.outputType === 1) {\n        console.log(\"[processMessage] Sending to output1.\");\n        return [processedMsg, null]; // Send to output1\n    } else if (processedMsg.outputType === 2) {\n        console.log(\"[processMessage] Sending to output2.\");\n        return [null, processedMsg]; // Send to output2\n    } else {\n        console.log(\"[processMessage] No specific output type. Not sending any message.\");\n        return [null, null]; // Don't send any message\n    }\n}\n\n// 9. Main execution\nasync function main(msg) {\n    try {\n        const [output1, output2] = await processMessage(msg, this);\n        if (output1) node.send([output1, null]);\n        if (output2) node.send([null, output2]);\n    } catch (error) {\n        node.error(\"Error processing message: \" + error.message, msg);\n    }\n}\n\n// 10. Call the main function\nreturn main(msg);",
        "outputs": 3,
        "timeout": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 910,
        "y": 400,
        "wires": [
            [
                "c1e5648ebbc40637"
            ],
            [
                "0121c003d821a526"
            ],
            []
        ]
    },
    {
        "id": "f808f68ecb565594",
        "type": "link in",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "SC: Out",
        "links": [
            "cebfdb8ca306df09"
        ],
        "x": 425,
        "y": 460,
        "wires": [
            [
                "ecb21505f2b71198"
            ]
        ]
    },
    {
        "id": "cebfdb8ca306df09",
        "type": "link out",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "SC: In",
        "mode": "link",
        "links": [
            "f808f68ecb565594"
        ],
        "x": 1285,
        "y": 480,
        "wires": []
    },
    {
        "id": "0121c003d821a526",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "Sequence Controller Side",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet prompts = context.get('prompts') || [];\nlet currentStep = context.get('currentStep') || 0;\n\nfunction processPrompts(inputPrompts) {\n    console.log('[Sequence Controller Side] Processing input prompts');\n\n    if (!Array.isArray(inputPrompts)) {\n        console.error('[Sequence Controller Side] Error: Input is not an array');\n        return [];\n    }\n\n    const processedPrompts = inputPrompts.map((prompt, index) => ({\n        title: `Prompt ${index + 1}`,\n        body: prompt,\n        sidePrompt: []\n    }));\n\n    context.set('prompts', processedPrompts);\n    console.log(`[Sequence Controller Side] Processed ${processedPrompts.length} prompts`);\n    node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${processedPrompts.length} prompts` });\n\n    return processedPrompts;\n}\n\nfunction processNextPrompt() {\n    console.log(`[Sequence Controller Side] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < prompts.length) {\n        const msg = {\n            currentStep: currentStep,\n            totalSteps: prompts.length,\n            promptConfig: prompts[currentStep],\n            payload: prompts[currentStep].body,\n            sidePrompt: prompts[currentStep].sidePrompt,\n            _continuation: true\n        };\n        console.log(`[Sequence Controller Side] Sending prompt ${currentStep + 1} of ${prompts.length}`);\n        node.send(msg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${prompts.length}` });\n        currentStep++;\n        context.set('currentStep', currentStep);\n    } else {\n        console.log('[Sequence Controller Side] All prompts processed. Stopping.');\n        node.send([null, { payload: \"Sequence Complete\", sidePromptStatus: \"done\" }]);\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[Sequence Controller Side] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[Sequence Controller Side] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    prompts = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('prompts', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, Prompts Unloaded\" });\n}\n\n// Main logic\nif (msg._continuation) {\n    console.log(`[Sequence Controller Side] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.status === \"done\" || msg.status === \"End of Sequence\") {\n            console.log('[Sequence Controller Side] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            processNextPrompt();\n        } else if (msg.status === \"error\") {\n            console.log(`[Sequence Controller Side] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[Sequence Controller Side] Received new message with payload: ${JSON.stringify(msg.payload)}`);\n    if (msg.status === \"start\") {\n        if (Array.isArray(msg.payload)) {\n            prompts = processPrompts(msg.payload);\n            startProcessing();\n        } else {\n            console.log('[Sequence Controller Side] Invalid input: payload is not an array of prompts');\n            node.status({ fill: \"red\", shape: \"ring\", text: \"Invalid input\" });\n        }\n    } else if (msg.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.status === \"Sequence Complete\") {\n        node.send([null, { ...msg, sidePromptStatus: \"done\" }]);\n        stopProcessing();\n    } else {\n        console.log(`[Sequence Controller Side] Unrecognized message: ${JSON.stringify(msg)}`);\n    }\n}\n\nreturn null;",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 910,
        "y": 500,
        "wires": [
            [
                "4f260a029e80f953"
            ],
            [
                "a142d35aa4e7a75c"
            ]
        ]
    },
    {
        "id": "4f260a029e80f953",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "g": "25b6777d38d17718",
        "name": "Run Prompt Side",
        "func": "console.log('[Run Prompt Side] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPrompt = context.runPrompt || {};\ncontext.runPrompt.isStopRequested = msg.payload === \"stop\";\n\nconsole.log('context.runPrompt:', context.runPrompt);\n\nlet browser, browserContext, currentPage;\nconsole.log('[Run Prompt Side] Initial state:', { browser, browserContext, currentPage });\n\nasync function connectAndSetupPage() {\n    console.log('[Run Prompt Side] Entering connectAndSetupPage');\n    if (!browser) {\n        console.log('[Run Prompt Side] Browser not initialized, connecting...');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        console.log('[Run Prompt Side] Browser connected');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt Side] Browser context obtained');\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n        console.log('[Run Prompt Side] Current page set');\n    }\n    //    console.log('[Run Prompt Side] Exiting connectAndSetupPage:', { browser, browserContext, currentPage });\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    console.log('[Run Prompt Side] Entering getCurrentPage');\n    if (!browserContext) {\n        console.log('[Run Prompt Side] Browser context not found, creating new one');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt Side] New browser context created');\n    }\n    const pages = await browserContext.pages();\n    console.log('[Run Prompt Side] Number of pages:', pages.length);\n    const currentPage = pages[pages.length - 1];\n    //console.log('[Run Prompt Side] Exiting getCurrentPage, current page:', currentPage);\n    return currentPage;\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n\n        if (shouldClick) {\n            await button.click();\n\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    console.log('[Run Prompt Side] Entering reloadPageIfNecessary:', { retryCount });\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        console.log('[Run Prompt Side] Should reload:', shouldReload);\n        shouldReload && await page.reload({ waitUntil: 'networkidle' });\n        console.log('[Run Prompt Side] Page reloaded:', shouldReload);\n    } catch (error) {\n        console.log(`[Run Prompt Side] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    console.log('[Run Prompt Side] Entering waitForResponseCompletion');\n    console.log('[Run Prompt Side] Initializing variables');\n\n    let previousLength = 0, currentLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    console.log(`[Run Prompt Side] Max stable count: ${maxStableCount}, Max wait time: ${maxWaitTime}ms`);\n\n    while (Date.now() - startTime < maxWaitTime) {\n        console.log(`[Run Prompt Side] Elapsed time: ${Date.now() - startTime}ms`);\n\n        if (context.runPrompt.isStopRequested) {\n            console.log('[Run Prompt Side] Stop requested. Halting response completion.');\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            console.log('[Run Prompt Side] Attempting to get current page');\n            const page = await getCurrentPage();\n            console.log('[Run Prompt Side] Successfully got current page');\n\n            // Check for scroll-to-bottom button and click if visible\n            console.log('[Run Prompt Side] Checking for scroll-to-bottom button');\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                console.log('[Run Prompt Side] Scroll-to-bottom button clicked, waiting for scroll animation');\n                await page.waitForTimeout(1000); // Wait for scroll animation\n                console.log('[Run Prompt Side] Scroll animation wait complete');\n            } else {\n                console.log('[Run Prompt Side] Scroll-to-bottom button not found or not clicked');\n            }\n\n            console.log('[Run Prompt Side] Waiting for article selector');\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            console.log('[Run Prompt Side] Article selector found');\n\n            console.log('[Run Prompt Side] Querying for articles');\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n            console.log(`[Run Prompt Side] Found ${articles.length} articles`);\n\n            if (articles.length === 0) {\n                console.log('[Run Prompt Side] No articles found, waiting...');\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt Side] Attempting to extract content from last article');\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n                console.log('[Run Prompt Side] Content extracted successfully');\n            } catch (error) {\n                console.log('[Run Prompt Side] Error extracting content:', error.message);\n                console.log('[Run Prompt Side] Falling back to article.innerText()');\n                responseText = await lastArticle.innerText();\n                console.log('[Run Prompt Side] Fallback content extraction complete');\n            }\n\n            currentLength = responseText.length;\n            console.log(`[Run Prompt Side] Current response length: ${currentLength}`);\n            if (currentLength == 0) {\n                console.log('[Run Prompt Side] No content found in the response');\n            }\n\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n            console.log(`[Run Prompt Side] Is response stable: ${isStable}, Stable count: ${stableCount}`);\n\n            if (stableCount >= maxStableCount) {\n                console.log('[Run Prompt Side] Response appears to be complete');\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            console.log('[Run Prompt Side] Waiting for 2 seconds before next iteration');\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            console.log(`[Run Prompt Side] Error in waitForResponseCompletion: ${error.message}`);\n            console.log('[Run Prompt Side] Error stack:', error.stack);\n            console.log('[Run Prompt Side] Waiting for 3 seconds before retrying');\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    console.log('[Run Prompt Side] Max wait time exceeded. Returning current response.');\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    console.log('[Run Prompt Side] Entering extractResponseText');\n    let responseText = '';\n    let lastArticle;\n\n    try {\n        // Find all articles within the h-full div\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        console.log(`[Run Prompt Side] Found ${articles.length} articles`);\n\n        if (articles.length > 0) {\n            // Get the last article\n            lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt Side] Selected the last article');\n        } else {\n            throw new Error('No articles found');\n        }\n\n        // Find and click the copy button\n        const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n        if (copyButton) {\n            await copyButton.click();\n            await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n\n            // Get clipboard contents\n            responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            console.log('[Run Prompt Side] Response extracted from clipboard');\n        } else {\n            console.log('[Run Prompt Side] Copy button not found, falling back to original method');\n            const markdownDiv = await lastArticle.$('div.markdown');\n            if (markdownDiv) {\n                responseText = await markdownDiv.innerText();\n            } else {\n                throw new Error('Markdown div not found');\n            }\n        }\n    } catch (error) {\n        console.log('[Run Prompt Side] Error extracting content:', error.message);\n        try {\n            if (!lastArticle) {\n                lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n                if (!lastArticle) {\n                    throw new Error('Unable to find last article');\n                }\n            }\n            const textBaseElement = await lastArticle.$('.text-base');\n            if (textBaseElement) {\n                responseText = await textBaseElement.innerText();\n                console.log('[Run Prompt Side] Response extracted using alternative selector');\n            } else {\n                throw new Error('Alternative selector not found');\n            }\n        } catch (innerError) {\n            console.log('[Run Prompt Side] Alternative selector also failed, using entire article content');\n            if (lastArticle) {\n                responseText = await lastArticle.innerText();\n            } else {\n                console.log('[Run Prompt Side] Failed to extract any content');\n                responseText = '';\n            }\n        }\n    }\n\n    console.log('[Run Prompt Side] Exiting extractResponseText, response length:', responseText.length);\n    return responseText;\n}\n\nasync function stopGeneration() {\n    console.log('[Run Prompt Side] Entering stopGeneration');\n    context.runPrompt.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n    console.log('[Run Prompt Side] Exiting stopGeneration');\n}\n\nfunction clearStopRequestedState() {\n    context.runPrompt.isStopRequested = false;\n    console.log('[Run Prompt Side] Stop requested state cleared.');\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close().then(() => console.log('[Run Prompt Side] Browser closed'));\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage  // Set _continuation to true for the last message\n    };\n\n    const secondOutput = {\n        ...msg,\n        payload: result.payload,\n        status: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage === true\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPrompt() {\n    console.log('[Run Prompt Side] Entering runPrompt');\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        console.log('[Run Prompt Side] Got current page in runPrompt');\n\n        // ... (existing code for new chat button)\n        console.log('[Run Prompt Side] Full Msg:', msg);\n        const promptText = msg.payload || 'Give me a recipe for biscuits';\n        console.log('[Run Prompt Side] Entering prompt:', promptText);\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n\n        // Handle sidePrompt if present\n        if (msg.sidePrompt && msg.sidePrompt.length > 0) {\n            console.log('[Run Prompt Side] Handling sidePrompt');\n            const sidePromptText = msg.sidePrompt.join('\\n');\n            await page.evaluate((text) => {\n                const textarea = document.querySelector('#prompt-textarea');\n                textarea.value += '\\n\\n' + text;\n                textarea.dispatchEvent(new Event('input', { bubbles: true }));\n            }, sidePromptText);\n        }\n\n        await page.click('button[data-testid=\"send-button\"]');\n        console.log('[Run Prompt Side] Sent prompt');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n        console.log('[Run Prompt Side] Exiting runPrompt');\n        return responseText;\n    } catch (error) {\n        console.log(`[Run Prompt Side] Error in runPrompt: ${error.message}`);\n        console.log('[Run Prompt Side] Error stack:', error.stack);\n        throw error;\n    }\n}\n\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPrompt.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPrompt();\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt Side] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    console.log('This is the last step');\n    return msg.currentStep === msg.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    }; \n}\n\nfunction handleError(error) {\n    return {\n        payload: 'Error occurred: ' + error.message,\n        status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n        error: error.message\n    };\n}\n\nasync function executeScript(msg) {\n    console.log('[Run Prompt Side] Entering executeScript');\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n        \n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n            console.log('last step result: ', result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\n\n\nexecuteScript(msg);\n\nreturn null;\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 23,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 910,
        "y": 600,
        "wires": [
            [],
            [
                "0121c003d821a526"
            ],
            []
        ]
    },
    {
        "id": "aa702ffd9a7ae1f9",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "name": "inputConditionals",
        "func": "// Input Handler\nconst flowContext = flow.get('flowContext') || {};\n\n// Update the latest message\nflowContext.latestMsg = msg;\nflow.set('flowContext', flowContext);\n\nconsole.log(\"[inputConditionals] Starting inputConditionals function.\");\nconsole.log(`[inputConditionals] Input msg: ${JSON.stringify(msg)}`);\n\n// Case: Stop message\nif (msg.status === \"stop\") {\n    console.log(\"[inputConditionals] Received stop message.\");\n    return null; // Send sidePrompt completion to output2\n}\n\n// Case: sidePrompt completion message\nif (msg.status === \"sidePromptCmdDone\") {\n    console.log(\"[inputConditionals] Received sidePrompt completion message.\");\n    flow.set('waitingForSidePrompt', false);\n    flow.set('sidePromptResult', msg.payload);\n    return null;\n}\n\n// Case: dynamicCmd message\nif (msg.payload && typeof msg.payload === 'string' && msg.payload.includes('dynamicCmd')) {\n    return msg; // Send dynamicCmd messages to mainProcessor\n}\n\n// Case: Default non-dynamicCmd\nif (msg.totalSteps){\nreturn msg;\n}\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 590,
        "y": 940,
        "wires": [
            [
                "18d88a72cf4ea989"
            ]
        ],
        "info": "# processMessage Function Breakdown\r\n\r\n## 1. Input Phase\r\n- **Always executed**\r\n- Update `flowContext` with latest message\r\n- Log function start and input message\r\n\r\n## 2. Processing Phase\r\n\r\n### Case 1: Regular message (most common)\r\n- **Condition:** Message doesn't meet any special conditions\r\n- **Action:** Pass message through unchanged\r\n- **Output:** First output (index 0)\r\n\r\n### Case 2: dynamicCmd message (common)\r\n- **Condition:** `msg.payload` exists, is a string, and contains \"dynamicCmd\"\r\n- **Action:** Pass message through unchanged\r\n- **Output:** First output (index 0)\r\n\r\n### Case 3: sidePrompt completion (less common)\r\n- **Condition:** `msg.sidePromptStatus` equals \"done\"\r\n- **Action:** \r\n  - Update flow variables (`waitingForSidePrompt`, `sidePromptResult`, `flowContext`)\r\n  - Log receipt of sidePrompt completion\r\n- **Output:** Second output (index 1)\r\n\r\n### Case 4: Stop message (edge case)\r\n- **Condition:** `msg.status` equals \"stop\"\r\n- **Action:** Log receipt of stop message\r\n- **Output:** No output (all null)\r\n\r\n## 3. Output Phase\r\n- Determine final output based on processing phase\r\n- Return array with message in appropriate index:\r\n  - [message, null, null] for first output\r\n  - [null, message, null] for second output\r\n  - [null, null, null] for stop message"
    },
    {
        "id": "18d88a72cf4ea989",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "name": "initialParser",
        "func": "/**\n * Processes a single line of the input text.\n * @param {string} line - The line to process\n * @param {Object} dynamicCmd - The current state of the dynamicCmd object\n * @param {Object} currentCommand - The current command being processed\n * @param {boolean} isCapturingNestedCommand - Whether we're currently capturing a nested command\n * @param {string} nestedCommandBuffer - Buffer for storing nested command\n * @returns {Object} Updated state object\n */\nfunction processLine(line, dynamicCmd, currentCommand, isCapturingNestedCommand, nestedCommandBuffer) {\n    // Remove comments and trim whitespace\n    line = line.replace(/\\/\\/.*$/, '').trim();\n\n    // Control flow based on line content\n    if (line === 'dynamicCmd') {\n        // Start a new command set\n        dynamicCmd.sections.push({ type: 'commandSet', commands: [] });\n    } else if (line === '- commandSet') {\n        // Ignore this line\n    } else if (line.startsWith('- `')) {\n        // Start capturing a nested command\n        isCapturingNestedCommand = true;\n        nestedCommandBuffer = line.substring(3);\n    } else if (isCapturingNestedCommand) {\n        if (line.endsWith('`')) {\n            // End of nested command\n            nestedCommandBuffer += line.substring(0, line.length - 1);\n            currentCommand.commands.push(nestedCommandBuffer);\n            isCapturingNestedCommand = false;\n            nestedCommandBuffer = '';\n        } else {\n            // Continue capturing nested command\n            nestedCommandBuffer += line + '\\n';\n        }\n    } else {\n        const mainCommandMatch = line.match(/^-\\s*(\\w+)(\\d+)/);\n        if (mainCommandMatch) {\n            // Start a new main command\n            const [, cmdType, cmdNumber] = mainCommandMatch;\n            currentCommand = { type: cmdType, number: cmdNumber, commands: [] };\n            dynamicCmd.sections[dynamicCmd.sections.length - 1].commands.push(currentCommand);\n        } else if (line.startsWith('-') && currentCommand) {\n            // Add a sub-command to the current main command\n            currentCommand.commands.push(line.substring(1).trim());\n        }\n    }\n\n    return { dynamicCmd, currentCommand, isCapturingNestedCommand, nestedCommandBuffer };\n}\n\n/**\n * Parses the entire input text into a structured dynamicCmd object.\n * @param {string} inputText - The input text to parse\n * @returns {Object} The parsed dynamicCmd object\n */\nfunction parseInputText(inputText) {\n    // Split input into lines\n    const lines = inputText.split('\\n');\n\n    // Initialize parsing state\n    let dynamicCmd = { sections: [] };\n    let currentCommand = null;\n    let isCapturingNestedCommand = false;\n    let nestedCommandBuffer = '';\n\n    // Process each line\n    lines.forEach((line) => {\n        // Update state based on processed line\n        ({ dynamicCmd, currentCommand, isCapturingNestedCommand, nestedCommandBuffer } =\n            processLine(line, dynamicCmd, currentCommand, isCapturingNestedCommand, nestedCommandBuffer));\n    });\n\n    return dynamicCmd;\n}\n\n/**\n * Main entry point for processing messages in Node-RED.\n * @param {Object} msg - The message object from Node-RED\n * @returns {Array} Array containing the processed message and two null values\n */\nfunction processMessage(msg) {\n    if (msg.payload && typeof msg.payload === 'string' && msg.payload.includes('dynamicCmd')) {\n        // Parse the payload if it's a string containing 'dynamicCmd'\n        msg.dynamicCmd = parseInputText(msg.payload);\n    } else {\n        // Set dynamicCmd to false for non-matching messages\n        msg.dynamicCmd = false;\n    }\n    return [msg, null, null];\n}\n\n// Node-RED function node execution\nreturn processMessage(msg);",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 1000,
        "wires": [
            [
                "90f7d654ff1d06e2"
            ]
        ],
        "info": "Function parseInputText(inputText):\r\n    Split inputText into lines\r\n    Initialize dynamicCmd object\r\n\r\n    For each line in lines:\r\n        Remove comments from line\r\n        \r\n        If line is 'dynamicCmd':\r\n            Start new command set in dynamicCmd\r\n        Else if line starts with '- ' and matches command pattern:\r\n            Create new command in current command set\r\n        Else if line starts with '- `':\r\n            Start capturing multi-line command\r\n        Else if currently capturing multi-line command:\r\n            If line ends with '`':\r\n                Finish capturing multi-line command\r\n            Else:\r\n                Continue capturing multi-line command\r\n        Else if line starts with '-':\r\n            Add sub-command to current command\r\n\r\n    Return dynamicCmd object\r\n\r\n// Node-RED function node entry point\r\nIf msg.payload contains 'dynamicCmd':\r\n    Parse msg.payload\r\n    Store result in flow context and msg.dynamicCmd\r\n    Return [msg, null, null]\r\nElse:\r\n    Set msg.dynamicCmd to false\r\n    Return [msg, null, null]"
    },
    {
        "id": "90f7d654ff1d06e2",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "name": "blockExecutor",
        "func": "console.log('[blockExecutor] Starting execution');\n\nconst flowContext = flow.get('flowContext') || {};\n\n/**\n * Waits for a processed result to be ready in the flow context.\n * @param {number} timeout - Maximum time to wait in milliseconds\n * @returns {Promise<any>} The processed result\n */\nasync function waitForProcessedResult(timeout = 30000) {\n    console.log('[waitForProcessedResult] Waiting for processed result');\n    const startTime = Date.now();\n\n    /**\n     * Checks if the result is ready in the flow context.\n     * @returns {Object|null} The result object if ready, null otherwise\n     */\n    function checkResultReady() {\n        const currentContext = flow.get('flowContext') || {};\n        if (currentContext.processedResultReady) {\n            console.log('[waitForProcessedResult] Result ready');\n            currentContext.processedResultReady = false;\n            flow.set('flowContext', currentContext);\n            return currentContext.processedResult;\n        }\n        return null;\n    }\n\n    /**\n     * Checks if the timeout has been exceeded.\n     * @throws {Error} If the timeout is exceeded\n     */\n    function checkTimeout() {\n        if (Date.now() - startTime > timeout) {\n            throw new Error('Timeout waiting for processed result');\n        }\n    }\n\n    /**\n     * Waits for a short period before the next check.\n     * @returns {Promise<void>}\n     */\n    async function waitBeforeNextCheck() {\n        await new Promise(resolve => setTimeout(resolve, 500));\n    }\n\n    /**\n     * Main loop to wait for the processed result.\n     * @returns {Promise<any>} The processed result\n     */\n    async function waitLoop() {\n        while (true) {\n            const result = checkResultReady();\n            if (result !== null) {\n                return result;\n            }\n            checkTimeout();\n            await waitBeforeNextCheck();\n        }\n    }\n\n    // Execute the wait loop\n    return await waitLoop();\n}\n\n/**\n * Executes a single command and waits for its result.\n * @param {Object} command - The command to execute\n * @returns {Promise<any>} The result of the command execution\n */\nasync function executeCommand(command) {\n    node.send({\n        dynamicCmd: true,\n        command: command,\n        triggerCommandExecution: Date.now()\n    });\n\n    return await waitForProcessedResult(60000);\n}\n\n/**\n * Executes all commands in a dynamicCmd structure.\n * @param {Object} dynamicCmd - The dynamicCmd structure containing commands to execute\n * @returns {Promise<string>} The final result of all command executions\n */\nasync function executeBlockCommands(dynamicCmd) {\n    /**\n     * Initializes and updates the flow context.\n     * @returns {Object} The initialized flow context\n     */\n    function initializeFlowContext() {\n        let flowContext = flow.get('flowContext') || {};\n        flowContext.previousResponse = flowContext.previousResponse || '[Previous response not available]';\n        flow.set('flowContext', flowContext);\n        return flowContext;\n    }\n\n    /**\n     * Executes a single command and updates the flow context.\n     * @param {Object} command - The command to execute\n     * @param {Object} flowContext - The current flow context\n     */\n    async function executeSingleCommand(command, flowContext) {\n        if (!command?.type) return;\n\n        try {\n            const result = await executeCommand(command);\n            command.result = result;\n            flowContext[`${command.type}${command.number}Result`] = result;\n            flow.set('flowContext', flowContext);\n            command.processedResult = result;\n        } catch (error) {\n            console.error(`[executeBlockCommands] Error executing ${command.type}:`, error);\n            command.processedResult = `[Error: ${error.message}]`;\n        }\n\n        await new Promise(resolve => setTimeout(resolve, 100));\n    }\n\n    /**\n     * Executes all commands in a section.\n     * @param {Object} section - The section containing commands\n     * @param {Object} flowContext - The current flow context\n     */\n    async function executeSection(section, flowContext) {\n        if (!section?.commands?.length) return;\n\n        for (const command of section.commands) {\n            await executeSingleCommand(command, flowContext);\n        }\n    }\n\n    /**\n     * Main execution logic for block commands.\n     */\n    async function executeMain() {\n        if (!dynamicCmd?.sections?.length) {\n            throw new Error(\"Invalid dynamicCmd structure\");\n        }\n\n        let flowContext = initializeFlowContext();\n\n        for (const section of dynamicCmd.sections) {\n            await executeSection(section, flowContext);\n        }\n\n        let finalResult = flowContext.mainPromptCmd1Result;\n        msg.dynamicCmdComplete = true;\n        return finalResult;\n    }\n\n    // Execute the main logic\n    return await executeMain();\n}\n\n/**\n * Parses the incoming message and categorizes it.\n * @param {Object} msg - The incoming message\n * @returns {Object} Categorized message object\n */\nfunction parseIncomingMessage(msg) {\n    if (msg.dynamicCmd && !msg.currentCommand) {\n        console.log('[parseIncomingMessage] New dynamic command detected');\n        return { type: 'dynamicCmd', data: msg.dynamicCmd };\n    } else if (msg.type === 'processedResult') {\n        console.log('[parseIncomingMessage] Processed result received');\n        return { type: 'processedResult', data: msg.data, command: msg.command };\n    } else {\n        console.log('[parseIncomingMessage] Pass through message');\n        return { type: 'passThrough', data: msg };\n    }\n}\n\n/**\n * Handles different types of messages based on their category.\n */\nasync function handleMessage() {\n    console.log('[handleMessage] Starting message handling');\n    try {\n        const parsedMsg = parseIncomingMessage(msg);\n\n        switch (parsedMsg.type) {\n            case 'dynamicCmd':\n                await handleDynamicCommand(parsedMsg.data);\n                break;\n            case 'processedResult':\n                handleProcessedResult(parsedMsg.data);\n                break;\n            default:\n                console.log('[handleMessage] Passing through message');\n                node.send(msg);\n        }\n    } catch (error) {\n        console.error(\"[handleMessage] Error:\", error);\n        node.error(\"Error in handleMessage: \" + error.message, msg);\n    }\n}\n\n/**\n * Handles the execution of a dynamic command.\n * @param {Object} data - The dynamic command data\n */\nasync function handleDynamicCommand(data) {\n    if (!data) throw new Error(\"Invalid dynamicCmd data\");\n\n    console.log('[handleDynamicCommand] Executing new dynamic command');\n    try {\n        const result = await executeBlockCommands(data);\n    } catch (error) {\n        console.error(\"[handleDynamicCommand] Error processing commands:\", error);\n        node.error(\"Error processing commands: \" + error.message, msg);\n    }\n}\n\n/**\n * Handles the processed result.\n * @param {any} data - The processed result data\n */\nfunction handleProcessedResult(data) {\n    console.log('[handleProcessedResult] Setting processed result');\n}\n\n// Main execution flow\nconsole.log('[blockExecutor] Starting execution');\nhandleMessage().then(() => console.log('[blockExecutor] Execution completed'));\n\nreturn null;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 820,
        "y": 1060,
        "wires": [
            [
                "668748b9bf4e46ef"
            ]
        ],
        "info": "# Block Executor Control Flow\r\n\r\n1. **Initialization**\r\n   - Log start of execution\r\n   - Retrieve or initialize `flowContext`\r\n\r\n2. **Utility Functions Definition**\r\n   - `sendFlowUpdate`: Send flow updates to another node\r\n   - `helper_waitProcessing`: Wait for processed result\r\n\r\n3. **Main Functions Definition**\r\n   - `executeCommand`: Send a command and wait for processing\r\n   - `executeBlockCommands`: Process a set of commands organized in sections\r\n   - `parseIncomingMessage`: Categorize incoming messages\r\n   - `handleMessage`: Main entry point for processing messages\r\n\r\n4. **Main Execution**\r\n   - Call `handleMessage()`\r\n\r\n5. **Message Handling (in `handleMessage`)**\r\n   - Parse incoming message\r\n   - Based on message type:\r\n     a. 'newDynamicCmd': \r\n        - Call `executeBlockCommands`\r\n        - On completion, update flow and send result\r\n     b. 'processedResult': \r\n        - Update flow variables\r\n     c. Other types: \r\n        - Pass message through\r\n\r\n6. **Block Command Execution (in `executeBlockCommands`)**\r\n   - Iterate through sections and commands\r\n   - For each command:\r\n     - Call `executeCommand`\r\n     - Collect results and update flow variables\r\n\r\n7. **Command Execution (in `executeCommand`)**\r\n   - Send command\r\n   - Wait for processing using `helper_waitProcessing`\r\n\r\n8. **Completion**\r\n   - Log execution completion\r\n   - Return null\r\n\r\nThroughout: Use `sendFlowUpdate` for flow variable updates and extensive error handling and logging."
    },
    {
        "id": "668748b9bf4e46ef",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "name": "commandExecutor",
        "func": "// Command Executor Node\n\n// Utility function for logging\nconst log = (prefix, message, obj = null) => {\n    console.log(`[${prefix}] ${message}${obj ? ': ' + JSON.stringify(obj) : ''}`);\n};\n\n// Parse dynamic variables in text\nfunction parseDynamicVariables(text, context) {\n    log('parseDynamicVariables', 'Starting function with text:', text);\n\n    if (typeof text !== 'string') {\n        log('parseDynamicVariables', 'Warning: text is not a string. Type:', typeof text);\n        if (text === null || text === undefined) {\n            log('parseDynamicVariables', 'Text is null or undefined. Returning empty string.');\n            return '';\n        }\n        try {\n            text = String(text);\n            log('parseDynamicVariables', 'Converted text to string:', text);\n        } catch (error) {\n            log('parseDynamicVariables', 'Error converting text to string:', error);\n            return '[Error: Unable to process non-string input]';\n        }\n    }\n\n    if (!msg || typeof msg !== 'object') {\n        log('parseDynamicVariables', 'Warning: msg is not a valid object');\n        return text;\n    }\n\n    try {\n        // Handle previousResponse and sidePromptResult\n        if (context && context.latestMsg && typeof context.latestMsg.currentStep === 'number') {\n            const currentStep = context.latestMsg.currentStep;\n            const previousStep = currentStep - 1;\n            const previousResponseKey = `response${previousStep}`;\n\n            if (previousStep >= 0 && context.latestMsg[previousResponseKey]) {\n                const previousResponse = context.latestMsg[previousResponseKey];\n                log('parseDynamicVariables', `Found previousResponse for step ${previousStep}:`, previousResponse);\n                text = text.replace(/{previousResponse}/g, previousResponse);\n            } else {\n                log('parseDynamicVariables', `No previousResponse found for step ${previousStep}`);\n                text = text.replace(/{previousResponse}/g, '[Previous response not available]');\n            }\n        } else {\n            log('parseDynamicVariables', 'Unable to determine previousResponse from context');\n            text = text.replace(/{previousResponse}/g, '[Previous response not available]');\n        }\n\n        log('parseDynamicVariables', 'After replacing previousResponse:', text);\n        text = text.replace(/{sidePromptResult}/g, context.sidePromptResult || '[Side prompt result not available]');\n\n        // Replace $<<commandTypeNumberResult>>$\n        text = text.replace(/\\$<<(\\w+)(\\d+)Result>>\\$/g, (match, cmdType, cmdNumber) => {\n            const resultKey = `${cmdType}${cmdNumber}Result`;\n            const result = context[resultKey] || `[${resultKey} not available]`;\n            log('parseDynamicVariables', `Replaced ${match} with:`, result);\n            return result;\n        });\n\n        // Replace $<<execute(...)>>$\n        text = text.replace(/\\$<<execute\\((.*?)\\)>>\\$/g, (match, code) => {\n            log('parseDynamicVariables', 'Executing code:', code);\n            try {\n                code = code.replace(/;$/, '');\n                const safeContext = createSafeContext(msg, context);\n                const result = new Function('context', `with(context) { return (${code}); }`)(safeContext);\n                log('parseDynamicVariables', 'Execution result:', result);\n                return result !== undefined ? result : '[undefined]';\n            } catch (error) {\n                log('parseDynamicVariables', 'Error executing:', error.message);\n                return `[Error executing: ${error.message}]`;\n            }\n        });\n\n        // Handle regular msg property access\n        text = text.replace(/\\$<<([\\w.]+)>>\\$/g, (match, path) => {\n            log('parseDynamicVariables', 'Accessing msg property:', path);\n            const parts = path.split('.');\n            let value = msg;\n            for (const part of parts) {\n                if (value && typeof value === 'object' && part in value) {\n                    value = value[part];\n                } else {\n                    log('parseDynamicVariables', `Warning: ${path} not available in msg`);\n                    return `[${path} not available]`;\n                }\n            }\n            const result = typeof value === 'object' ? JSON.stringify(value) : String(value);\n            log('parseDynamicVariables', 'Msg property value:', result);\n            return result;\n        });\n\n        log('parseDynamicVariables', 'Final result:', text);\n        return text;\n    } catch (error) {\n        log('parseDynamicVariables', 'Unexpected error:', error);\n        return `[Error: ${error.message}]`;\n    }\n}\n\n\n// Create a safe context for command execution\nfunction createSafeContext(msg, context) {\n    return {\n        flow: {\n            get: (key) => {\n                const value = flow.get(key);\n                log('createSafeContext', `flow.get('${key}'):`, value);\n                return value;\n            },\n            set: (key, value) => {\n                log('createSafeContext', `flow.set('${key}'):`, value);\n                flow.set(key, value);\n            }\n        },\n        global: {\n            get: (key) => {\n                const value = global.get(key);\n                log('createSafeContext', `global.get('${key}'):`, value);\n                return value;\n            },\n            set: (key, value) => {\n                log('createSafeContext', `global.set('${key}'):`, value);\n                global.set(key, value);\n            }\n        },\n        msg: msg,\n        context: context\n    };\n}\n\n// Execute local command\nfunction executeLocalCmd(command, msg, context) {\n    log('executeLocalCmd', 'Executing local command:', command);\n    let result = '';\n    try {\n        const commandString = command.commands.join('\\n');\n        log('executeLocalCmd', 'Executing:', commandString);\n        const safeContext = createSafeContext(msg, context);\n        const wrappedCommand = `with(this) { ${commandString} }`;\n        const commandResult = new Function(wrappedCommand).call(safeContext);\n        result = commandResult !== undefined ? commandResult : '';\n    } catch (error) {\n        log('executeLocalCmd', 'Error:', error.message);\n        result = `[Error: ${error.message}]`;\n    }\n    log('executeLocalCmd', 'Result:', result);\n    return result;\n}\n\n// Execute compile or pack command\nfunction executeCompileOrPackCmd(command, msg, context) {\n    log('executeCompileOrPackCmd', 'Executing compile/pack command:', command);\n    let result = '';\n\n    if (command && Array.isArray(command.commands)) {\n        result = command.commands.map(cmd => {\n            return parseDynamicVariables(cmd, context);\n        }).join('\\n');\n    } else {\n        log('executeCompileOrPackCmd', 'Invalid command structure:', command);\n        result = '[Error: Invalid command structure]';\n    }\n\n    log('executeCompileOrPackCmd', 'Result:', result);\n    return result.trim();\n}\n\n// Execute main prompt command\nfunction executeMainPromptCmd(command, msg, context) {\n    log('executeMainPromptCmd', 'Executing main prompt command:', command);\n    const result = command.commands.map(cmd => parseDynamicVariables(cmd, context)).join('\\n');\n    log('executeMainPromptCmd', 'Result:', result);\n    return result;\n}\n\n// Wait for side prompt result\nfunction waitForSidePromptResult(timeout = 100000) {\n    log('waitForSidePromptResult', 'Starting to wait for side prompt result');\n    return new Promise((resolve, reject) => {\n        const startTime = Date.now();\n        const checkSidePromptResult = () => {\n            let sidePromptResult = flow.get('sidePromptResult') || {};\n            if (flow.get('waitingForSidePrompt') == false) {\n                log('waitForSidePromptResult', 'Side prompt result is ready');\n                resolve(sidePromptResult);\n            } else if (Date.now() - startTime > timeout) {\n                log('waitForSidePromptResult', 'Timeout reached while waiting for side prompt result');\n                reject(new Error('Timeout waiting for side prompt result'));\n            } else {\n                log('waitForSidePromptResult', 'Side prompt result not ready, checking again in 1000ms');\n                setTimeout(checkSidePromptResult, 1300);\n            }\n        };\n        checkSidePromptResult();\n    });\n}\n\n// Execute side prompt command\nasync function executeSidePromptCmd(command, msg, context) {\n    log('executeSidePromptCmd', 'Executing side prompt command:', command);\n    const sidePromptCommands = command.commands;\n\n    // Set flow level variable indicating side prompt processing\n    flow.set('waitingForSidePrompt', true);\n\n    // Execute side prompt commands\n    const result = sidePromptCommands.map(cmd => parseDynamicVariables(cmd, context));\n\n    log('executeSidePromptCmd', 'Sent side prompt, waiting for result');\n\n    try {\n        // Wait for the side prompt result\n        const sidePromptResult = await waitForSidePromptResult();\n\n        // Update flow context with side prompt result\n        context.sidePromptResult = sidePromptResult;\n        flow.set('flowContext', context);\n\n        log('executeSidePromptCmd', 'Received side prompt result:', sidePromptResult);\n        return sidePromptResult;\n    } catch (error) {\n        log('executeSidePromptCmd', 'Error waiting for side prompt result:', error);\n        return `[Error: ${error.message}]`;\n    } finally {\n        // Reset the processing flag\n        flow.set('waitingForSidePrompt', false);\n    }\n}\n\n// Execute command based on its type\nfunction executeCommand(command, context) {\n    log('executeCommand', 'Executing command:', command);\n    let result = '';\n\n    switch (command.type) {\n        case 'localCmd':\n            result = executeLocalCmd(command, msg, context);\n            break;\n        case 'compileCmd':\n        case 'packCmd':\n            result = executeCompileOrPackCmd(command, msg, context);\n            break;\n        case 'mainPromptCmd':\n            result = executeMainPromptCmd(command, msg, context);\n            break;\n        case 'sidePromptCmd':\n            result = executeSidePromptCmd(command, msg, context);\n            break;\n        default:\n            log('executeCommand', 'Unknown command type:', command.type);\n            result = `[Unknown command type: ${command.type}]`;\n    }\n\n    log('executeCommand', 'Result:', result);\n    return result;\n}\n\n// Determine output type based on command type\nfunction determineOutputType(commandType) {\n    switch (commandType) {\n        case 'sidePromptCmd': return 'sidePrompt';\n        case 'mainPromptCmd': return 'mainPrompt';\n        default: return 'dynamicCmd';\n    }\n}\n\n// Update flow context with command result\nfunction updateFlowContext(flowContext, command, result) {\n    flowContext.processedResult = result;\n    flowContext.processedResultReady = true;\n    flowContext[`${command.type}${command.number}Result`] = result;\n    flow.set('flowContext', flowContext);\n    log('updateFlowContext', `Updated flowContext with result for ${command.type}${command.number}`);\n}\n\n// Main execution function\nfunction main() {\n    log('main', 'Starting main function');\n\n    // Handle non-dynamic commands\n    if (!msg.dynamicCmd) {\n        log('main', 'Passing through non-dynamic command');\n        return { ...msg, outputType: 'passThrough' };\n    }\n\n    const { command, triggerCommandExecution } = msg;\n    log('main', 'Received command', command);\n    log('main', 'triggerCommandExecution', triggerCommandExecution);\n\n    // Handle invalid dynamic commands\n    if (!command || !triggerCommandExecution) {\n        log('main', 'Invalid dynamic command, passing through');\n        return msg;\n    }\n\n    // Process valid dynamic command\n    log('main', 'Processing dynamic command');\n    let finalResult, outputType = 'dynamicCmd';\n\n    try {\n        // Execute command and determine output type\n        finalResult = executeCommand(command, flow.get('flowContext') || {});\n        outputType = determineOutputType(command.type);\n    } catch (error) {\n        log('main', 'Error executing command', error);\n        finalResult = `[Error: ${error.message}]`;\n        outputType = 'error';\n    }\n\n    log('main', 'Final result', finalResult);\n    log('main', 'Output type', outputType);\n\n    // Update flow context\n    updateFlowContext(flow.get('flowContext') || {}, command, finalResult);\n\n    // Return processed result\n    return {\n        ...msg,\n        processedResult: { type: 'processedResult', data: finalResult, command },\n        outputType\n    };\n}\n\n// Main execution with error handling\ntry {\n    return main();\n} catch (error) {\n    log('commandExecutor', 'Error in main function', error);\n    return msg;\n}",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 830,
        "y": 1120,
        "wires": [
            [
                "171821de9aa7e4ab"
            ]
        ],
        "info": "# Command Executor Control Flow\r\n\r\n1. **Initialization**\r\n   - Log start of execution\r\n   - Initialize or retrieve `flowContext`\r\n\r\n2. **Utility Functions Definition**\r\n   - `parseDynamicVariables`: Parse and replace dynamic variables in text\r\n   - `createSafeContext`: Create a safe context for executing commands\r\n   - `executeLocalCmd`: Execute local commands\r\n   - `executeCompileOrPackCmd`: Execute compile or pack commands\r\n   - `executeMainPromptCmd`: Execute main prompt commands\r\n   - `waitForSidePromptResult`: Wait for side prompt results\r\n   - `executeSidePromptCmd`: Execute side prompt commands\r\n   - `executeCommand`: Main function to execute commands based on type\r\n\r\n3. **Main Function Definition**\r\n   - `main()`: Core logic for processing commands\r\n\r\n4. **Main Execution**\r\n   - Try-catch block to execute `main()` and handle any errors\r\n\r\n5. **Main Function Flow (`main()`)**\r\n   - Check if message contains a dynamic command\r\n   - If not, pass through the message with an output type\r\n   - If yes:\r\n     a. Extract command and trigger from message\r\n     b. Refresh `flowContext`\r\n     c. Process the command:\r\n        - Execute the command using `executeCommand()`\r\n        - Determine the output type based on command type\r\n        - Handle any errors during execution\r\n     d. Update `flowContext` with the result\r\n     e. Return processed result with output type\r\n\r\n6. **Command Execution (`executeCommand()`)**\r\n   - Switch based on command type:\r\n     - `localCmd`: Execute using `executeLocalCmd()`\r\n     - `compileCmd` or `packCmd`: Execute using `executeCompileOrPackCmd()`\r\n     - `mainPromptCmd`: Execute using `executeMainPromptCmd()`\r\n     - `sidePromptCmd`: Execute using `executeSidePromptCmd()`\r\n\r\n7. **Dynamic Variable Parsing (`parseDynamicVariables()`)**\r\n   - Handle `previousResponse` and `sidePromptResult`\r\n   - Replace command type number results\r\n   - Execute inline code within `$<<execute(...)>>$`\r\n   - Handle regular msg property access\r\n\r\n8. **Side Prompt Execution (`executeSidePromptCmd()`)**\r\n   - Set flow-level variable for side prompt processing\r\n   - Execute side prompt commands\r\n   - Send out message with side prompts\r\n   - Wait for side prompt result using `waitForSidePromptResult()`\r\n   - Update `flowContext` with the result\r\n\r\nThroughout: Extensive logging and error handling at each step"
    },
    {
        "id": "171821de9aa7e4ab",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "name": "outputHandler",
        "func": "// Output Handler Node\n\n// Utility function for logging\nconst log = (prefix, message, obj = null) => {\n    console.log(`[${prefix}] ${message}${obj ? ': ' + JSON.stringify(obj) : ''}`);\n};\n\n// Determine the type of output based on the message content\nfunction determineOutputType(msg) {\n    log('determineOutputType', 'Starting output type determination', msg);\n\n    // Check for invalid message\n    if (typeof msg !== 'object' || msg === null) {\n        log('determineOutputType', 'Invalid message object');\n        return 'passThrough';\n    }\n\n    // Check for explicitly set output type\n    if (msg.outputType) {\n        log('determineOutputType', `Output type explicitly set: ${msg.outputType}`);\n        return msg.outputType;\n    }\n\n    // Check processed result\n    if (msg.processedResult?.type === 'processedResult') {\n        const commandType = msg.processedResult.command?.type;\n        if (commandType === 'sidePromptCmd' || commandType === 'mainPromptCmd') {\n            log('determineOutputType', `${commandType} detected`);\n            return commandType === 'sidePromptCmd' ? 'sidePrompt' : 'mainPrompt';\n        }\n    }\n\n    // Check dynamic command\n    try {\n        const dynamicCmd = flow.get('dynamicCmd');\n        log('determineOutputType', 'DynamicCmd', dynamicCmd);\n        const lastCommand = dynamicCmd?.sections?.slice(-1)[0]?.commands?.slice(-1)[0];\n        if (lastCommand) {\n            log('determineOutputType', `Last command type: ${lastCommand.type}`);\n            if (lastCommand.type === 'sidePromptCmd' || lastCommand.type === 'mainPromptCmd') {\n                return lastCommand.type === 'sidePromptCmd' ? 'sidePrompt' : 'mainPrompt';\n            }\n        }\n    } catch (error) {\n        log('determineOutputType', 'Error checking dynamic command', error);\n    }\n\n    // Check for undefined dynamicCmd\n    if (typeof flow.get('dynamicCmd') === 'undefined') {\n        if (msg.sidePrompt === true) return 'sidePrompt';\n        if (msg.mainPrompt === true) return 'mainPrompt';\n    }\n\n    // Default to passThrough\n    log('determineOutputType', 'Defaulting to passThrough output type');\n    return 'passThrough';\n}\n\n// Handle passThrough output\nfunction handlePassThroughOutput(msg) {\n    log('handlePassThroughOutput', 'Handling passThrough output', msg);\n    return [msg, null, null];\n}\n\n// Handle side prompt output\nfunction handleSidePromptOutput(msg) {\n    log('handleSidePromptOutput', 'Handling side prompt output', msg);\n\n    let sidePromptContent;\n    if (msg.processedResult?.command?.type === 'sidePromptCmd' && Array.isArray(msg.processedResult.command.commands)) {\n        sidePromptContent = msg.processedResult.command.commands;\n    } else if (Array.isArray(msg.payload)) {\n        sidePromptContent = msg.payload;\n    } else {\n        sidePromptContent = [msg.payload];\n    }\n\n    const sidePromptMsg = {\n        ...msg,\n        status: \"start\",\n        sidePrompt: true,\n        payload: sidePromptContent,\n        sidePromptNumber: msg.processedResult?.command?.number,\n    };\n\n    log('handleSidePromptOutput', 'Formatted side prompt message', sidePromptMsg);\n    return [null, sidePromptMsg, null];\n}\n\n// Handle main prompt output\nfunction handleMainPromptOutput(msg) {\n    log('handleMainPromptOutput', 'Starting to handle main prompt output');\n\n    if (msg?.processedResult?.data) {\n        log('handleMainPromptOutput', 'Found processedResult.data, moving to payload');\n        msg.payload = msg.processedResult.data;\n    } else {\n        log('handleMainPromptOutput', 'processedResult.data not found in the message');\n    }\n\n    return [msg, null, null];\n}\n\n// Handle error output\nfunction handleErrorOutput(msg) {\n    log('handleErrorOutput', 'Handling error output', msg);\n    return [null, null, msg];\n}\n\n// Garbage collection\nfunction garbageCollect() {\n    log('garbageCollect', 'Starting garbage collection');\n    flow.keys().forEach(key => {\n        flow.set(key, undefined);\n        log('garbageCollect', `Cleared flow variable: ${key}`);\n    });\n    log('garbageCollect', 'Garbage collection completed');\n}\n\n// Main execution logic\nfunction processOutput(msg) {\n    log('Output Handler', 'Starting main execution logic');\n\n    // Check for parsed execution result\n    const parsedExecutionResult = flow.get('parsedExecutionResult');\n    if (parsedExecutionResult) {\n        log('Output Handler', 'parsedExecutionResult found', parsedExecutionResult);\n        msg.payload = parsedExecutionResult;\n    }\n\n    // Determine output type\n    const outputType = determineOutputType(msg);\n    log('Output Handler', `Determined output type: ${outputType}`);\n\n    // Garbage collection if dynamic command is completed\n    if (msg.dynamicCmd !== false && msg.dynamicCmdComplete === true) {\n        log('Output Handler', 'Dynamic command completed, triggering garbage collection');\n        garbageCollect();\n    }\n\n    // Store last output type\n    flow.set('lastOutputType', outputType);\n\n    // Handle output based on type\n    log('Output Handler', `Switching based on output type: ${outputType}`);\n    let result;\n    switch (outputType) {\n        case 'passThrough':\n            result = handlePassThroughOutput(msg);\n            break;\n        case 'dynamicCmd':\n            log('Output Handler', 'Handling dynamicCmd (no action)');\n            result = [null, null, null];\n            break;\n        case 'sidePrompt':\n            result = handleSidePromptOutput(msg);\n            break;\n        case 'mainPrompt':\n            result = handleMainPromptOutput(msg);\n            break;\n        case 'error':\n            result = handleErrorOutput(msg);\n            break;\n        default:\n            log('Output Handler', `Unknown output type: ${outputType}, treating as passThrough`);\n            result = handlePassThroughOutput(msg);\n    }\n\n    log('Output Handler', 'Final result', result);\n    return result;\n}\n\n// Execute the main function\nreturn processOutput(msg);\n",
        "outputs": 4,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1040,
        "y": 1200,
        "wires": [
            [],
            [],
            [],
            []
        ]
    },
    {
        "id": "938b48336b152540",
        "type": "comment",
        "z": "ecd378f1d3401d0d",
        "name": "Check Descriptions for Breakdown",
        "info": "",
        "x": 620,
        "y": 860,
        "wires": []
    },
    {
        "id": "2fc4acc2cf2e4f06",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "name": "Sequence Controller Side",
        "func": "// Use node context to persist state across messages\nlet isProcessing = context.get('isProcessing') || false;\nlet prompts = context.get('prompts') || [];\nlet currentStep = context.get('currentStep') || 0;\n\nfunction processPrompts(inputPrompts) {\n    console.log('[Sequence Controller Side] Processing input prompts');\n\n    if (!Array.isArray(inputPrompts)) {\n        console.error('[Sequence Controller Side] Error: Input is not an array');\n        return [];\n    }\n\n    const processedPrompts = inputPrompts.map((prompt, index) => ({\n        title: `Prompt ${index + 1}`,\n        body: prompt,\n        sidePrompt: []\n    }));\n\n    context.set('prompts', processedPrompts);\n    console.log(`[Sequence Controller Side] Processed ${processedPrompts.length} prompts`);\n    node.status({ fill: \"blue\", shape: \"dot\", text: `Loaded ${processedPrompts.length} prompts` });\n\n    return processedPrompts;\n}\n\nfunction processNextPrompt() {\n    console.log(`[Sequence Controller Side] Processing next prompt. Current step: ${currentStep + 1}`);\n    if (currentStep < prompts.length) {\n        const msg = {\n            currentStep: currentStep,\n            totalSteps: prompts.length,\n            promptConfig: prompts[currentStep],\n            payload: prompts[currentStep].body,\n            sidePrompt: prompts[currentStep].sidePrompt,\n            _continuation: true\n        };\n        console.log(`[Sequence Controller Side] Sending prompt ${currentStep + 1} of ${prompts.length}`);\n        node.send(msg);\n        node.status({ fill: \"blue\", shape: \"dot\", text: `Processing prompt ${currentStep + 1} of ${prompts.length}` });\n        currentStep++;\n        context.set('currentStep', currentStep);\n    } else {\n        console.log('[Sequence Controller Side] All prompts processed. Stopping.');\n        node.send([null, { payload: \"Sequence Complete\", status: \"sidePromptCmdDone\" }]);\n        stopProcessing();\n    }\n}\n\nfunction startProcessing() {\n    console.log('[Sequence Controller Side] Starting processing');\n    isProcessing = true;\n    currentStep = 0;\n    context.set('isProcessing', isProcessing);\n    context.set('currentStep', currentStep);\n    processNextPrompt();\n}\n\nfunction stopProcessing() {\n    console.log('[Sequence Controller Side] Stopping processing');\n    isProcessing = false;\n    currentStep = 0;\n    prompts = [];\n    context.set('isProcessing', false);\n    context.set('currentStep', 0);\n    context.set('prompts', []);\n    node.status({ fill: \"yellow\", shape: \"dot\", text: \"Sequence Stopped, Prompts Unloaded\" });\n}\n\n// Main logic\nif (msg._continuation) {\n    console.log(`[Sequence Controller Side] Received continuation message with payload: ${msg.payload}`);\n    if (isProcessing) {\n        if (msg.status === \"done\" || msg.status === \"End of Sequence\") {\n            console.log('[Sequence Controller Side] Received \"done\" or \"End of Sequence\" signal. Processing next prompt.');\n            processNextPrompt();\n        } else if (msg.status === \"error\") {\n            console.log(`[Sequence Controller Side] Error occurred: ${msg.error}. Stopping sequence.`);\n            stopProcessing();\n        }\n    }\n} else {\n    console.log(`[Sequence Controller Side] Received new message with payload: ${JSON.stringify(msg.payload)}`);\n    if (msg.status === \"start\") {\n        if (Array.isArray(msg.payload)) {\n            prompts = processPrompts(msg.payload);\n            startProcessing();\n        } else {\n            console.log('[Sequence Controller Side] Invalid input: payload is not an array of prompts');\n            node.status({ fill: \"red\", shape: \"ring\", text: \"Invalid input\" });\n        }\n    } else if (msg.status === \"stop\") {\n        stopProcessing();\n    } else if (msg.status === \"Sequence Complete\") {\n        node.send([null, { ...msg, status: \"sidePromptCmdDone\" }]);\n        stopProcessing();\n    } else {\n        console.log(`[Sequence Controller Side] Unrecognized message: ${JSON.stringify(msg)}`);\n    }\n}\n\nreturn null;",
        "outputs": 2,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "fs",
                "module": "fs"
            },
            {
                "var": "path",
                "module": "path"
            },
            {
                "var": "os",
                "module": "os"
            }
        ],
        "x": 1250,
        "y": 1340,
        "wires": [
            [
                "cfd9d1439896b953"
            ],
            []
        ]
    },
    {
        "id": "cfd9d1439896b953",
        "type": "function",
        "z": "ecd378f1d3401d0d",
        "name": "Run Prompt Side",
        "func": "console.log('[Run Prompt Side] Starting execution');\n\nnode.status({ fill: \"blue\", shape: \"dot\", text: \"Running...\" });\n\ncontext.runPrompt = context.runPrompt || {};\ncontext.runPrompt.isStopRequested = msg.payload === \"stop\";\n\nconsole.log('context.runPrompt:', context.runPrompt);\n\nlet browser, browserContext, currentPage;\nconsole.log('[Run Prompt Side] Initial state:', { browser, browserContext, currentPage });\n\nasync function connectAndSetupPage() {\n    console.log('[Run Prompt Side] Entering connectAndSetupPage');\n    if (!browser) {\n        console.log('[Run Prompt Side] Browser not initialized, connecting...');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        console.log('[Run Prompt Side] Browser connected');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt Side] Browser context obtained');\n        currentPage = browserContext.pages()[0] || await browserContext.newPage();\n        console.log('[Run Prompt Side] Current page set');\n    }\n    //    console.log('[Run Prompt Side] Exiting connectAndSetupPage:', { browser, browserContext, currentPage });\n    return { browser, browserContext, currentPage };\n}\n\nasync function getCurrentPage() {\n    console.log('[Run Prompt Side] Entering getCurrentPage');\n    if (!browserContext) {\n        console.log('[Run Prompt Side] Browser context not found, creating new one');\n        browser = await playwright.chromium.connectOverCDP('http://localhost:27000');\n        browserContext = browser.contexts()[0];\n        console.log('[Run Prompt Side] New browser context created');\n    }\n    const pages = await browserContext.pages();\n    console.log('[Run Prompt Side] Number of pages:', pages.length);\n    const currentPage = pages[pages.length - 1];\n    //console.log('[Run Prompt Side] Exiting getCurrentPage, current page:', currentPage);\n    return currentPage;\n}\n\nasync function clickButtonIfVisible(selector, waitForHidden = false) {\n    try {\n        const page = await getCurrentPage();\n        const button = await page.$(selector);\n        const shouldClick = button && await button.isVisible();\n\n        if (shouldClick) {\n            await button.click();\n\n            if (waitForHidden) {\n                await page.waitForSelector(selector, { state: 'hidden', timeout: 60000 });\n            }\n        }\n\n        return shouldClick;\n    } catch (error) {\n        return false;\n    }\n}\n\nasync function reloadPageIfNecessary(retryCount) {\n    console.log('[Run Prompt Side] Entering reloadPageIfNecessary:', { retryCount });\n    try {\n        const page = await getCurrentPage();\n        const shouldReload = [\n            retryCount > 0,\n            !await clickButtonIfVisible('button:has-text(\"Continue generating\")', true),\n            await page.$('#prompt-textarea').then(() => false).catch(() => true)\n        ].every(Boolean);\n\n        console.log('[Run Prompt Side] Should reload:', shouldReload);\n        shouldReload && await page.reload({ waitUntil: 'networkidle' });\n        console.log('[Run Prompt Side] Page reloaded:', shouldReload);\n    } catch (error) {\n        console.log(`[Run Prompt Side] Error in reloadPageIfNecessary: ${error.message}`);\n    }\n}\n\nasync function waitForResponseCompletion() {\n    console.log('[Run Prompt Side] Entering waitForResponseCompletion');\n    console.log('[Run Prompt Side] Initializing variables');\n\n    let previousLength = 0, currentLength = 0, stableCount = 0;\n    const maxStableCount = 3;\n    const maxWaitTime = 120000; // 2 minutes\n    const startTime = Date.now();\n    let responseText = '';\n\n    console.log(`[Run Prompt Side] Max stable count: ${maxStableCount}, Max wait time: ${maxWaitTime}ms`);\n\n    while (Date.now() - startTime < maxWaitTime) {\n        console.log(`[Run Prompt Side] Elapsed time: ${Date.now() - startTime}ms`);\n\n        if (context.runPrompt.isStopRequested) {\n            console.log('[Run Prompt Side] Stop requested. Halting response completion.');\n            await stopGeneration();\n            clearStopRequestedState();\n            return '';\n        }\n\n        try {\n            console.log('[Run Prompt Side] Attempting to get current page');\n            const page = await getCurrentPage();\n            console.log('[Run Prompt Side] Successfully got current page');\n\n            // Check for scroll-to-bottom button and click if visible\n            console.log('[Run Prompt Side] Checking for scroll-to-bottom button');\n            const scrollButtonSelector = 'button.cursor-pointer.absolute.z-10.rounded-full.bg-clip-padding.border.text-token-text-secondary.border-token-border-light.right-1\\\\/2.translate-x-1\\\\/2.bg-token-main-surface-primary.w-8.h-8.flex.items-center.justify-center.bottom-5';\n            const scrollButtonClicked = await clickButtonIfVisible(scrollButtonSelector);\n\n            if (scrollButtonClicked) {\n                console.log('[Run Prompt Side] Scroll-to-bottom button clicked, waiting for scroll animation');\n                await page.waitForTimeout(1000); // Wait for scroll animation\n                console.log('[Run Prompt Side] Scroll animation wait complete');\n            } else {\n                console.log('[Run Prompt Side] Scroll-to-bottom button not found or not clicked');\n            }\n\n            console.log('[Run Prompt Side] Waiting for article selector');\n            await page.waitForSelector('div.h-full article.w-full.text-token-text-primary', { timeout: 10000 });\n            console.log('[Run Prompt Side] Article selector found');\n\n            console.log('[Run Prompt Side] Querying for articles');\n            const articles = await page.$$('div.h-full article.w-full.text-token-text-primary');\n            console.log(`[Run Prompt Side] Found ${articles.length} articles`);\n\n            if (articles.length === 0) {\n                console.log('[Run Prompt Side] No articles found, waiting...');\n                await page.waitForTimeout(3000);\n                continue;\n            }\n\n            const lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt Side] Attempting to extract content from last article');\n            try {\n                responseText = await page.evaluate(article => {\n                    const markdownDiv = article.querySelector('.markdown.prose.w-full.break-words.dark\\\\:prose-invert.dark');\n                    return markdownDiv ? markdownDiv.innerText : '';\n                }, lastArticle);\n                console.log('[Run Prompt Side] Content extracted successfully');\n            } catch (error) {\n                console.log('[Run Prompt Side] Error extracting content:', error.message);\n                console.log('[Run Prompt Side] Falling back to article.innerText()');\n                responseText = await lastArticle.innerText();\n                console.log('[Run Prompt Side] Fallback content extraction complete');\n            }\n\n            currentLength = responseText.length;\n            console.log(`[Run Prompt Side] Current response length: ${currentLength}`);\n            if (currentLength == 0) {\n                console.log('[Run Prompt Side] No content found in the response');\n            }\n\n            const isStable = currentLength === previousLength && currentLength > 0;\n            stableCount = isStable ? stableCount + 1 : 0;\n            console.log(`[Run Prompt Side] Is response stable: ${isStable}, Stable count: ${stableCount}`);\n\n            if (stableCount >= maxStableCount) {\n                console.log('[Run Prompt Side] Response appears to be complete');\n                return responseText;\n            }\n\n            previousLength = currentLength;\n            console.log('[Run Prompt Side] Waiting for 2 seconds before next iteration');\n            await page.waitForTimeout(2000);\n        } catch (error) {\n            console.log(`[Run Prompt Side] Error in waitForResponseCompletion: ${error.message}`);\n            console.log('[Run Prompt Side] Error stack:', error.stack);\n            console.log('[Run Prompt Side] Waiting for 3 seconds before retrying');\n            await new Promise(resolve => setTimeout(resolve, 3000));\n        }\n    }\n\n    console.log('[Run Prompt Side] Max wait time exceeded. Returning current response.');\n    return responseText;\n}\n\nasync function extractResponseText(currentPage) {\n    console.log('[Run Prompt Side] Entering extractResponseText');\n    let responseText = '';\n    let lastArticle;\n\n    try {\n        // Find all articles within the h-full div\n        const articles = await currentPage.$$('div.h-full article.w-full.text-token-text-primary');\n        console.log(`[Run Prompt Side] Found ${articles.length} articles`);\n\n        if (articles.length > 0) {\n            // Get the last article\n            lastArticle = articles[articles.length - 1];\n            console.log('[Run Prompt Side] Selected the last article');\n        } else {\n            throw new Error('No articles found');\n        }\n\n        // Find and click the copy button\n        const copyButton = await lastArticle.$('button[aria-label=\"Copy\"]');\n        if (copyButton) {\n            await copyButton.click();\n            await currentPage.waitForTimeout(1000); // Wait for clipboard to be updated\n\n            // Get clipboard contents\n            responseText = await currentPage.evaluate(() => navigator.clipboard.readText());\n            console.log('[Run Prompt Side] Response extracted from clipboard');\n        } else {\n            console.log('[Run Prompt Side] Copy button not found, falling back to original method');\n            const markdownDiv = await lastArticle.$('div.markdown');\n            if (markdownDiv) {\n                responseText = await markdownDiv.innerText();\n            } else {\n                throw new Error('Markdown div not found');\n            }\n        }\n    } catch (error) {\n        console.log('[Run Prompt Side] Error extracting content:', error.message);\n        try {\n            if (!lastArticle) {\n                lastArticle = await currentPage.$('div.h-full article.w-full.text-token-text-primary:last-child');\n                if (!lastArticle) {\n                    throw new Error('Unable to find last article');\n                }\n            }\n            const textBaseElement = await lastArticle.$('.text-base');\n            if (textBaseElement) {\n                responseText = await textBaseElement.innerText();\n                console.log('[Run Prompt Side] Response extracted using alternative selector');\n            } else {\n                throw new Error('Alternative selector not found');\n            }\n        } catch (innerError) {\n            console.log('[Run Prompt Side] Alternative selector also failed, using entire article content');\n            if (lastArticle) {\n                responseText = await lastArticle.innerText();\n            } else {\n                console.log('[Run Prompt Side] Failed to extract any content');\n                responseText = '';\n            }\n        }\n    }\n\n    console.log('[Run Prompt Side] Exiting extractResponseText, response length:', responseText.length);\n    return responseText;\n}\n\nasync function stopGeneration() {\n    console.log('[Run Prompt Side] Entering stopGeneration');\n    context.runPrompt.isStopRequested = true;\n    await clickButtonIfVisible('button[data-testid=\"stop-button\"][aria-label=\"Stop streaming\"]', true);\n    clearStopRequestedState();\n    console.log('[Run Prompt Side] Exiting stopGeneration');\n}\n\nfunction clearStopRequestedState() {\n    context.runPrompt.isStopRequested = false;\n    console.log('[Run Prompt Side] Stop requested state cleared.');\n}\n\nfunction cleanup(browser, result, msg) {\n    if (browser) {\n        browser.close().then(() => console.log('[Run Prompt Side] Browser closed'));\n    }\n\n    node.status(result.status);\n\n    const isLastMessage = result.endOfSequence;\n\n    const firstOutput = {\n        ...msg,\n        payload: result.payload,\n        endOfSequence: !!isLastMessage,\n        _continuation: !isLastMessage  // Set _continuation to true for the last message\n    };\n\n    const secondOutput = {\n        ...msg,\n        payload: result.payload,\n        status: result.status.text,\n        _continuation: !isLastMessage,\n        error: result.error,\n        endOfSequence: isLastMessage === true\n    };\n\n    node.send([firstOutput, secondOutput]);\n\n    return result;\n}\n\nasync function runPrompt() {\n    console.log('[Run Prompt Side] Entering runPrompt');\n    try {\n        await reloadPageIfNecessary(0);\n\n        const page = await getCurrentPage();\n        console.log('[Run Prompt Side] Got current page in runPrompt');\n\n        // ... (existing code for new chat button)\n        console.log('[Run Prompt Side] Full Msg:', msg);\n        const promptText = msg.payload || 'Sidefiring';\n        console.log('[Run Prompt Side] Entering prompt:', promptText);\n        await page.waitForSelector('#prompt-textarea', { state: 'attached', timeout: 30000 });\n        await page.fill('#prompt-textarea', promptText);\n\n        // Handle sidePrompt if present\n        if (msg.sidePrompt && msg.sidePrompt.length > 0) {\n            console.log('[Run Prompt Side] Handling sidePrompt');\n            const sidePromptText = msg.sidePrompt.join('\\n');\n            await page.evaluate((text) => {\n                const textarea = document.querySelector('#prompt-textarea');\n                textarea.value += '\\n\\n' + text;\n                textarea.dispatchEvent(new Event('input', { bubbles: true }));\n            }, sidePromptText);\n        }\n\n        await page.click('button[data-testid=\"send-button\"]');\n        console.log('[Run Prompt Side] Sent prompt');\n\n        await waitForResponseCompletion();\n\n        const responseText = await extractResponseText(page);\n        await clickButtonIfVisible('button:has-text(\"I prefer this response\")');\n        await page.waitForSelector('button[data-testid=\"stop-button\"]', { state: 'hidden', timeout: 120000 });\n\n        console.log('[Run Prompt Side] Exiting runPrompt');\n        return responseText;\n    } catch (error) {\n        console.log(`[Run Prompt Side] Error in runPrompt: ${error.message}`);\n        console.log('[Run Prompt Side] Error stack:', error.stack);\n        throw error;\n    }\n}\n\n\nasync function setupBrowser() {\n    try {\n        const { browser } = await connectAndSetupPage();\n        return browser;\n    } catch (error) {\n        throw new Error('Connection setup error: ' + error.message);\n    }\n}\n\nfunction isStopRequested() {\n    return context.runPrompt.isStopRequested;\n}\n\nasync function handleStopRequest(browser, msg) {\n    await stopGeneration();\n    return {\n        payload: \"stopped\",\n        status: { fill: \"yellow\", shape: \"dot\", text: \"Stopped\" }\n    };\n}\n\nasync function runPromptWithRetries(msg, maxRetries) {\n    for (let retryCount = 0; retryCount < maxRetries; retryCount++) {\n        if (isStopRequested()) {\n            return handleStopRequest();\n        }\n\n        try {\n            const payload = await runPrompt();\n            return {\n                payload,\n                status: { fill: \"green\", shape: \"dot\", text: \"done\" }\n            };\n        } catch (error) {\n            console.error(`[Run Prompt Side] Attempt ${retryCount + 1} failed:`, error);\n            await reloadPageIfNecessary(retryCount + 1);\n\n            if (retryCount === maxRetries - 1) {\n                throw error;\n            }\n        }\n    }\n    throw new Error('Max retries reached');\n}\n\nfunction isLastStep(msg) {\n    console.log('This is the last step');\n    return msg.currentStep === msg.totalSteps - 1;\n}\n\nfunction handleLastStep(result) {\n    return {\n        ...result,\n        endOfSequence: true,\n        status: { fill: \"green\", shape: \"dot\", text: \"Sequence Complete\" }\n    }; \n}\n\nfunction handleError(error) {\n    return {\n        payload: 'Error occurred: ' + error.message,\n        status: { fill: \"red\", shape: \"ring\", text: \"Error\" },\n        error: error.message\n    };\n}\n\nasync function executeScript(msg) {\n    console.log('[Run Prompt Side] Entering executeScript');\n    const maxRetries = 3;\n    let browser;\n    let result = { payload: null, status: null, error: null };\n\n    try {\n        browser = await setupBrowser();\n        \n        if (isStopRequested()) {\n            return handleStopRequest(browser, msg);\n        }\n\n        result = await runPromptWithRetries(msg, maxRetries);\n\n        if (isLastStep(msg)) {\n            result = handleLastStep(result);\n            console.log('last step result: ', result);\n        }\n    } catch (error) {\n        result = handleError(error);\n    }\n\n    return cleanup(browser, result, msg);\n}\n\n\n\nexecuteScript(msg);\n\nreturn null;\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 23,
        "initialize": "",
        "finalize": "",
        "libs": [
            {
                "var": "playwright",
                "module": "playwright"
            }
        ],
        "x": 1250,
        "y": 1420,
        "wires": [
            [],
            [
                "2fc4acc2cf2e4f06"
            ],
            []
        ]
    },
    {
        "id": "9cf975d9507d623d",
        "type": "comment",
        "z": "ac96ed0192970f1b",
        "name": "Here",
        "info": "Get the flow id\nput request to update the flow",
        "x": 490,
        "y": 220,
        "wires": []
    },
    {
        "id": "trigger_flow_id_request",
        "type": "inject",
        "z": "ac96ed0192970f1b",
        "name": "Trigger Flow ID Request",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 250,
        "y": 300,
        "wires": [
            [
                "http_request_flow_ids"
            ]
        ]
    },
    {
        "id": "http_request_flow_ids",
        "type": "http request",
        "z": "ac96ed0192970f1b",
        "name": "Get Flow IDs",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "http://localhost:26000/flows",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "basic",
        "senderr": false,
        "headers": [],
        "x": 490,
        "y": 300,
        "wires": [
            [
                "process_flow_ids"
            ]
        ]
    },
    {
        "id": "process_flow_ids",
        "type": "function",
        "z": "ac96ed0192970f1b",
        "name": "Process Flow IDs",
        "func": "msg.payload = msg.payload.map(flow => ({\n    id: flow.id,\n    label: flow.label || 'Unnamed Flow'\n}));\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 730,
        "y": 300,
        "wires": [
            [
                "debug_flow_ids"
            ]
        ]
    },
    {
        "id": "debug_flow_ids",
        "type": "debug",
        "z": "ac96ed0192970f1b",
        "name": "Debug Flow IDs",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 970,
        "y": 300,
        "wires": []
    },
    {
        "id": "a6494f2b607bcfa1",
        "type": "delflow",
        "z": "ac96ed0192970f1b",
        "name": "",
        "enabled": false,
        "x": 560,
        "y": 420,
        "wires": [
            [
                "3f453c220ae32c81"
            ]
        ]
    },
    {
        "id": "eac13069de09f52e",
        "type": "inject",
        "z": "ac96ed0192970f1b",
        "name": "deleteFlowID",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "b7925abd5dc222f6",
        "payloadType": "str",
        "x": 350,
        "y": 420,
        "wires": [
            [
                "a6494f2b607bcfa1"
            ]
        ]
    },
    {
        "id": "3f453c220ae32c81",
        "type": "debug",
        "z": "ac96ed0192970f1b",
        "name": "Debug Flow IDs",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "",
        "statusType": "auto",
        "x": 760,
        "y": 420,
        "wires": []
    }
]