[
    {
        "id": "a3db7a0bed089aba",
        "type": "tab",
        "label": "mainCalc",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "a073baad498bb284",
        "type": "tab",
        "label": "BetInputCheck",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "4126bd8cd63414e5",
        "type": "group",
        "z": "a073baad498bb284",
        "name": "BetInputCheck",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#d1d1d1"
        },
        "nodes": [
            "9e02f8f5e79de5a0",
            "bf94ecd062e4e70d",
            "907bb0adef74d85a",
            "3172a5061aab2782",
            "8dde91e674783ac8",
            "82f37f0f6985ba34",
            "28eddc9efdf05bee",
            "a1342c8699ac314d",
            "cd9414575b2fd3df"
        ],
        "x": 88,
        "y": 179,
        "w": 1534,
        "h": 768
    },
    {
        "id": "54f6d0041ccccb9a",
        "type": "group",
        "z": "a3db7a0bed089aba",
        "name": "Global Settings Load",
        "style": {
            "fill": "#d1d1d1",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "3d0e993013e06282",
            "033fe16e9cc49266",
            "3f7e8e558f6fa4e1",
            "e231afc77a9d3d48",
            "eff63dcfba5e7816",
            "64d65777ae3de614",
            "e49bb3665fc405ad",
            "658245982fee8ef1",
            "95b4ced33ab33e52",
            "185ac7421dd2f0e3"
        ],
        "x": 354,
        "y": 219,
        "w": 1512,
        "h": 162
    },
    {
        "id": "cb45f058661ba82d",
        "type": "group",
        "z": "a3db7a0bed089aba",
        "name": "SortedBetsCheck",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#d1d1d1"
        },
        "nodes": [
            "ce0b890d25fd621e",
            "7ad00ab84ca1d0a6",
            "00cb41efb645a58a",
            "3a2af3c5174ade05"
        ],
        "x": 348,
        "y": 419,
        "w": 1524,
        "h": 708
    },
    {
        "id": "9e02f8f5e79de5a0",
        "type": "group",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "BetInputCheck: Ph1 Extract",
        "style": {
            "fill": "#e3f3d3",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "272b6d76a23994ba",
            "3b7490b20fbb7087",
            "bd4fd4d1e09d770b",
            "74c06399d74963b0",
            "f4d0bfed3d6727e6",
            "5f817b78b5dfe714",
            "fb5587b589c5cd32",
            "24c74fc74752908c",
            "054adb80f90a06e5",
            "596247ccc0b71a3c",
            "9255709a121bbd33"
        ],
        "x": 124,
        "y": 239,
        "w": 1422,
        "h": 182
    },
    {
        "id": "bf94ecd062e4e70d",
        "type": "group",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "BetInputCheck: Ph2 Transform",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#ffffbf"
        },
        "nodes": [
            "9d42e07bd472374f",
            "aab5da598ff97b79",
            "6d7830c85b50c511",
            "b4dca9fd7958c13f",
            "12551b69148dc875",
            "18ee888a0e0c3587",
            "740d874372634aa9",
            "b753d113f1e07d62",
            "aa6c72150d31fb90",
            "148caedec77ae2dc",
            "7f404f5ee3444148"
        ],
        "x": 114,
        "y": 559,
        "w": 1462,
        "h": 202
    },
    {
        "id": "907bb0adef74d85a",
        "type": "group",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "BetInputCheck: Ph3 Load",
        "style": {
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "844825e531e70a8c",
            "8e05a6c56f99c187",
            "2e4fb60325f287ea",
            "37c361494a477963"
        ],
        "x": 114,
        "y": 779,
        "w": 1482,
        "h": 142
    },
    {
        "id": "ce0b890d25fd621e",
        "type": "group",
        "z": "a3db7a0bed089aba",
        "g": "cb45f058661ba82d",
        "name": "SortedBetsCheck: Ph1 Extract",
        "style": {
            "fill": "#e3f3d3",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "444beed8d57c785b",
            "bec042967485a2e3",
            "e44962bae1cc1618",
            "896eb4243908ad4f",
            "539afbf1cf687bbe",
            "c8d3e2ea864ca716",
            "e7098ada93bb3395",
            "c9ada086ac941463",
            "f74155178487c953",
            "7651d1d6f4210202",
            "f28aeef268b206d0",
            "51d8459b5ce8cb36"
        ],
        "x": 374,
        "y": 499,
        "w": 1452,
        "h": 202
    },
    {
        "id": "7ad00ab84ca1d0a6",
        "type": "group",
        "z": "a3db7a0bed089aba",
        "g": "cb45f058661ba82d",
        "name": "SortedBetsCheck: Ph2 Transform",
        "style": {
            "label": true,
            "color": "#000000",
            "fill": "#ffffbf"
        },
        "nodes": [
            "e78f6e028ab5a2c8",
            "546006e067f926e1",
            "41a3772b4f06d197",
            "93cb17474f0bb3e7",
            "2e89d386f82a853a",
            "523d55bf21aaae36",
            "24f408267e5fc21f",
            "2d00dfbbb4447581",
            "10aba27dacca5e49",
            "1d2207ac43530c01",
            "fd01a76bae39afdc"
        ],
        "x": 374,
        "y": 739,
        "w": 1472,
        "h": 202
    },
    {
        "id": "00cb41efb645a58a",
        "type": "group",
        "z": "a3db7a0bed089aba",
        "g": "cb45f058661ba82d",
        "name": "SortedBetsCheck: Ph3 Load",
        "style": {
            "fill": "#ffbfbf",
            "label": true,
            "color": "#000000"
        },
        "nodes": [
            "74f808d9c639d17d",
            "64ce18257e5c45e4",
            "ee7ec09d0d059517",
            "c8bbbbfd7b906968"
        ],
        "x": 374,
        "y": 959,
        "w": 1462,
        "h": 142
    },
    {
        "id": "e2bc7ac9aa77279e",
        "type": "mongodb4-client",
        "name": "Basic Connection",
        "protocol": "mongodb",
        "hostname": "127.0.0.1",
        "port": "22000",
        "dbName": "CimaMain",
        "appName": "",
        "authSource": "admin",
        "authMechanism": "SCRAM-SHA-256",
        "tls": false,
        "tlsCAFile": "",
        "tlsCertificateKeyFile": "",
        "tlsInsecure": false,
        "connectTimeoutMS": "",
        "socketTimeoutMS": "",
        "minPoolSize": "",
        "maxPoolSize": "",
        "maxIdleTimeMS": "",
        "uri": "mongodb://127.0.0.1:22000",
        "advanced": "{\"connectTimeoutMS\": 30000}",
        "uriTabActive": "tab-uri-advanced"
    },
    {
        "id": "df8a615d6d2cd2e7",
        "type": "websocket-listener",
        "path": "/ws/BetInputCheck",
        "wholemsg": "false"
    },
    {
        "id": "033fe16e9cc49266",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "Load Sports Settings",
        "func": "msg.extractMessage = msg.payload;\nmsg.timestamp = Date.now();\n\n// find query argument\nconst query = {\n};\n\n// payload for mongodb4 node\nmsg.payload = [query];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 260,
        "wires": [
            [
                "185ac7421dd2f0e3"
            ]
        ]
    },
    {
        "id": "3f7e8e558f6fa4e1",
        "type": "http in",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "",
        "url": "/LoadSettings",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 470,
        "y": 260,
        "wires": [
            [
                "033fe16e9cc49266"
            ]
        ]
    },
    {
        "id": "e78f6e028ab5a2c8",
        "type": "comment",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Outputs one at a time",
        "info": "",
        "x": 740,
        "y": 900,
        "wires": []
    },
    {
        "id": "e231afc77a9d3d48",
        "type": "inject",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "START INJECT",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "START",
        "payloadType": "str",
        "x": 600,
        "y": 320,
        "wires": [
            [
                "033fe16e9cc49266",
                "3d0e993013e06282"
            ]
        ]
    },
    {
        "id": "eff63dcfba5e7816",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "Sports Settings Results",
        "func": "var SportsSettingsObject = {};\n\nfor (let index = 0; index < msg.result.length; index++) {\n    // Use the sports name as the key, supporting both .Sports and .sports (in case of lowercase)\n    let sportsName = msg.result[index].Sports || msg.result[index].sports;\n\n    // Only set if sportsName is valid (not undefined, null, or empty string)\n    if (sportsName) {\n        SportsSettingsObject[sportsName] = msg.result[index];\n    } else {\n        // Optional: warn about missing property for debugging\n        node.warn(\"Missing 'Sports' property in result at index: \" + index + \", object: \" + JSON.stringify(msg.result[index]));\n    }\n\n    if (index === msg.result.length - 1) {\n        context.global.set('SportsSettings', SportsSettingsObject);\n        msg.SportsSettingsObject = SportsSettingsObject;\n    }\n}\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 260,
        "wires": [
            [
                "64d65777ae3de614"
            ]
        ]
    },
    {
        "id": "64d65777ae3de614",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "Sports Settings",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1740,
        "y": 260,
        "wires": []
    },
    {
        "id": "3d0e993013e06282",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "Load Stake Settings",
        "func": "msg.extractMessage = msg.payload;\nmsg.timestamp = Date.now();\n\n// find query argument\nconst query = {\n};\n\n// payload for mongodb4 node\nmsg.payload = [query];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 340,
        "wires": [
            [
                "e49bb3665fc405ad"
            ]
        ]
    },
    {
        "id": "e49bb3665fc405ad",
        "type": "mongodb4",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "stakeSettings",
        "operation": "find",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "stakeSettings.find.toArray",
        "x": 1180,
        "y": 340,
        "wires": [
            [
                "658245982fee8ef1"
            ]
        ]
    },
    {
        "id": "658245982fee8ef1",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "Stake Settings Results",
        "func": "// Set a global context variable using a message\ncontext.global.set('StakeSettings', msg.payload);\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1450,
        "y": 340,
        "wires": [
            [
                "95b4ced33ab33e52"
            ]
        ]
    },
    {
        "id": "95b4ced33ab33e52",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "name": "Stake Settings",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1740,
        "y": 340,
        "wires": []
    },
    {
        "id": "546006e067f926e1",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Transform 2: LineType Sorter",
        "func": "var incomingMessage = msg;\n\n//--------------------------------------\n// OUTPUT TO LINE TYPE CALCULATORS\n// Define output names and their corresponding indexes\nconst outputMapping = {\n    \"POINTSPREAD\": 0,\n    \"TOTAL\": 1,\n    \"MONEYLINE\": 2,\n    // Add more output names and indexes as needed\n};\n\nlet outputIndex;\n\nfunction outputMappedSend(currentResult, outputIndex) {\n    // Create an array to store messages for each output, initialized with null values\n    const outputs = Array(Object.keys(outputMapping).length).fill(null);\n\n    // Construct a new message object for the output\n    var outputMessage = {\n        req: incomingMessage.req, // Spread operator to copy existing msg properties\n        res: incomingMessage.res,\n        transform1Message: {combinedResults : incomingMessage.combinedResults, resultsArray : incomingMessage.resultsArray},\n        transform2Message: currentResult,\n        extractMessage: incomingMessage.extractMessage\n    };\n\n    // Ensure the extractMessage doesn't carry over unnecessary properties\n    if (outputMessage.extractMessage) {\n        delete outputMessage.transform1Message.extractMessage;\n    }\n\n    \n    // Assign the new message to the appropriate output based on the index\n    outputs[outputIndex] = outputMessage;\n\n    // Send the messages. Only the targeted output index will have a non-null message.\n    node.send([outputs]);\n}\n\n//------------\n//Calculate Length and iterate through\n// a. For resultLength Check msg.resultsArray\n// b. Switch Route it Through\n// c. The router calls a function.\n// Assuming msg.resultsArray is an array\n\nfor (let i = 0; i < incomingMessage.resultsArray.length; i++) {\n    // Access each element using msg.resultsArray[i]\n    let currentResult = incomingMessage.resultsArray[i];\n\n    // Determine the index of the desired output based on the LineType\n    switch (incomingMessage.resultsArray[i].LineType) {\n        case 'POINTSPREAD':\n            outputIndex = outputMapping[\"POINTSPREAD\"];\n            outputMappedSend(currentResult, outputIndex);\n            break;\n        case 'TOTAL':\n            outputIndex = outputMapping[\"TOTAL\"];\n            outputMappedSend(currentResult, outputIndex);\n            break;\n        case 'MONEYLINE':\n            outputIndex = outputMapping[\"MONEYLINE\"];\n            outputMappedSend(currentResult, outputIndex);\n            break;\n        default:\n            // Handle default case (optional)\n            node.warn('Unknown LineType: ', incomingMessage.resultsArray[i]);\n    }\n}\n",
        "outputs": 3,
        "timeout": "",
        "noerr": 3,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 600,
        "y": 840,
        "wires": [
            [
                "93cb17474f0bb3e7",
                "2e89d386f82a853a"
            ],
            [
                "523d55bf21aaae36"
            ],
            [
                "24f408267e5fc21f"
            ]
        ],
        "outputLabels": [
            "POINTSPREAD",
            "TOTAL",
            "MONEYLINE"
        ]
    },
    {
        "id": "41a3772b4f06d197",
        "type": "link in",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "SBCheck Ph2: IN : Transform1 : Split Messages > Line Type Sorter",
        "links": [
            "7651d1d6f4210202"
        ],
        "x": 415,
        "y": 840,
        "wires": [
            [
                "546006e067f926e1"
            ]
        ]
    },
    {
        "id": "93cb17474f0bb3e7",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Transform 2: Pointspread",
        "func": "// 3. Check Bet \n    // If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n    // If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n    // Then calculate line ; vig ; outcomes\n    // Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n    // Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform2Message = incomingMessageVar.transform2Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform2Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n        \n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n        \n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n    \n    return result;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    main.PointspreadPointsDifference = transform2Message['Bet1'].Line1PointsAmFloat + transform2Message['Bet2'].Line2PointsAmFloat\n\n    main.PointspreadRangeMin = SportsSettingsVar[main.sport].PointspreadRangeMin;\n    main.PointspreadRangeMax = SportsSettingsVar[main.sport].PointspreadRangeMax;\n\n    // Calculate Range Rating\n    main.PointspreadPointsDifferenceRating = main.PointspreadPointsDifference / main.PointspreadRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n    \n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n    \n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        main.line[i] = transform2Message[`Bet${i}`];        \n        main.line[i].lineValue = transform2Message[`Bet${i}`][`Line${i}PriceAmML`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win; \n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;            \n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n    \n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n    \n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n    \n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n \n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n    \n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n    \n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.PointspreadPointsDifference >= main.PointspreadRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }   \n    // B: If Arb Less than Range min & greater than 0\n    else if (main.PointspreadPointsDifference < main.PointspreadRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15){\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.PointspreadPointsDifference < main.PointspreadRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else{\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\"){\n        main.line[1].stake = globalStake; \n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\"){\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1/100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2/100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform2Message = incomingMessageVar.transform2Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform2Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 6,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 820,
        "wires": [
            [
                "2d00dfbbb4447581",
                "10aba27dacca5e49"
            ]
        ]
    },
    {
        "id": "2e89d386f82a853a",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Debug PspreadSorter",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 780,
        "wires": []
    },
    {
        "id": "523d55bf21aaae36",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Transform 2: Totals",
        "func": "// 3. Check Bet \n// If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n// If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n// Then calculate line ; vig ; outcomes\n// Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n// Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform2Message = incomingMessageVar.transform2Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform2Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    main.TotalsPointsDifference = transform2Message['Bet1'].Line1PointsAmFloat + transform2Message['Bet2'].Line2PointsAmFloat\n\n    main.TotalsRangeMin = SportsSettingsVar[main.sport].TotalsRangeMin;\n    main.TotalsRangeMax = SportsSettingsVar[main.sport].TotalsRangeMax;\n\n    // Calculate Range Rating\n    main.TotalsPointsDifferenceRating = main.TotalsPointsDifference / main.TotalsRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        main.line[i] = transform2Message[`Bet${i}`];\n        main.line[i].lineValue = transform2Message[`Bet${i}`][`Line${i}PriceAmML`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.TotalsPointsDifference >= main.TotalsRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.TotalsPointsDifference < main.TotalsRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.TotalsPointsDifference < main.TotalsRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform2Message = incomingMessageVar.transform2Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform2Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 6,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1060,
        "y": 860,
        "wires": [
            [
                "10aba27dacca5e49"
            ]
        ]
    },
    {
        "id": "24f408267e5fc21f",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Transform 2: Moneyline",
        "func": "// 3. Check Bet \n// If Point Spread (By Sports); If Totals (By Sports); If Moneyline \n// If Line type x (PS & Totals) or (ML) =  then calculate points ; line ; profit ; vig loss\n// Then calculate line ; vig ; outcomes\n// Then Profit & Bet Type : Middle ; Vigsplit ; Arb\n// Then Compare Risk / Profit (LATER)\n\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform2Message = incomingMessageVar.transform2Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n\nmain.sport = transform2Message['Sport'];\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    main.MoneylineDifference = transform2Message['Bet1'].Line1PointsAmFloat + transform2Message['Bet2'].Line2PointsAmFloat\n\n    main.MoneylineRangeMin = SportsSettingsVar[main.sport].MoneylineRangeMin;\n    main.MoneylineRangeMax = SportsSettingsVar[main.sport].MoneylineRangeMax;\n\n    // Calculate Range Rating\n    main.MoneylineDifferenceRating = main.MoneylineDifference / main.MoneylineRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        main.line[i] = transform2Message[`Bet${i}`];\n        main.line[i].lineValue = transform2Message[`Bet${i}`][`Line${i}PriceAmML`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.MoneylineDifference >= main.MoneylineRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MONEYLINEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.MoneylineDifference < main.MoneylineRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.MoneylineDifference < main.MoneylineRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform2Message = incomingMessageVar.transform2Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform2Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 6,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1080,
        "y": 900,
        "wires": [
            [
                "10aba27dacca5e49"
            ]
        ]
    },
    {
        "id": "2d00dfbbb4447581",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Debug PSpread",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1380,
        "y": 820,
        "wires": []
    },
    {
        "id": "10aba27dacca5e49",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Transform 2: Comparative Bets",
        "func": "\nvar incomingMessage = msg;\nvar msgIDVar = msg._msgid;\nvar resultCounter = incomingMessage.transform1Message.resultsArray.length;\nvar main = {};\nvar tenPercentStake = 10;\nvar vigMax = 5;\nvar arbPercentageRangeMin = 4;\nvar vigSplitRangeMin = 15;\nvar moneylineRangeMin = 21;\n\n//===================================\n// Buffer Functions\n// Initialize a buffer object if it doesn't exist\nif (!context.get(\"buffer\")) {\n    context.set(\"buffer\", {});\n}\n\n\n// Initialize a timeout object to keep track of message timeouts\nif (!context.get(\"timeouts\")) {\n    context.set(\"timeouts\", {});\n}\n\nlet buffer = context.get(\"buffer\");\n\nlet timeouts = context.get(\"timeouts\");\nconst timeoutDuration = 60000; // Timeout duration in milliseconds (1 minute)\n\n\n// Ensure buffer entry exists and initialize it as an empty array if it doesn't\nif (!buffer[msgIDVar]) {\n    buffer[msgIDVar] = {};\n    buffer[msgIDVar].messages = [];\n}\n\n// Add the incoming message to the buffer array for this msgIDVar\nbuffer[msgIDVar].messages.push(incomingMessage);\ncontext.set(\"buffer\", buffer); // Persist the updated buffer\n\n\n// Check if we need to set a timeout for this msgIDVar\nif (!timeouts[msgIDVar]) {\n    timeouts[msgIDVar] = setTimeout(() => {\n        cleanupBuffer(msgIDVar); // Cleanup function called after timeout\n        node.warn(`Cleanup performed for msgIDVar ${msgIDVar} due to timeout.`);\n    }, timeoutDuration);\n    context.set(\"timeouts\", timeouts); // Persist the updated timeouts\n}\n\n\n// Function to clean up the buffer and timeouts\nfunction cleanupBuffer(msgIDVar) {\n    const index = msgIDVar;\n    delete buffer[index]; // Remove the message group from the buffer\n    delete timeouts[index]; // Remove the timeout for this message group\n    context.set(\"buffer\", buffer); // Update the buffer in flow context\n    context.set(\"timeouts\", timeouts); // Update the timeouts in flow context\n}\n\n//=========================\n// CALCULATION FUNCTIONS\n// 4. figure out which is the original message\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit \n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n// General function to extract and sort messages by a specified property path\nfunction extractAndSortByProperty(messages, propertyPath) {\n    // Split the property path into parts for nested properties\n    const pathParts = propertyPath.split('.');\n\n    // Map and extract the specified property value, handling nested properties\n    const extractedValues = messages.map((message, index) => {\n        let value = message.transform2Message;\n        for (const part of pathParts) {\n            value = value ? value[part] : undefined;\n        }\n        return { messageIndex: index, value };\n    });\n\n    // Filter out any undefined values that may not exist for the specified property\n    const filteredValues = extractedValues.filter(item => item.value !== undefined);\n\n    // Sort the filtered array by the specified property in descending order\n    filteredValues.sort((a, b) => b.value - a.value);\n\n    return filteredValues;\n}\n\n\nfunction calculateComparison(){\n// Calculate Within  PointSpread , Totals, Moneyline\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit\n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n\n    // -------------------\n\n    // Check if the incomingMessage.transform2Message is the main bet to compare all results\n    if (incomingMessage.transform2Message && incomingMessage.transform2Message._id == incomingMessage.extractMessage._id){\n        // Set Bet Type\n        main.BetType = incomingMessage.transform2Message.BetType; \n    }\n\n\n    // A: If MIDDLEBET\n    if (main.BetType == \"MIDDLEBET\"){\n\n        // Filter results by BetType\n        let middleBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"MIDDLEBET\"\n        );\n        // Check if it doesn't exist\n        if (middleBetMessages.length <= 0){\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else{\n            // Example: Sort by 'PointspreadPointsDifference'\n            let sortedByPointspread = extractAndSortByProperty(buffer[msgIDVar].messages, 'PointspreadPointsDifference');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform2Message.PointspreadPointsDifference > sortedByPointspread[0])\n            {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else {\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // B: If ARBBET\n    if (main.BetType == \"ARBBET\") {\n       \n        // Filter results by BetType\n        let arbBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"ARBBET\"\n        );\n        // Check if it doesn't exist\n        if (arbBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else {\n            // Example: Sort by nested 'arbResults.ArbPercentage'\n            let sortedByArbPercentage = extractAndSortByProperty(buffer[msgIDVar].messages, 'arbResults.ArbPercentage');\n\n            // Example: Sort by nested 'arbResults.ArbProfit1'\n            let sortedByArbProfit1 = extractAndSortByProperty(buffer[msgIDVar].messages, 'arbResults.ArbProfit1');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform2Message.arbResults.ArbPercentage > (sortedByArbPercentage[0] + 3) || incomingMessage.transform2Message.arbResults.ArbProfit1 > (sortedByArbProfit1[0] + tenPercentStake)) {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else{\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // C: If Vigsplitbet\n    if (main.BetType == \"VIGSPLITBET\") {\n\n        // Filter results by BetType\n        let vigsplitBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"VIGSPLITBET\"\n        );\n        // Check if it doesn't exist\n        if (vigsplitBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n        // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n    // D: If Vigsplitbet\n    if (main.BetType == \"MONEYLINEBET\") {\n\n        // Filter results by BetType\n        let moneylineBetMessages = buffer[msgIDVar].messages.filter(message =>\n            message.transform2Message && message.transform2Message.BetType === \"MONEYLINEBET\"\n        );\n        // Check if it doesn't exist\n        if (moneylineBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n            // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n\n    //--------------------\n    // CHECK IF NO RESULTS ; RETURN IF NONE\n    if (incomingMessage.transform1Message.resultsArray.length == 1) {\n        main.SameGame = \"Clear\";\n    }\n    \n}\n\nfunction calculateProfit() {\n\n    // CHECK MIDDLEBET\n    if (incomingMessage.transform2Message.BetType == \"MIDDLEBET\"){\n        if (incomingMessage.transform2Message.PointspreadPointsDifference >= incomingMessage.transform2Message.PointspreadRangeMin)\n        {main.profitCheck = true;}\n        else{ main.profitCheck = false;}\n    }\n    // CHECK ARBBET\n    else if(incomingMessage.transform2Message.BetType == \"ARBBET\"){\n        if (incomingMessage.transform2Message.arbResults.ArbPercentage >= arbPercentageRangeMin)\n        { main.profitCheck = true; }\n        else { main.profitCheck = false; }      \n    }\n    // CHECK VIGSPLITBET\n    else if (incomingMessage.transform2Message.BetType == \"VIGSPLITBET\"){\n        if (incomingMessage.transform2Message.vigSplitProfit >= vigSplitRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK MONEYLINEBET\n    else if (incomingMessage.transform2Message.BetType == \"MONEYLINEBET\") {\n        if (incomingMessage.transform2Message.moneylineDifference > moneylineRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK VIGMAX\n    if (incomingMessage.transform2Message.TotalVig > vigMax){\n        main.profitCheck = false;\n    }\n\n}\n\n\n//========================\n// EXECUTION FUNCTIONS\n\n// If we have collected resultCounter messages for this msgIDVar, process them\nif (buffer[msgIDVar].messages.length === resultCounter) {\n\n    //-------------\n    //iterate through the incomingMessage.resultsArray[i]._id and check if it there are matches to the ones in the buffer\n    let matchesCount = 0;\n\n    // Example of improved match checking, avoiding incorrect index access\n    buffer[msgIDVar].messages.forEach((bufferedMsg, index) => {\n        if (bufferedMsg.transform2Message && incomingMessage.transform1Message.resultsArray.some(res => res._id === bufferedMsg.transform2Message._id)) {\n            matchesCount++;\n        }\n    });\n\n    //------------\n    // IF all messages exist, and complete.\n    if (matchesCount == incomingMessage.transform1Message.resultsArray.length) {\n        \n \n        clearTimeout(timeouts[msgIDVar]); // Important to clear timeout\n        context.set(\"timeouts\", timeouts); // Persist timeouts changes\n\n        // CALCULATE HERE\n        calculateComparison();\n        calculateProfit();\n        \n        // ADD ALL KEYS\n        for (const [key, value] of Object.entries(main)) {\n            incomingMessage.transform2Message[key] = value;\n        }\n        \n        // Prep Message and Send\n        var newMsg = {...msg};\n        newMsg.matches = matchesCount;\n        newMsg.extractMessage = msg.extractMessage;\n        newMsg.transform2Message = incomingMessage.transform2Message;\n        newMsg.transform1Message = incomingMessage.transform1Message;\n        newMsg.transformResults = incomingMessage.transformResults;\n        newMsg.main = main;\n\n        // Send the combined message on\n        node.send(newMsg);\n\n        // Cleanup buffer and timeouts for this msgIDVar\n        cleanupBuffer(msgIDVar);\n    } else {\n        // Handle case where results are missing\n        node.error(\"Not matching length\", msg);\n    }\n\n}\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1440,
        "y": 880,
        "wires": [
            [
                "fd01a76bae39afdc",
                "1d2207ac43530c01"
            ]
        ]
    },
    {
        "id": "444beed8d57c785b",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "Transform1 : Comparative Query Results",
        "func": "var msgIDVar = msg._msgid;\n\n// Initialize a buffer object if it doesn't exist\nif (!context.get(\"buffer\")) {\n    context.set(\"buffer\", {});\n}\n\n// Initialize a timeout object to keep track of message timeouts\nif (!context.get(\"timeouts\")) {\n    context.set(\"timeouts\", {});\n}\n\nlet buffer = context.get(\"buffer\");\nlet timeouts = context.get(\"timeouts\");\nconst timeoutDuration = 60000; // Timeout duration in milliseconds (1 minute)\n\n// Function to clean up the buffer and timeouts\nfunction cleanupBuffer(msgIDVar) {\n    const index = msgIDVar;\n    delete buffer[index]; // Remove the message group from the buffer\n    delete timeouts[index]; // Remove the timeout for this message group\n    context.set(\"buffer\", buffer); // Update the buffer in flow context\n    context.set(\"timeouts\", timeouts); // Update the timeouts in flow context\n}\n\n// Ensure buffer entry exists and initialize it as an empty array if it doesn't\nif (!buffer[msgIDVar]) {\n    buffer[msgIDVar] = [];\n}\n\n// Add the incoming message to the buffer array for this msgIDVar\nbuffer[msgIDVar].push(msg);\n\n// Check if we need to set a timeout for this msgIDVar\nif (!timeouts[msgIDVar]) {\n    timeouts[msgIDVar] = setTimeout(() => {\n        cleanupBuffer(msgIDVar); // Cleanup function called after timeout\n        node.warn(`Cleanup performed for msgIDVar ${msgIDVar} due to timeout.`);\n    }, timeoutDuration);\n}\n\n// If we have collected 3 messages for this msgIDVar, process them\nif (buffer[msgIDVar].length === 3) {\n    //node.send(msg);\n    \n    // Check if all required collections are present\n    const collections = [\"InProgressBets\", \"CompletedTransactions\", \"SortedBets\"];\n    const collectedCollections = buffer[msgIDVar].map(msg => msg.collection);\n\n    if (collections.every(collection => collectedCollections.includes(collection))) {\n        clearTimeout(timeouts[msgIDVar]); // Cancel the timeout as we're processing the messages\n        let combinedResults = {};\n\n        // Process messages based on their collections\n        buffer[msgIDVar].forEach((messageVar) => {\n            combinedResults[messageVar.collection] = messageVar.result;\n        });\n\n        // Add a new combo property, clean up\n        msg.combinedResults = combinedResults;\n        delete msg.payload;\n        delete msg.queryID;\n        delete msg.query;\n        delete msg.result;\n        delete msg.collection;\n\n        // Send the combined message on\n        node.send(msg);\n\n        // Cleanup buffer and timeouts for this msgIDVar\n        cleanupBuffer(msgIDVar); \n    } else {\n        // Handle case where required collections are missing\n        node.error(\"Not all required collections are present in the buffered messages.\", msg);\n    }\n    \n}\n\nreturn null; // Prevent sending the original message onwards",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1260,
        "y": 600,
        "wires": [
            [
                "539afbf1cf687bbe",
                "c8d3e2ea864ca716"
            ]
        ]
    },
    {
        "id": "bec042967485a2e3",
        "type": "mongodb4",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "sortedBets",
        "operation": "aggregate",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "sortedBets.aggregate.toArray",
        "x": 920,
        "y": 660,
        "wires": [
            [
                "444beed8d57c785b",
                "c9ada086ac941463"
            ]
        ]
    },
    {
        "id": "e44962bae1cc1618",
        "type": "mongodb4",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "inProgressBets",
        "operation": "aggregate",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "inProgressBets.aggregate.toArray",
        "x": 940,
        "y": 600,
        "wires": [
            [
                "444beed8d57c785b"
            ]
        ]
    },
    {
        "id": "896eb4243908ad4f",
        "type": "mongodb4",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "completedTransactions",
        "operation": "aggregate",
        "output": "toArray",
        "maxTimeMS": "",
        "handleDocId": false,
        "name": "completedTransactions.aggregate.toArray",
        "x": 960,
        "y": 560,
        "wires": [
            [
                "444beed8d57c785b"
            ]
        ]
    },
    {
        "id": "539afbf1cf687bbe",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "results",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1450,
        "y": 660,
        "wires": []
    },
    {
        "id": "c8d3e2ea864ca716",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "Spit Messages",
        "func": "// Extract the input array\nvar incomingMessage = msg;\nvar newMsg = msg;\n\n    // MAKE ARRAY\n    var resultsArray = [];\n\n    // Define the properties to check\n    var resultsToGet = [\n        'SortedBets',\n        'InProgressBets',\n        'CompletedTransactions',\n    ];\n\n    // Iterate over the properties and push non-empty values to the array\n    resultsToGet.forEach(property => {\n        // Check if the property exists and is not undefined, and if it is an array\n        if (msg.combinedResults[property] && Array.isArray(msg.combinedResults[property].result)) {\n            // Iterate over the elements of the array and push them to the resultsArray\n            msg.combinedResults[property].result.forEach(entry => {\n                resultsArray.push(entry);\n            });\n        }\n    });\n    \n    // Push the original message\n    resultsArray.push(msg.extractMessage.item);\n\n    // Apply to the newMsg\n    newMsg.resultsArray = resultsArray;\n\n    // Send Message\n    node.send(newMsg);\n\n\n// Optionally, you can return null to prevent the original message from being passed to the next node\nreturn null;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1540,
        "y": 600,
        "wires": [
            [
                "7651d1d6f4210202",
                "f74155178487c953"
            ]
        ]
    },
    {
        "id": "e7098ada93bb3395",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "set payload",
        "func": "let item = msg.extractMessage.item;\n\nconst oneWeekAgo = new Date(Date.now() - 12 * 7 * 24 * 60 * 60 * 1000); // 12 weeks ago\n\nconst GeneralBetsPipeline = [\n    {\n        $match: {\n            TimeStamp: {\n                $gte: oneWeekAgo,\n                $lt: new Date(),\n            },\n            $and: [\n                // Condition 1: Check if Item.GameNumber is the same\n                { GameNumber: { $eq: item.GameNumber } },\n                // Condition 1a: Check if Item.GameNumber is the same\n                { Sport: { $eq: item.Sport } },\n                // Condition 1b: Check if Item.GameNumber is the same\n                { League: { $eq: item.League } },\n                // Condition 2: Check if Item.Bet1.Book1 is different\n                { \"Bet1.Book1\": { $ne: item.Book1 } },\n                // Condition 3: Check if Item.Bet2.Book2 is different\n                { \"Bet2.Book2\": { $ne: item.Book2 } },\n                // Condition 4: Check Team 1\n                { \"Bet1.Team1\": { $ne: item.Team1 } },\n                // Condition 5: Check Team 2\n                { \"Bet2.Team2\": { $ne: item.Team2 } },\n                // Condition 6: Check if Bet1.BookNameAccountNameAssigned1 is different\n                { \"Bet1.BookNameAccountNameAssigned1\": { $ne: item.BookNameAccountName1 } },\n                // Condition 7: Check if Bet1.BookNameAccountNameAssigned2 is different\n                { \"Bet2.BookNameAccountNameAssigned2\": { $ne: item.BookNameAccountName2 } },\n                \n                // Condition 8: Check if Item.PointsDifference is equal or higher\n\n                // { PointsDifference: { $gt: item.PointsDifference } },\n                // Condition 5: Check if item.RoughSum is higher\n                // { PotentialProfit: { $gt: item.RoughSum } },\n            ],\n        },\n    },\n    {\n        $sort: {\n            GameNumber: -1,\n            LineType: -1,\n            Team1: -1,\n            Line1PriceAmML: -1,\n            Line1PointsAmFloat: -1,\n            TimeStamp: -1,\n        },\n    },\n    {\n        $limit: 1000,\n    },\n];\n\nmsg.payload = [GeneralBetsPipeline];\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 690,
        "y": 600,
        "wires": [
            [
                "bec042967485a2e3",
                "e44962bae1cc1618",
                "896eb4243908ad4f"
            ]
        ]
    },
    {
        "id": "c9ada086ac941463",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "output query",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1210,
        "y": 660,
        "wires": []
    },
    {
        "id": "f74155178487c953",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "Split Message",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 660,
        "wires": []
    },
    {
        "id": "7651d1d6f4210202",
        "type": "link out",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "SBCheck Ph1 : OUT : Transform1 : Split Messages > Line Type Sorter",
        "mode": "link",
        "links": [
            "41a3772b4f06d197"
        ],
        "x": 1645,
        "y": 600,
        "wires": []
    },
    {
        "id": "f28aeef268b206d0",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "EXTRACT : Receive POST",
        "func": "// PRIOR TO SET FIELDS - COMING FROM RAWDBS\nvar idVar = msg.payload.message._id;\n\nmsg.extractMessage = {\n    announce: 'Received POST request at:',\n    timestamp: msg.timestamp,\n    _id: idVar,\n    item: msg.payload.message,\n};\n\n//1. Timestamp ----------------\n\n// GENERATE A TIMESTAMP (SPECIFIC TO PIPELINE)\n// Generate a timestamp for every incoming message\n\n\n// Retrieve the last stored message's timestamp\nvar lastTimestamp = flow.get(\"sortedBetsCheckConditions_lastTimestamp\") || 0;\n\n// Check if the incoming message is newer\nif (msg.timestamp > lastTimestamp) {\n    // Update the context with the new message payload and timestamp\n    flow.set(\"sortedBetsCheckConditions_rememberedPayload\", msg.payload);\n    flow.set(\"sortedBetsCheckConditions_lastTimestamp\", msg.timestamp);\n} else {\n    // Ignore the message, as it's older than what we have stored\n}\n\n//2. QUEUE ----------------\n\n// Retrieve the existing queue or initialize a new one\nvar messageQueue = flow.get(\"sortedBetsCheckConditions_messageQueue\") || [];\n\n// Add the incoming message to the queue\nmessageQueue.push({ payload: msg.payload});\n\n// Update the queue in the context\nflow.set(\"sortedBetsCheckConditions_messageQueue\", messageQueue);\n\n// Time limit in milliseconds (10 minutes)\nconst timeLimit = 10 * 60 * 1000; // 10 minutes * 60 seconds * 1000 milliseconds\n\n// Filter the queue to keep only messages from the last 10 minutes\nmessageQueue = messageQueue.filter(item => Date.now() - item.payload.timestamp <= timeLimit);\n\n// Save the updated queue back to the node context\nflow.set('sortedBetsCheckConditions_messageQueue', messageQueue);\n\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 520,
        "y": 600,
        "wires": [
            [
                "e7098ada93bb3395"
            ]
        ]
    },
    {
        "id": "51d8459b5ce8cb36",
        "type": "http in",
        "z": "a3db7a0bed089aba",
        "g": "ce0b890d25fd621e",
        "name": "",
        "url": "/SortedBetsCheckConditions",
        "method": "post",
        "upload": false,
        "swaggerDoc": "",
        "x": 540,
        "y": 540,
        "wires": [
            [
                "f28aeef268b206d0"
            ]
        ]
    },
    {
        "id": "1d2207ac43530c01",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "Debug COMPARE",
        "active": false,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1710,
        "y": 820,
        "wires": []
    },
    {
        "id": "74f808d9c639d17d",
        "type": "function",
        "z": "a3db7a0bed089aba",
        "g": "00cb41efb645a58a",
        "name": "Load: Pack to HTTP",
        "func": "\nvar incomingMessage = msg;\n\n\n//===================================\nmsg.statusCode = 200; // Set HTTP status code to 200 OK\nmsg.headers = {\n    \"Content-Type\": \"text/plain\" // Set Content-Type header to text/plain\n};\n// Skip the Sort\nmsg.payload = {\n    extractMessage: incomingMessage.extractMessage,\n    finalMessage: incomingMessage.transform2Message,\n    transform1Message: incomingMessage.transform1Message,\n    _msgid: incomingMessage._msgid\n};\n\nmsg.req = incomingMessage.req;\nmsg.res = incomingMessage.res;\n//========================\n// EXECUTION FUNCTIONS\n\nnode.send(msg);\nreturn null\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1420,
        "y": 1060,
        "wires": [
            [
                "64ce18257e5c45e4",
                "ee7ec09d0d059517"
            ]
        ]
    },
    {
        "id": "64ce18257e5c45e4",
        "type": "debug",
        "z": "a3db7a0bed089aba",
        "g": "00cb41efb645a58a",
        "name": "Debug RESPONSE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1700,
        "y": 1000,
        "wires": []
    },
    {
        "id": "ee7ec09d0d059517",
        "type": "http response",
        "z": "a3db7a0bed089aba",
        "g": "00cb41efb645a58a",
        "name": "HTTP RESP 2",
        "statusCode": "",
        "headers": {},
        "x": 1720,
        "y": 1060,
        "wires": []
    },
    {
        "id": "fd01a76bae39afdc",
        "type": "link out",
        "z": "a3db7a0bed089aba",
        "g": "7ad00ab84ca1d0a6",
        "name": "SBCheck Ph2: OUT :  > Load: Pack to HTTP",
        "mode": "link",
        "links": [
            "c8bbbbfd7b906968"
        ],
        "x": 1785,
        "y": 880,
        "wires": []
    },
    {
        "id": "c8bbbbfd7b906968",
        "type": "link in",
        "z": "a3db7a0bed089aba",
        "g": "00cb41efb645a58a",
        "name": "SBCheck Ph3 : IN : Compare > Load: Pack to HTTP",
        "links": [
            "fd01a76bae39afdc"
        ],
        "x": 415,
        "y": 1060,
        "wires": [
            [
                "74f808d9c639d17d"
            ]
        ]
    },
    {
        "id": "3a2af3c5174ade05",
        "type": "comment",
        "z": "a3db7a0bed089aba",
        "g": "cb45f058661ba82d",
        "name": "SortedBetsCheck : Full Pseudocode",
        "info": "// 3. Check Bet POINTS & PROFIT 3 different ways: Middle, VigSplit, Arb\n    // Point Spread ; If Totals; If Moneyline\n    // If Line type x (PS & Totals) =  then calculate points ; line ; profit ; vig loss\n    // If Line type y (ML) = calculate line ; profit ; vig loss\n    //--- (DUPLICATE AND DO IT TWICE TO BOTH PASSED AND COMPARE)\n    // filter by Sports\n    // if sports ; check the min and max, get the gap percentage\n    // line ; how much gap.\n\n//--------\n// Make a function also to calculate if it's a high Vigsplit.\n// Middle / Vigsplit / Arb / Moneyline\n\n// 4. Filter 5% or more / Filter 0 risk profit\n    // cut out vig loss > 5%\n    // Filter out 0 risk > Profit #\n\n//--------\n// 5. Check if x or y higher\n// 6. only push if higher 5% threshhold than highest bets in 2 categories.\n\n//================================\n// Later : Do a line scanner.\n// 10. QUERY MONGO, Slap a credit stop loss limit for accounts \n// 11. COME OUT WITH 1 or 2 bets arrays - use same books, different accounts(middle & vigsplit)\n\nmsg.payload = SportsSettingsVar;\nreturn msg;",
        "x": 530,
        "y": 460,
        "wires": []
    },
    {
        "id": "185ac7421dd2f0e3",
        "type": "mongodb4",
        "z": "a3db7a0bed089aba",
        "g": "54f6d0041ccccb9a",
        "clientNode": "e2bc7ac9aa77279e",
        "mode": "collection",
        "collection": "sportsSettings",
        "operation": "find",
        "output": "toArray",
        "maxTimeMS": "0",
        "handleDocId": false,
        "name": "sportsSettings.find.toArray",
        "x": 1180,
        "y": 260,
        "wires": [
            [
                "eff63dcfba5e7816"
            ]
        ]
    },
    {
        "id": "272b6d76a23994ba",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "EXTRACT : Receive POST",
        "func": "// PRIOR TO SET FIELDS - COMING FROM RAWDBS\nlet incomingMessage = msg;\n\nmsg.extractMessage = {\n    announce: 'Received POST request at:',\n    timestamp: msg.timestamp,\n    originalMessage: msg.payload,\n};\n\n// Create proper structure for EXTRACT 2 function\nmsg.scrapeResults = incomingMessage.payload.scrapeResults;\nmsg.fullBet = incomingMessage.payload.fullBet;\nmsg.fullMessage = incomingMessage.payload.fullBet;\n\n//1. Timestamp ----------------\n\n// GENERATE A TIMESTAMP (SPECIFIC TO PIPELINE)\n// Generate a timestamp for every incoming message\n\n\n// Retrieve the last stored message's timestamp\nvar lastTimestamp = flow.get(\"BetInputCheck_lastTimestamp\") || 0;\n\n// Check if the incoming message is newer\nif (msg.timestamp > lastTimestamp) {\n    // Update the context with the new message payload and timestamp\n    flow.set(\"BetInputCheck_rememberedPayload\", msg.payload);\n    flow.set(\"BetInputCheck_lastTimestamp\", msg.timestamp);\n} else {\n    // Ignore the message, as it's older than what we have stored\n}\n\n//2. QUEUE ----------------\n\n// Retrieve the existing queue or initialize a new one\nvar messageQueue = flow.get(\"BetInputCheck_messageQueue\") || [];\n\n// Add the incoming message to the queue\nmessageQueue.push({ payload: msg.payload});\n\n// Update the queue in the context\nflow.set(\"BetInputCheck_messageQueue\", messageQueue);\n\n// Time limit in milliseconds (10 minutes)\nconst timeLimit = 10 * 60 * 1000; // 10 minutes * 60 seconds * 1000 milliseconds\n\n// Filter the queue to keep only messages from the last 10 minutes\nmessageQueue = messageQueue.filter(item => Date.now() - item.payload.timestamp <= timeLimit);\n\n// Save the updated queue back to the node context\nflow.set('BetInputCheck_messageQueue', messageQueue);\n\ndelete msg.payload;\n\nreturn msg;",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 740,
        "y": 360,
        "wires": [
            [
                "f4d0bfed3d6727e6",
                "5f817b78b5dfe714"
            ]
        ]
    },
    {
        "id": "3b7490b20fbb7087",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "output response",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 710,
        "y": 280,
        "wires": []
    },
    {
        "id": "bd4fd4d1e09d770b",
        "type": "http response",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "HTTP RESP 0",
        "statusCode": "",
        "headers": {},
        "x": 1440,
        "y": 280,
        "wires": []
    },
    {
        "id": "74c06399d74963b0",
        "type": "link out",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": " BetInputCheck Ph1 : OUT : Transform1 : Split Messages > Line Type Sorter",
        "mode": "link",
        "links": [
            "6d7830c85b50c511"
        ],
        "x": 1445,
        "y": 360,
        "wires": []
    },
    {
        "id": "f4d0bfed3d6727e6",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "Debug POST",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1080,
        "y": 300,
        "wires": []
    },
    {
        "id": "5f817b78b5dfe714",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "EXTRACT 2: Wait for 2 Bets",
        "func": "// Function: EXTRACT 2: Wait for 2 Bets\n// ID: 5f817b78b5dfe714\n// Outputs: 1\n// No Error: 0\n//\n// MODIFIED: Removed buffering logic, implemented immediate passthrough with data enhancement\n// Original: EXTRACT 2: Wait for 2 Bets (v1.0.0)\n// New: Immediate processing with enhanced data structure (v2.0.0)\n//\n// Edit this file, then run: python node_red_function_converter.py --update\n\n// Main function: Process single bet immediately with data enhancement\nvar incomingMessage = msg;\n\n// Debug logging to see what we're receiving\nnode.log(\"EXTRACT 2 Debug - Message structure:\");\nnode.log(\"  incomingMessage:\", incomingMessage ? \"exists\" : \"missing\");\nnode.log(\"  incomingMessage.scrapeResults:\", incomingMessage && incomingMessage.scrapeResults ? \"exists\" : \"missing\");\nnode.log(\"  incomingMessage.fullBet:\", incomingMessage && incomingMessage.fullBet ? \"exists\" : \"missing\");\nif (incomingMessage) {\n    node.log(\"  incomingMessage keys:\", Object.keys(incomingMessage));\n}\n\n// Validate incoming message structure\nif (!incomingMessage || !incomingMessage.scrapeResults || !incomingMessage.fullBet) {\n    node.error(\"Invalid message structure received - missing scrapeResults or fullBet\");\n    return null;\n}\n\n// Validate scraped data structure\nif (!incomingMessage.scrapeResults.scraped_team1 || !incomingMessage.scrapeResults.scraped_team2) {\n    node.error(\"Invalid scraped data structure - missing team1 or team2\");\n    return null;\n}\n\n// Create enhanced message with both scraped and original data\nvar enhancedMessage = {\n    ...incomingMessage,\n    \n    // Add processing indicators\n    isSingleBet: true,\n    processedAt: Date.now(),\n    version: \"2.0.0\",\n    \n    // Preserve original fullBet data completely\n    fullBet: {\n        ...incomingMessage.fullBet\n    },\n    \n    // Preserve original scrapeResults data completely\n    scrapeResults: {\n        ...incomingMessage.scrapeResults\n    },\n    \n    // Add enhanced data structure for calculators\n    enhancedData: {\n        // Team 1 enhanced data\n        team1: {\n            original: {\n                team: incomingMessage.fullBet.bet1.team1,\n                book: incomingMessage.fullBet.bet1.book1,\n                line: incomingMessage.fullBet.bet1.line1PointsAmFloat,\n                price: incomingMessage.fullBet.bet1.line1PriceAm\n            },\n            scraped: {\n                team: incomingMessage.scrapeResults.scraped_team1,\n                book: incomingMessage.scrapeResults.scraped_book1,\n                line: incomingMessage.scrapeResults.scraped_line1PointsAmFloat,\n                price: incomingMessage.scrapeResults.scraped_line1PriceAm\n            }\n        },\n        \n        // Team 2 enhanced data\n        team2: {\n            original: {\n                team: incomingMessage.fullBet.bet2.team2,\n                book: incomingMessage.fullBet.bet2.book2,\n                line: incomingMessage.fullBet.bet2.line2PointsAmFloat,\n                price: incomingMessage.fullBet.bet2.line2PriceAm\n            },\n            scraped: {\n                team: incomingMessage.scrapeResults.scraped_team2,\n                book: incomingMessage.scrapeResults.scraped_book2,\n                line: incomingMessage.scrapeResults.scraped_line2PointsAmFloat,\n                price: incomingMessage.scrapeResults.scraped_line2PriceAm\n            }\n        },\n        \n        // Game information\n        game: {\n            sport: incomingMessage.scrapeResults.scraped_sport,\n            league: incomingMessage.scrapeResults.scraped_league,\n            gameNumber: incomingMessage.scrapeResults.scraped_game_number,\n            lineType: incomingMessage.scrapeResults.scraped_linetype\n        }\n    }\n};\n\n// MAPPING LAYER: Create transform1Message structure for original calculation functions\n// This maps enhanced data structure to the format expected by original v1.0.0 functions\nenhancedMessage.transform1Message = enhancedMessage.transform1Message || {};\n\nenhancedMessage.transform1Message.scraped_bet_1 = {\n    scraped_sport: enhancedMessage.enhancedData.game.sport,\n    scraped_lineType: enhancedMessage.enhancedData.game.lineType,\n    scraped_team: enhancedMessage.enhancedData.team1.scraped.team,\n    scraped_book: enhancedMessage.enhancedData.team1.scraped.book,\n    scraped_points: enhancedMessage.enhancedData.team1.scraped.line,\n    scraped_odds: enhancedMessage.enhancedData.team1.scraped.price,\n    scraped_line: enhancedMessage.enhancedData.team1.scraped.line\n};\n\nenhancedMessage.transform1Message.scraped_bet_2 = {\n    scraped_sport: enhancedMessage.enhancedData.game.sport,\n    scraped_lineType: enhancedMessage.enhancedData.game.lineType,\n    scraped_team: enhancedMessage.enhancedData.team2.scraped.team,\n    scraped_book: enhancedMessage.enhancedData.team2.scraped.book,\n    scraped_points: enhancedMessage.enhancedData.team2.scraped.line,\n    scraped_odds: enhancedMessage.enhancedData.team2.scraped.price,\n    scraped_line: enhancedMessage.enhancedData.team2.scraped.line\n};\n\n// Add sport and lineType at root level for compatibility\nenhancedMessage.transform1Message.Sport = enhancedMessage.enhancedData.game.sport;\nenhancedMessage.transform1Message.scraped_lineType = enhancedMessage.enhancedData.game.lineType;\nenhancedMessage.transform1Message.scraped_sport = enhancedMessage.enhancedData.game.sport;\n\n// Log the enhanced processing\nnode.log(`Enhanced single bet processing: ${incomingMessage.scrapeResults.scraped_team1} vs ${incomingMessage.scrapeResults.scraped_team2}`);\nnode.log(`Scraped lines: ${incomingMessage.scrapeResults.scraped_line1PointsAmFloat} / ${incomingMessage.scrapeResults.scraped_line2PointsAmFloat}`);\nnode.log(`Scraped prices: ${incomingMessage.scrapeResults.scraped_line1PriceAm} / ${incomingMessage.scrapeResults.scraped_line2PriceAm}`);\nnode.log(`MAPPING: Created transform1Message.scraped_bet_1 and scraped_bet_2 for original calculation functions`);\n\n// Debug logging to see what the mapping layer is creating\nnode.log(`MAPPING DEBUG - transform1Message.scraped_bet_1.scraped_sport: ${enhancedMessage.transform1Message.scraped_bet_1.scraped_sport}`);\nnode.log(`MAPPING DEBUG - transform1Message.scraped_bet_1.scraped_lineType: ${enhancedMessage.transform1Message.scraped_bet_1.scraped_lineType}`);\nnode.log(`MAPPING DEBUG - transform1Message.scraped_bet_1.scraped_team: ${enhancedMessage.transform1Message.scraped_bet_1.scraped_team}`);\n\n// Send enhanced message immediately (no buffering, no waiting)\nnode.send(enhancedMessage);\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 4,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1130,
        "y": 360,
        "wires": [
            [
                "74c06399d74963b0",
                "fb5587b589c5cd32"
            ]
        ]
    },
    {
        "id": "fb5587b589c5cd32",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "Debug 2 Bets",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1400,
        "y": 320,
        "wires": []
    },
    {
        "id": "24c74fc74752908c",
        "type": "websocket in",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "/ws/BetInputCheck",
        "server": "df8a615d6d2cd2e7",
        "client": "",
        "x": 240,
        "y": 300,
        "wires": [
            [
                "054adb80f90a06e5"
            ]
        ]
    },
    {
        "id": "054adb80f90a06e5",
        "type": "json",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 480,
        "y": 320,
        "wires": [
            [
                "3b7490b20fbb7087",
                "272b6d76a23994ba"
            ]
        ]
    },
    {
        "id": "9d42e07bd472374f",
        "type": "comment",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Outputs one at a time",
        "info": "",
        "x": 480,
        "y": 720,
        "wires": []
    },
    {
        "id": "aab5da598ff97b79",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: LineType Sorter",
        "func": "// Function: Transform 1: LineType Sorter\n// ID: aab5da598ff97b79\n// Outputs: 3\n// No Error: 0\n//\n// Edit this file, then run: python node_red_function_converter.py --update\n//\n\n// Main function:\nvar incomingMessage = msg;\n\n// Debug logging to confirm LineType Sorter is being executed\nnode.log(\"LineType Sorter: Function executed - processing message\");\n//--------------------------------------\n// OUTPUT TO LINE TYPE CALCULATORS\n// Define output names and their corresponding indexes\nconst outputMapping = {\n    \"POINTSPREAD\": 0,\n    \"TOTAL\": 1,\n    \"MONEYLINE\": 2,\n    // Add more output names and indexes as needed\n};\n\nlet outputIndex;\n\nfunction outputMappedSend(currentResult, outputIndex) {\n    // Create an array to store messages for each output, initialized with null values\n    const outputs = Array(Object.keys(outputMapping).length).fill(null);\n\n    // Construct a new message object for the output\n    var outputMessage = {\n        req: incomingMessage.req,\n        res: incomingMessage.res,\n        transform1Message: incomingMessage.transform1Message || currentResult,\n        extractMessage: incomingMessage.extractMessage,\n        fullMessage: incomingMessage.fullMessage\n    };\n    delete outputMessage.transform1Message.extractMessage;\n    delete outputMessage.transform1Message.req;\n    delete outputMessage.transform1Message.res;\n\n    // Ensure the extractMessage doesn't carry over unnecessary properties\n    if (outputMessage.extractMessage) {\n        // Clean up if needed\n    }\n\n    // Assign the new message to the appropriate output based on the index\n    outputs[outputIndex] = outputMessage;\n\n    // Send the messages. Only the targeted output index will have a non-null message.\n    node.send(outputs);\n}\n\n//------------\n//SWITCH\n\nlet currentResult = incomingMessage;\n\n// Determine the index of the desired output based on the LineType\n// CRITICAL: Check message structure before accessing LineType\nlet lineType;\n\n// Debug logging to see what we're receiving\nnode.log(\"LineType Sorter Debug - Message structure:\");\nnode.log(\"  incomingMessage.scrapeResults:\", incomingMessage.scrapeResults ? \"exists\" : \"missing\");\nnode.log(\"  incomingMessage.transform1Message:\", incomingMessage.transform1Message ? \"exists\" : \"missing\");\nif (incomingMessage.transform1Message && incomingMessage.transform1Message.scraped_bet_1) {\n    node.log(\"  incomingMessage.transform1Message.scraped_bet_1:\", \"exists\");\n    node.log(\"  scraped_lineType:\", incomingMessage.transform1Message.scraped_bet_1.scraped_lineType);\n}\nif (incomingMessage.scrapeResults && incomingMessage.scrapeResults.scraped_lineType) {\n    lineType = incomingMessage.scrapeResults.scraped_lineType;\n} else if (incomingMessage.scraped_bet_1 && incomingMessage.scraped_bet_1.scraped_lineType) {\n    lineType = incomingMessage.scraped_bet_1.scraped_lineType;\n} else if (incomingMessage.transform1Message && incomingMessage.transform1Message.scraped_bet_1 && incomingMessage.transform1Message.scraped_bet_1.scraped_lineType) {\n    lineType = incomingMessage.transform1Message.scraped_bet_1.scraped_lineType;\n} else {\n    node.warn('Unknown LineType: No lineType found in message structure');\n    return;\n}\n\nswitch (lineType) {\n    case 'POINTSPREAD':\n        outputIndex = outputMapping[\"POINTSPREAD\"];\n        outputMappedSend(currentResult, outputIndex);\n        break;\n    case 'TOTAL':\n        outputIndex = outputMapping[\"TOTAL\"];\n        outputMappedSend(currentResult, outputIndex);\n        break;\n    case 'MONEYLINE':\n        outputIndex = outputMapping[\"MONEYLINE\"];\n        outputMappedSend(currentResult, outputIndex);\n        break;\n    default:\n        // Handle default case (optional)\n        node.warn('Unknown LineType: ');\n}",
        "outputs": 3,
        "timeout": "",
        "noerr": 6,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 410,
        "y": 660,
        "wires": [
            [
                "b4dca9fd7958c13f",
                "12551b69148dc875"
            ],
            [
                "18ee888a0e0c3587"
            ],
            [
                "740d874372634aa9"
            ]
        ],
        "outputLabels": [
            "POINTSPREAD",
            "TOTAL",
            "MONEYLINE"
        ]
    },
    {
        "id": "6d7830c85b50c511",
        "type": "link in",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": " BetInputCheck Ph2: IN : Transform1 : Split Messages > Line Type Sorter",
        "links": [
            "74c06399d74963b0"
        ],
        "x": 155,
        "y": 660,
        "wires": [
            [
                "aab5da598ff97b79"
            ]
        ]
    },
    {
        "id": "b4dca9fd7958c13f",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Pointspread",
        "func": "// Function: Transform 1: Pointspread (Modified for v2.0.0)\n// ID: b4dca9fd7958c13f\n// Outputs: 1\n// No Error: 7\n//\n// MODIFIED: Handle single bet instead of paired bets\n// Original: Paired bet processing (v1.0.0)\n// New: Single bet processing with preserved calculation logic (v2.0.0)\n//\n// Edit this file, then run: python node_red_function_converter.py --update\n\n// Main function: Process single bet with preserved calculation logic\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nif (!SportsSettingsVar) {\n    node.error('SportsSettings not found in global context');\n    return;\n}\nvar transform1Message = incomingMessageVar.transform1Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n// Handle single bet (v2.0.0) - check if it's a single bet or paired bet\nvar isSingleBet = transform1Message.isSingleMessage || !transform1Message.scraped_bet_2;\n\nif (isSingleBet) {\n    // Single bet processing (v2.0.0)\n    main.sport = transform1Message.scraped_bet_1['scraped_sport'];\n    main.isSingleBet = true;\n} else {\n    // Paired bet processing (v1.0.0 - preserved for compatibility)\n    main.sport = transform1Message.scraped_bet_1['scraped_sport'];\n    main.isSingleBet = false;\n}\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n// Function to convert scraped_points to an integer if it is a string\nfunction convertScrapedPoints(betKey) {\n    let scrapedPoints = transform1Message[betKey].scraped_points;\n    if (typeof scrapedPoints === 'string') {\n        scrapedPoints = parseInt(scrapedPoints, 10); // Convert to integer with base 10\n    }\n    transform1Message[betKey].scraped_points = scrapedPoints;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    // REPLACE HERE\n    convertScrapedPoints('scraped_bet_1');\n    convertScrapedPoints('scraped_bet_2');\n    main.PointspreadPointsDifference = transform1Message['scraped_bet_1'].scraped_points - transform1Message['scraped_bet_2'].scraped_points;\n    node.warn({ sport: main.sport });\n\n    main.psRangeMin = SportsSettingsVar[main.sport].psRangeMin;\n    main.psRangeMax = SportsSettingsVar[main.sport].psRangeMax;\n\n    // Calculate Range Rating\n    main.PointspreadPointsDifferenceRating = main.PointspreadPointsDifference / main.psRangeMax;\n\n    return;\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        // REPLACE HERE\n        main.line[i] = transform1Message[`scraped_bet_${i}`];\n        main.line[i].lineValue = transform1Message[`scraped_bet_${i}`][`scraped_odds`];\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return;\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return;\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk);\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.PointspreadPointsDifference >= main.psRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }\n    // B: If Arb Less than Range min && greater than 0\n    else if (main.PointspreadPointsDifference < main.psRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min && less than 5% Arb && more than 15\n    else if (main.PointspreadPointsDifference < main.psRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return;\n}\n\nfunction calculateStake(globalStake) {\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n\n// NEW FUNCTION: Single bet processing (v2.0.0)\nfunction calculateSingleBetMetrics() {\n    // Process single bet with BOTH lines (original + scraped) - immediate processing\n    var bet1 = transform1Message.scraped_bet_1;\n    \n    // Initialize BOTH lines for single bet processing\n    main.line[1] = {};\n    main.line[2] = {};\n    \n    // Line 1: Original bet data (from fullBet)\n    main.line[1].lineValue = parseFloat(transform1Message.fullBet.line);\n    main.line[1].price = parseFloat(transform1Message.fullBet.odds);\n    main.line[1].team = transform1Message.fullBet.team;\n    main.line[1].book = transform1Message.fullBet.book;\n    \n    // Line 2: Scraped bet data (from scraped_bet_1)\n    main.line[2].lineValue = parseFloat(bet1.scraped_line);\n    main.line[2].price = parseFloat(bet1.scraped_odds);\n    main.line[2].team = bet1.scraped_team;\n    main.line[2].book = bet1.scraped_book;\n    \n    // Calculate metrics for both lines\n    [1, 2].forEach(lineNum => {\n        main.line[lineNum].decimalOdds = americanToDecimal(main.line[lineNum].price);\n        main.line[lineNum].impliedProbability = 1 / main.line[lineNum].decimalOdds;\n        main.line[lineNum].vig = calculateVig(main.line[lineNum].price);\n        main.line[lineNum].risk = 100; // Standard risk amount\n        main.line[lineNum].win = calculateWin(main.line[lineNum].price, main.line[lineNum].risk);\n        main.line[lineNum].takeback = main.line[lineNum].risk + main.line[lineNum].win;\n    });\n    \n    // Calculate line difference for single bet\n    main.PointspreadPointsDifference = Math.abs(main.line[1].lineValue - main.line[2].lineValue);\n    \n    // Set single bet indicators\n    main.BetType = \"SINGLEBET\";\n    main.isSingleBet = true;\n    main.singleBetMetrics = {\n        line1: {\n            lineValue: main.line[1].lineValue,\n            price: main.line[1].price,\n            team: main.line[1].team,\n            book: main.line[1].book,\n            risk: main.line[1].risk,\n            win: main.line[1].win,\n            takeback: main.line[1].takeback,\n            vig: main.line[1].vig\n        },\n        line2: {\n            lineValue: main.line[2].lineValue,\n            price: main.line[2].price,\n            team: main.line[2].team,\n            book: main.line[2].book,\n            risk: main.line[2].risk,\n            win: main.line[2].win,\n            takeback: main.line[2].takeback,\n            vig: main.line[2].vig\n        },\n        pointsDifference: main.PointspreadPointsDifference\n    };\n    \n    // Log single bet processing with both lines\n    node.log(`Single bet processed: ${main.line[1].team} ${main.line[1].lineValue} vs ${main.line[2].team} ${main.line[2].lineValue} (diff: ${main.PointspreadPointsDifference})`);\n}\n\n//-----\n// EXECUTE\nif (isSingleBet) {\n    // Single bet processing (v2.0.0)\n    calculateSingleBetMetrics();\n} else {\n    // Paired bet processing (v1.0.0 - preserved)\n    calculatePointsRange();\n    calculateLineDifference();\n    calculateOutcomes();\n    calculateBetType();\n    calculateStake(globalStake);\n}\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform1Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 9,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 640,
        "wires": [
            [
                "b753d113f1e07d62",
                "aa6c72150d31fb90"
            ]
        ]
    },
    {
        "id": "12551b69148dc875",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Debug PspreadSorter",
        "active": true,
        "tosidebar": true,
        "console": true,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 820,
        "y": 600,
        "wires": []
    },
    {
        "id": "18ee888a0e0c3587",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Totals",
        "func": "// Function: Transform 1: Totals (Modified for v2.0.0)\n// ID: 18ee888a0e0c3587\n// Outputs: 1\n// No Error: 7\n//\n// MODIFIED: Handle single bet instead of paired bets\n// Original: Paired bet processing (v1.0.0)\n// New: Single bet processing with preserved calculation logic (v2.0.0)\n//\n// Edit this file, then run: python node_red_function_converter.py --update\n\n// Main function: Process single bet with preserved calculation logic\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform1Message = incomingMessageVar.transform1Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n// Handle single bet (v2.0.0) - check if it's a single bet or paired bet\nvar isSingleBet = transform1Message.isSingleMessage || !transform1Message.scraped_bet_2;\n\nif (isSingleBet) {\n    // Single bet processing (v2.0.0)\n    main.sport = transform1Message.scraped_bet_1['scraped_sport'];\n    main.isSingleBet = true;\n} else {\n    // Paired bet processing (v1.0.0 - preserved for compatibility)\n    main.sport = transform1Message['Sport'];\n    main.isSingleBet = false;\n}\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n// Function to convert scraped_points to an integer if it is a string\nfunction convertScrapedPoints(betKey) {\n    let scrapedPoints = transform1Message[betKey].scraped_points;\n    if (typeof scrapedPoints === 'string') {\n        scrapedPoints = parseInt(scrapedPoints, 10); // Convert to integer with base 10\n    }\n    transform1Message[betKey].scraped_points = scrapedPoints;\n}\n\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    // REPLACE HERE\n    convertScrapedPoints('scraped_bet_1');\n    convertScrapedPoints('scraped_bet_2');\n    main.TotalsPointsDifference = transform1Message['scraped_bet_1'].scraped_points + transform1Message['scraped_bet_2'].scraped_points;\n\n    main.totalsRangeMin = SportsSettingsVar[main.sport].totalsRangeMin;\n    main.totalsRangeMax = SportsSettingsVar[main.sport].totalsRangeMax;\n\n    // Calculate Range Rating\n    main.TotalsPointsDifferenceRating = main.TotalsPointsDifference / main.totalsRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        // REPLACE HERE\n        main.line[i] = transform1Message[`scraped_bet_${i}`];\n        main.line[i].lineValue = transform1Message[`scraped_bet_${i}`][`scraped_odds`];\n\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.TotalsPointsDifference >= main.totalsRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MIDDLEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.TotalsPointsDifference < main.totalsRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.TotalsPointsDifference < main.totalsRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n\n// NEW FUNCTION: Single bet processing (v2.0.0)\nfunction calculateSingleBetMetrics() {\n    // Process single bet with preserved calculation logic\n    var bet1 = transform1Message.scraped_bet_1;\n    \n    // Initialize single bet line\n    main.line[1] = {};\n    main.line[1].lineValue = parseFloat(bet1.scraped_line);\n    main.line[1].price = parseFloat(bet1.scraped_odds);\n    main.line[1].team = bet1.scraped_team;\n    main.line[1].book = bet1.scraped_book;\n    \n    // Calculate basic metrics for single bet\n    main.line[1].decimalOdds = americanToDecimal(main.line[1].price);\n    main.line[1].impliedProbability = 1 / main.line[1].decimalOdds;\n    main.line[1].vig = calculateVig(main.line[1].price);\n    \n    // Calculate risk/win for single bet\n    main.line[1].risk = 100; // Standard risk amount\n    main.line[1].win = calculateWin(main.line[1].price, main.line[1].risk);\n    main.line[1].takeback = main.line[1].risk + main.line[1].win;\n    \n    // Set single bet indicators\n    main.BetType = \"SINGLEBET\";\n    main.isSingleBet = true;\n    main.singleBetMetrics = {\n        lineValue: main.line[1].lineValue,\n        price: main.line[1].price,\n        team: main.line[1].team,\n        book: main.line[1].book,\n        risk: main.line[1].risk,\n        win: main.line[1].win,\n        takeback: main.line[1].takeback,\n        vig: main.line[1].vig,\n        decimalOdds: main.line[1].decimalOdds,\n        impliedProbability: main.line[1].impliedProbability\n    };\n    \n    // Log single bet processing\n    node.log(`Single bet processed: ${main.line[1].team} ${main.line[1].lineValue} ${main.line[1].price}`);\n}\n//-----\n// EXECUTE\nif (isSingleBet) {\n    // Single bet processing (v2.0.0)\n    calculateSingleBetMetrics();\n} else {\n    // Paired bet processing (v1.0.0 - preserved)\n    calculatePointsRange();\n    calculateLineDifference();\n    calculateOutcomes();\n    calculateBetType();\n    calculateStake(globalStake);\n}\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform1Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 28,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 800,
        "y": 680,
        "wires": [
            [
                "aa6c72150d31fb90"
            ]
        ]
    },
    {
        "id": "740d874372634aa9",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Moneyline",
        "func": "// Function: Transform 1: Moneyline (Modified for v2.0.0)\n// ID: 740d874372634aa9\n// Outputs: 1\n// No Error: 7\n//\n// MODIFIED: Handle single bet instead of paired bets\n// Original: Paired bet processing (v1.0.0)\n// New: Single bet processing with preserved calculation logic (v2.0.0)\n//\n// Edit this file, then run: python node_red_function_converter.py --update\n\n// Main function: Process single bet with preserved calculation logic\nvar incomingMessageVar = msg;\nvar SportsSettingsVar = context.global.get('SportsSettings');\nvar transform1Message = incomingMessageVar.transform1Message;\nvar main = {};\nvar vigMax = 5;\nvar globalStake = 100;\nvar arbMin = .05;\nvar arbMax = .07;\n\n// Handle single bet (v2.0.0) - check if it's a single bet or paired bet\nvar isSingleBet = transform1Message.isSingleMessage || !transform1Message.scraped_bet_2;\n\nif (isSingleBet) {\n    // Single bet processing (v2.0.0)\n    main.sport = transform1Message.scraped_bet_1['scraped_sport'];\n    main.isSingleBet = true;\n} else {\n    // Paired bet processing (v1.0.0 - preserved for compatibility)\n    main.sport = transform1Message['Sport'];\n    main.isSingleBet = false;\n}\n\n// Initialize arrays to hold values for each line\nmain.line = {};\n\n//-----\n//SUBFUNCTIONS\nfunction americanToDecimal(americanOdds) {\n    // Ensure americanOdds is a number\n    americanOdds = parseFloat(americanOdds);\n\n    // Check if americanOdds is a valid number\n    if (isNaN(americanOdds)) {\n        throw new Error(\"Invalid input. Please provide a valid number for American odds.\");\n    }\n\n    // Convert American odds to decimal odds\n    let decimalOdds;\n    if (americanOdds >= 100) {\n        decimalOdds = (americanOdds / 100) + 1;\n    } else {\n        decimalOdds = (100 / Math.abs(americanOdds)) + 1;\n    }\n\n    return decimalOdds.toFixed(3); // Round to 3 decimal places for precision\n}\n\nfunction calculateArbitrage(oddsOutcome1, oddsOutcome2, globalStake) {\n    let line1Value = americanToDecimal(oddsOutcome1);\n    let line2Value = americanToDecimal(oddsOutcome2);\n\n\n    // Convert string to float for safety\n    oddsOutcome1 = parseFloat(line1Value);\n    oddsOutcome2 = parseFloat(line2Value);\n\n    // Determine the lowest odds and calculate stakes\n    let riskForLowestOdds = globalStake; // The stake for the outcome with the lowest odds is set to $100\n    let lowestOdds = Math.min(oddsOutcome1, oddsOutcome2);\n    let highestOdds = Math.max(oddsOutcome1, oddsOutcome2);\n\n\n    // Calculate Arbitrage Percentage\n    let arbPercentageTotal = (1 / oddsOutcome1 + 1 / oddsOutcome2) * 100;\n\n    let result = {}; // Initialize the result object\n\n    // Determine If There Is an Arbitrage Opportunity\n    if (arbPercentageTotal < 100) {\n        // Adjust the other stake proportionally to maintain arbitrage\n        let riskOnHighestOdds = (lowestOdds / highestOdds) * riskForLowestOdds;\n\n        // Round stakes to the nearest dollar\n        let roundedRiskOnLowestOdds = Math.round(riskForLowestOdds);\n        let roundedRiskOnHighestOdds = Math.round(riskOnHighestOdds);\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let totalRoundedStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate total required stake to maintain arbitrage proportions\n        let ArbTotalStake = roundedRiskOnLowestOdds + roundedRiskOnHighestOdds;\n\n        // Calculate potential returns for each bet\n        let returnOnLowestOdds = roundedRiskOnLowestOdds * lowestOdds;\n        let returnOnHighestOdds = roundedRiskOnHighestOdds * highestOdds;\n\n        // Calculate profits for each outcome by subtracting the total stake from the returns of each outcome\n        let ArbProfit1 = returnOnLowestOdds - ArbTotalStake;\n        let ArbProfit2 = returnOnHighestOdds - ArbTotalStake;\n\n\n        // Populate the result object with values\n        result.ArbOpportunity = true;\n        result.ArbPercentage = 100 - arbPercentageTotal.toFixed(2);\n        result.ArbBetOnOutcome1 = roundedRiskOnLowestOdds.toFixed(2);\n        result.ArbBetOnOutcome2 = roundedRiskOnHighestOdds.toFixed(2);\n        result.ArbTotalStake = totalRoundedStake.toFixed(2);\n        result.ArbProfit1 = ArbProfit1.toFixed(2);\n        result.ArbProfit2 = ArbProfit2.toFixed(2);\n\n    } else {\n        // Indicate no arbitrage opportunity in the result object\n        result.ArbOpportunity = false;\n        result.message = \"No Arbitrage Opportunity.\";\n    }\n\n    return result;\n}\n\n// Function to convert scraped_points to an integer if it is a string\nfunction convertScrapedPoints(betKey) {\n    let scrapedPoints = transform1Message[betKey].scraped_points;\n    if (typeof scrapedPoints === 'string') {\n        scrapedPoints = parseInt(scrapedPoints, 10); // Convert to integer with base 10\n    }\n    transform1Message[betKey].scraped_points = scrapedPoints;\n}\n//-----\n// MAIN CALCULATIONS\nfunction calculatePointsRange() {\n    // Filter Range by Sports\n    // Calculate Limits\n    //REPLACE HERE\n    convertScrapedPoints('scraped_bet_1');\n    convertScrapedPoints('scraped_bet_2');\n    main.MoneylineDifference = transform1Message['scraped_bet_1'].scraped_points + transform1Message['scraped_bet_2'].scraped_points\n\n    main.moneylineRangeMin = SportsSettingsVar[main.sport].moneylineRangeMin;\n    main.moneylineRangeMax = SportsSettingsVar[main.sport].moneylineRangeMax;\n\n    // Calculate Range Rating\n    main.MoneylineDifferenceRating = main.MoneylineDifference / main.moneylineRangeMax;\n\n    return\n}\n\nfunction calculateLineDifference() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n    main.line = {};\n\n    // Iterate over each line\n    for (let i = 1; i <= 2; i++) {\n        // REPLACE HERE\n        main.line[i] = transform1Message[`scraped_bet_${i}`];\n        main.line[i].lineValue = transform1Message[`scraped_bet_${i}`][`scraped_odds`];\n\n        if (main.line[i].lineValue < 0) {\n            main.line[i].Risk = Math.abs(main.line[i].lineValue);\n            main.line[i].Win = 100;\n            main.line[i].Takeback = Math.abs(main.line[i].lineValue) + main.line[i].Win;\n            main.line[i].Lose = Math.abs(main.line[i].lineValue);\n            main.line[i].Vig = Math.abs(main.line[i].lineValue) - main.line[i].Win;\n        } else if (main.line[i].lineValue > 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = main.line[i].lineValue;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        } else if (main.line[i].lineValue === 0) {\n            main.line[i].Risk = 100;\n            main.line[i].Win = 100;\n            main.line[i].Takeback = main.line[i].Risk + main.line[i].Win;\n            main.line[i].Lose = main.line[i].Risk;\n            main.line[i].Vig = 0;\n        }\n\n    }\n    main.totalTakeback = main.line[1].Takeback + main.line[2].Takeback;\n    return\n}\n\nfunction calculateOutcomes() {\n    // Cases : Middle = Loss / Push\n    // -120 +140\n    // Pay 120 to win 100 / Pay 100 to win 140\n    // W1:-$0; L1:+$20 | W2:+$20; L2:$0\n\n    // +100 +120\n    // Pay 100 to win 100 / Pay 120 to win 140\n    // W1:+$0; L1:+$20 | W2:+$20; L2:+$0\n\n    // -110 -120\n    // Pay 110 to win 100 / Pay 120 to win 120\n    // W1:-$20; L1:-$10 | W2:-$10; L2:-$20  = DROP\n\n    main.W1 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L1 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.W2 = main.line[2].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.L2 = main.line[1].Takeback - main.line[1].Risk - main.line[2].Risk;\n    main.TotalVig = main.line[1].Vig + main.line[2].Vig;\n    return\n}\n\nfunction calculateBetType() {\n    // Middle / Vigsplit / Arb\n    // is it a good middle?\n    // is it a + vigsplit and - spread?\n    // is it a + 5% arb with low outlay?\n\n    // TO DO : \n    // 1. Calculate Arb\n    let risk = 100;\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, risk);\n\n    // 2. Calculate VigSplit\n    main.line1VSP = main.line[1].Win - main.line[1].Risk;\n    main.line2VSP = main.line[2].Win - main.line[2].Risk;\n    main.vigSplitProfit = main.line1VSP + main.line2VSP;\n    main.vigSplitProfitRate = main.vigSplitProfit / (main.line[1].Risk + main.line[2].Risk)\n    main.vigSplitTotalRisk = main.line[1].Risk + main.line[2].Risk;\n\n    // A: If high middle, take as middle\n    if (main.MoneylineDifference >= main.moneylineRangeMin\n        && main.TotalVig <= vigMax) {\n        main.BetType = \"MONEYLINEBET\";\n    }\n    // B: If Arb Less than Range min & greater than 0\n    else if (main.MoneylineDifference < main.moneylineRangeMin\n        && main.arbResults.ArbPercentage >= .05\n        && main.arbResults.ArbPercentage <= .15) {\n        main.BetType = \"ARBBET\";\n        //Take it.\n    }\n    // C: VIGSPLIT LAST RESORT : If less then Range Min & less than 5% Arb & more than 15\n    else if (main.MoneylineDifference < main.moneylineRangeMin\n        && main.arbResults.ArbPercentage < .05 && main.arbResults.vigSplitProfit > 15) {\n        main.BetType = \"VIGSPLITBET\";\n        //Take it.\n    }\n    else {\n        main.BetType = false;\n    }\n\n    return\n}\n\nfunction calculateStake(globalStake) {\n\n    main.arbResults = calculateArbitrage(main.line[1].lineValue, main.line[2].lineValue, globalStake);\n    if (main.BetType == \"MIDDLEBET\") {\n        main.line[1].stake = globalStake;\n        main.line[2].stake = globalStake;\n    }\n    else if (main.BetType == \"ARBITRAGEBET\") {\n        main.line[1].stake = (main.arbResults.ArbBetOnOutcome1 / 100) * globalStake;\n        main.line[2].stake = (main.arbResults.ArbBetOnOutcome2 / 100) * globalStake;\n    }\n    if (main.BetType == \"VIGSPLITBET\") {\n        main.line[1].stake = (main.line[1].risk / 100) * globalStake;\n        main.line[2].stake = (main.line[2].risk / 100) * globalStake;\n    }\n}\n//-----\n// EXECUTE\ncalculatePointsRange();\ncalculateLineDifference();\ncalculateOutcomes();\ncalculateBetType();\ncalculateStake(globalStake);\n\n//------\n// CONFIGURE MESSAGE\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.extractMessage = msg.extractMessage;\nmsg.transform1Message = incomingMessageVar.transform1Message;\nmsg.transformResults = main;\nmsg.req = incomingMessageVar.req;\nmsg.res = incomingMessageVar.res;\n\nfor (const [key, value] of Object.entries(msg.transformResults)) {\n    msg.transform1Message[key] = value;\n}\n\nnode.send(msg);\n\n// return msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 7,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 810,
        "y": 720,
        "wires": [
            [
                "aa6c72150d31fb90"
            ]
        ]
    },
    {
        "id": "b753d113f1e07d62",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Debug PSpread",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1120,
        "y": 640,
        "wires": []
    },
    {
        "id": "aa6c72150d31fb90",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Transform 1: Comparative Bets",
        "func": "// Function: Transform 1: Comparative Bets\n// ID: aa6c72150d31fb90\n// Outputs: 1\n// No Error: 15\n//\n// Edit this file, then run: python node_red_function_converter.py --update\n//\n\n// Main function:\n\nvar incomingMessage = msg;\nvar betIDVar = msg._msgid;\nvar resultCounter = 1\nvar main = {};\nvar tenPercentStake = 10;\nvar vigMax = 5;\nvar arbPercentageRangeMin = 4;\nvar vigSplitRangeMin = 15;\nvar moneylineRangeMin = 21;\n\n//===================================\n// 1. BUFFER FUNCTIONS\nfunction updateBufferWithIncomingMessage(incomingMessage) {\n    // Initialize a buffer object if it doesn't exist\n    if (!context.get(\"buffer\")) {\n        context.set(\"buffer\", {});\n    }\n\n    // Initialize a timeout object to keep track of message timeouts\n    if (!context.get(\"timeouts\")) {\n        context.set(\"timeouts\", {});\n    }\n\n    // Retrieve the buffer and timeouts objects\n    let buffer = context.get(\"buffer\");\n    let timeouts = context.get(\"timeouts\");\n    const timeoutDuration = 60000; // Timeout duration in milliseconds (1 minute)\n\n    // Extract the message ID from the incoming message\n    var betIDVar = incomingMessage.fullMessage._id;\n\n    // Ensure buffer entry exists for the current message ID and initialize it as an empty array if it doesn't\n    if (!buffer[betIDVar]) {\n        buffer[betIDVar] = {};\n        buffer[betIDVar].messages = [];\n    }\n\n    // Add the incoming message to the buffer array for this betIDVar\n    buffer[betIDVar].messages.push(incomingMessage);\n\n    // Persist the updated buffer\n    context.set(\"buffer\", buffer);\n\n    // Return the relevant variables for use outside the function\n    return {\n        buffer, // Updated buffer object\n        timeouts, // Updated timeouts object\n        betIDVar // The message ID variable\n    };\n}\n\n// Call the function to update the buffer with the incoming message and capture the returned values\nvar { buffer, timeouts, betIDVar } = updateBufferWithIncomingMessage(incomingMessage);\n\n// Now `buffer`, `timeouts`, and `betIDVar` are available for use outside the function.\n\n// Assuming cleanupBuffer function is implemented elsewhere\nfunction cleanupBuffer(betIDVar) {\n    let buffer = context.get(\"buffer\");\n    let timeouts = context.get(\"timeouts\");\n\n    delete buffer[betIDVar];\n    context.set(\"buffer\", buffer);\n\n    if (timeouts[betIDVar]) {\n        clearTimeout(timeouts[betIDVar]);\n        delete timeouts[betIDVar];\n        context.set(\"timeouts\", timeouts);\n    }\n}\n\n//=========================\n// CALCULATION FUNCTIONS\n// 4. figure out which is the original message\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit \n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n// General function to extract and sort messages by a specified property path\nfunction extractAndSortByProperty(messages, propertyPath) {\n    // Split the property path into parts for nested properties\n    const pathParts = propertyPath.split('.');\n\n    // Map and extract the specified property value, handling nested properties\n    const extractedValues = messages.map((message, index) => {\n        let value = message.transform1Message;\n        for (const part of pathParts) {\n            value = value ? value[part] : undefined;\n        }\n        return { messageIndex: index, value };\n    });\n\n    // Filter out any undefined values that may not exist for the specified property\n    const filteredValues = extractedValues.filter(item => item.value !== undefined);\n\n    // Sort the filtered array by the specified property in descending order\n    filteredValues.sort((a, b) => b.value - a.value);\n\n    return filteredValues;\n}\n\n\nfunction calculateComparison(){\n// Calculate Within  PointSpread , Totals, Moneyline\n    // a. if IncomingMessage._id = extractMessage._id\n    // b. if extractMessage._id bet Type == middle, arb, vigsplit\n    // c. compare vigsplit, arb, middle as +10% profit of the highest one (if doesn't exist, take it)\n    // d. check against final gating conditions of profitability.\n    // e. mark as SameGame = Clear\n\n    // -------------------\n\n    // Check if the incomingMessage.transform1Message is the main bet to compare all results\n    if (incomingMessage.transform1Message && incomingMessage.transform1Message._id == incomingMessage.extractMessage._id){\n        // Set Bet Type\n        main.BetType = incomingMessage.transform1Message.BetType; \n    }\n\n    // A: If MIDDLEBET\n    if (main.BetType == \"MIDDLEBET\"){\n\n        // Filter results by BetType\n        let middleBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"MIDDLEBET\"\n        );\n        // Check if it doesn't exist\n        if (middleBetMessages.length <= 0){\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else{\n            // Example: Sort by 'PointspreadPointsDifference'\n            let sortedByPointspread = extractAndSortByProperty(buffer[betIDVar].messages, 'PointspreadPointsDifference');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform1Message.PointspreadPointsDifference > sortedByPointspread[0])\n            {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else {\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // B: If ARBBET\n    if (main.BetType == \"ARBBET\") {\n       \n        // Filter results by BetType\n        let arbBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"ARBBET\"\n        );\n        // Check if it doesn't exist\n        if (arbBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        }\n        // If it exists, compare        \n        else {\n            // Example: Sort by nested 'arbResults.ArbPercentage'\n            let sortedByArbPercentage = extractAndSortByProperty(buffer[betIDVar].messages, 'arbResults.ArbPercentage');\n\n            // Example: Sort by nested 'arbResults.ArbProfit1'\n            let sortedByArbProfit1 = extractAndSortByProperty(buffer[betIDVar].messages, 'arbResults.ArbProfit1');\n\n            // Check if Points / Profit Margin is high enough\n            if (incomingMessage.transform1Message.arbResults.ArbPercentage > (sortedByArbPercentage[0] + 3) || incomingMessage.transform1Message.arbResults.ArbProfit1 > (sortedByArbProfit1[0] + tenPercentStake)) {\n                // If so , mark it clear\n                main.SameGame = \"Clear\";\n            } else{\n                // If not , mark it unclear\n                main.SameGame = \"Unclear\";\n            }\n        }\n    }\n    // C: If Vigsplitbet\n    if (main.BetType == \"VIGSPLITBET\") {\n\n        // Filter results by BetType\n        let vigsplitBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"VIGSPLITBET\"\n        );\n        // Check if it doesn't exist\n        if (vigsplitBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n        // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n    // D: If Vigsplitbet\n    if (main.BetType == \"MONEYLINEBET\") {\n\n        // Filter results by BetType\n        let moneylineBetMessages = buffer[betIDVar].messages.filter(message =>\n            message.transform1Message && message.transform1Message.BetType === \"MONEYLINEBET\"\n        );\n        // Check if it doesn't exist\n        if (moneylineBetMessages.length <= 0) {\n            main.SameGame = \"Clear\";\n        } else {\n            // If not , mark it unclear\n            main.SameGame = \"Unclear\";\n        }\n    }\n}\n\nfunction calculateProfit() {\n\n    // CHECK MIDDLEBET\n    if (incomingMessage.transform1Message.BetType == \"MIDDLEBET\"){\n        if (incomingMessage.transform1Message.PointspreadPointsDifference >= incomingMessage.transform1Message.psRangeMin)\n        {main.profitCheck = true;}\n        else{ main.profitCheck = false;}\n    }\n    // CHECK ARBBET\n    else if(incomingMessage.transform1Message.BetType == \"ARBBET\"){\n        if (incomingMessage.transform1Message.arbResults.ArbPercentage >= arbPercentageRangeMin)\n        { main.profitCheck = true; }\n        else { main.profitCheck = false; }      \n    }\n    // CHECK VIGSPLITBET\n    else if (incomingMessage.transform1Message.BetType == \"VIGSPLITBET\"){\n        if (incomingMessage.transform1Message.vigSplitProfit >= vigSplitRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK MONEYLINEBET\n    else if (incomingMessage.transform1Message.BetType == \"MONEYLINEBET\") {\n        if (incomingMessage.transform1Message.moneylineDifference > moneylineRangeMin) { main.profitCheck = true; }\n        else { main.profitCheck = false; }\n    }\n    // CHECK VIGMAX\n    if (incomingMessage.transform1Message.TotalVig > vigMax){\n        main.profitCheck = false;\n    }\n\n}\n\n\n//========================\n// EXECUTION FUNCTIONS\n\n// If we have collected resultCounter messages for this betIDVar, process them\nif (buffer[betIDVar].messages.length === resultCounter) {\n\n\n        clearTimeout(timeouts[betIDVar]); // Important to clear timeout\n        context.set(\"timeouts\", timeouts); // Persist timeouts changes\n\n        // CALCULATE HERE\n        calculateComparison();\n        calculateProfit();\n        \n        // ADD ALL KEYS\n        for (const [key, value] of Object.entries(main)) {\n            incomingMessage.transform1Message[key] = value;\n        }\n        \n        // Prep Message and Send\n        var newMsg = {...msg};\n        newMsg.extractMessage = msg.extractMessage;\n        newMsg.transform1Message = incomingMessage.transform1Message;\n        newMsg.transformResults = incomingMessage.transformResults;\n        newMsg.main = main;\n\n        // Send the combined message on\n        node.send(newMsg);\n\n        // Cleanup buffer and timeouts for this betIDVar\n        cleanupBuffer(betIDVar);\n\n}\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 15,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1170,
        "y": 700,
        "wires": [
            [
                "7f404f5ee3444148",
                "148caedec77ae2dc"
            ]
        ]
    },
    {
        "id": "148caedec77ae2dc",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": "Debug COMPARE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1440,
        "y": 640,
        "wires": []
    },
    {
        "id": "7f404f5ee3444148",
        "type": "link out",
        "z": "a073baad498bb284",
        "g": "bf94ecd062e4e70d",
        "name": " BetInputCheck Ph2 : OUT : Compare > Load: Pack to HTTP",
        "mode": "link",
        "links": [
            "2e4fb60325f287ea"
        ],
        "x": 1525,
        "y": 700,
        "wires": []
    },
    {
        "id": "844825e531e70a8c",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "907bb0adef74d85a",
        "name": "Load: Pack to HTTP",
        "func": "\nvar incomingMessage = msg;\n\n\n//===================================\nmsg.statusCode = 200; // Set HTTP status code to 200 OK\nmsg.headers = {\n    \"Content-Type\": \"application/json\" // Set Content-Type header to text/plain\n};\n// Skip the Sort\nmsg.payload = {\n    extractMessage: incomingMessage.extractMessage,\n    finalMessage: incomingMessage.transform2Message,\n    transform1Message: incomingMessage.transform1Message,\n    _msgid: incomingMessage._msgid,\n};\n//delete msg.req;\n//delete msg.res;\n//msg.req = incomingMessage.transform1Message.scraped_bet_2.req;\n//msg.res = incomingMessage.transform1Message.scraped_bet_2.res;\n\nvar req2 = incomingMessage.transform1Message.scraped_bet_1.req;\nvar res2 = incomingMessage.transform1Message.scraped_bet_1.res; \n\ndelete msg.transform1Message.req;\ndelete msg.transform1Message.res;\ndelete msg.transform1Message.scraped_bet_1.req;\ndelete msg.transform1Message.scraped_bet_1.res;\ndelete msg.transform1Message.scraped_bet_2.req;\ndelete msg.transform1Message.scraped_bet_2.res;\n\n//========================\n// EXECUTION FUNCTIONS\n\nnode.send(msg);\n\n//msg.req = req2;\n//msg.res = res2;\n\n//node.send(msg);\nreturn null\n\n//\n\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1140,
        "y": 880,
        "wires": [
            [
                "8e05a6c56f99c187",
                "37c361494a477963"
            ]
        ]
    },
    {
        "id": "8e05a6c56f99c187",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "907bb0adef74d85a",
        "name": "Debug RESPONSE",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": false,
        "complete": "true",
        "targetType": "full",
        "statusVal": "",
        "statusType": "auto",
        "x": 1460,
        "y": 820,
        "wires": []
    },
    {
        "id": "2e4fb60325f287ea",
        "type": "link in",
        "z": "a073baad498bb284",
        "g": "907bb0adef74d85a",
        "name": "BetInputCheck Ph3: IN : Compare > Load: Pack to HTTP",
        "links": [
            "7f404f5ee3444148"
        ],
        "x": 155,
        "y": 880,
        "wires": [
            [
                "844825e531e70a8c"
            ]
        ]
    },
    {
        "id": "37c361494a477963",
        "type": "websocket out",
        "z": "a073baad498bb284",
        "g": "907bb0adef74d85a",
        "name": "ws/BetInputCheck",
        "server": "df8a615d6d2cd2e7",
        "client": "",
        "x": 1460,
        "y": 880,
        "wires": []
    },
    {
        "id": "3172a5061aab2782",
        "type": "comment",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "BETINPUTCHECK : Full Pseudocode",
        "info": "// TO PARSE:\n\n// 1. BOOK > GAME NUMBER > TIME \n// 2. SPORTS > LEAGUE > TEAM\n// 3. POINTS > LINE >   \n// 4. CHECK WAIT FOR OTHER LINE\n// 5. CHECK FOR ACCEPTABLE RANGE OF PROFIT\n// 6. IF SO, GO AHEAD",
        "x": 280,
        "y": 220,
        "wires": []
    },
    {
        "id": "8dde91e674783ac8",
        "type": "comment",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "DO NODE RED A>B>C TRACKING COMMENTS",
        "info": "",
        "x": 720,
        "y": 220,
        "wires": []
    },
    {
        "id": "82f37f0f6985ba34",
        "type": "comment",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "GIVE IT LINETYPE",
        "info": "",
        "x": 1110,
        "y": 440,
        "wires": []
    },
    {
        "id": "596247ccc0b71a3c",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "Test 1",
        "func": "msg.payload = {\n    \"scrapeResults\": {\n        \"scraped_sport\": \"Football\",\n        \"scraped_linetype\": \"POINTSPREAD\",\n        \"scraped_team1\": \"NC Central\",\n        \"scraped_team2\": \"N. Carolina A & T\",\n        \"scraped_line1PointsAmFloat\": \"-3.5\",\n        \"scraped_line2PointsAmFloat\": \"6.5\",\n        \"scraped_line1PriceAm\": -110,\n        \"scraped_line2PriceAm\": 100,\n        \"scraped_book1\": \"Bovada\",\n        \"scraped_book2\": \"SBGGlobal\",\n        \"scraped_league\": \"CFB\",\n        \"scraped_game_number\": \"309225\",\n        \"scraped_timestamp\": \"2025-09-04T02:43:54.460Z\"\n    },\n    \"fullBet\": {\n        \"_id\": \"64fce07f596995d08bb77510\",\n        \"bet1\": {\n            \"team1\": \"NC Central\",\n            \"book1\": \"Bovada\",\n            \"line1PointsAmFloat\": 6.5,\n            \"line1PriceAm\": 100,\n            \"lineValue\": 100,\n            \"risk\": 100,\n            \"win\": 100,\n            \"takeback\": 200,\n            \"lose\": 100,\n            \"vig\": 0,\n            \"book1AccountAssigned\": \"Pointsbet_Rozz\",\n            \"usLineSpeed\": \"default\",\n            \"euLineSpeed\": \"default\"\n        },\n        \"bet2\": {\n            \"team2\": \"N. Carolina A & T\",\n            \"book2\": \"YouWager\",\n            \"line2PointsAmFloat\": -3,\n            \"line2PriceAm\": 120,\n            \"lineValue\": 120,\n            \"risk\": 100,\n            \"win\": 120,\n            \"takeback\": 220,\n            \"lose\": 100,\n            \"vig\": null,\n            \"book2AccountAssigned\": \"Youwager_Gouge\",\n            \"usLineSpeed\": \"default\",\n            \"euLineSpeed\": \"default\"\n        },\n        \"primaryBets\": {\n            \"status\": null,\n            \"Error\": null,\n            \"rabbitsFired\": null,\n            \"Lay\": null,\n            \"finalStatus\": null\n        },\n        \"rabbitLine1\": {\n            \"initiated\": null,\n            \"bookSelected\": null,\n            \"running\": null,\n            \"lineConfirmed\": null,\n            \"placingWager\": null,\n            \"wagerPlaced\": null,\n            \"finalWager\": null,\n            \"wagerPlacedTimestamp\": null,\n            \"betslip\": null\n        },\n        \"rabbitLine2\": {\n            \"initiated\": null,\n            \"bookSelected\": null,\n            \"running\": null,\n            \"lineConfirmed\": null,\n            \"placingWager\": null,\n            \"wagerPlaced\": null,\n            \"finalWager\": null,\n            \"wagerPlacedTimestamp\": null,\n            \"betslip\": null\n        },\n        \"Lay\": {\n            \"line\": null,\n            \"initiated\": null,\n            \"bookSelected\": null,\n            \"running\": null,\n            \"lineConfirmed\": null,\n            \"placingWager\": null,\n            \"wagerPlaced\": null,\n            \"finalWager\": null,\n            \"wagerPlacedTimestamp\": null,\n            \"betslip\": null\n        },\n        \"rawDBSID\": \"64fce07f596995d08bb77510\",\n        \"alertName\": \"Middle Alert\",\n        \"timeStamp\": \"2023-09-09T21:15:07.000Z\",\n        \"timeStampEST\": \"09/09/23 05:15:07pm\",\n        \"sport\": \"Football\",\n        \"league\": \"CFB\",\n        \"gameNumber\": \"309225\",\n        \"lineType\": \"POINTSPREAD\",\n        \"betType\": \"MIDDLEBET\",\n        \"pointsDifference\": 3.5,\n        \"psPointsDifference\": 3.5,\n        \"psRangeMin\": 1.5,\n        \"psRangeMax\": 6,\n        \"psPointsDifferenceRating\": 0.5833333333333334,\n        \"roughSum\": 220,\n        \"potentialProfitLowLeg\": 100,\n        \"potentialProfitHighLeg\": 120,\n        \"potentialProfitLine1\": 100,\n        \"potentialProfitLine2\": 120,\n        \"potentialProfitMiddle\": 220,\n        \"potentialCostLine1\": -100,\n        \"potentialCostLine2\": -100,\n        \"potentialLoss\": -200,\n        \"totalTakeback\": 420,\n        \"w1\": 0,\n        \"l1\": 20,\n        \"w2\": 20,\n        \"l2\": 0,\n        \"arbOpportunity\": null,\n        \"arbPercentage\": null,\n        \"arbBetOnOutcome1\": null,\n        \"arbBetOnOutcome2\": null,\n        \"arbTotalStake\": null,\n        \"arbProfit1\": null,\n        \"arbProfit2\": null,\n        \"middleVigRate\": 220,\n        \"totalVig\": 0,\n        \"middleVigMargin\": null,\n        \"vigSplitMargin\": null,\n        \"moneylineMargin\": null,\n        \"line1PriceAmTop\": 100,\n        \"line2PriceAmGUI\": 120,\n        \"line1Flag\": null,\n        \"line1FlagType\": null,\n        \"line1FlagCheckPassed\": null,\n        \"line1PriceConfirm\": null,\n        \"line2Flag\": null,\n        \"line2FlagType\": null,\n        \"line2FlagCheckPassed\": null,\n        \"line2PriceConfirm\": null,\n        \"sameGame\": \"Clear\",\n        \"confirmedBet1Time\": null,\n        \"confirmedBet1Points\": null,\n        \"confirmedBet1Line\": null,\n        \"confirmedBet1Slip\": null,\n        \"confirmedBet2Time\": null,\n        \"confirmedBet2Points\": null,\n        \"confirmedBet2Line\": null,\n        \"confirmedBet2Slip\": null,\n        \"confirmedbetType\": null,\n        \"confirmedPointsDifference\": null,\n        \"confirmedProfit\": null,\n        \"confirmedMargin\": null,\n        \"fastBookLocation\": \"default\",\n        \"conditionCheck\": null,\n        \"bet1Placed\": null,\n        \"bet2Placed\": null,\n        \"Error\": \"none\",\n        \"errorLine1PriceAm\": \"none\",\n        \"errorLine2PriceAm\": \"none\",\n        \"windowsLeft\": 720,\n        \"finalStatus\": null,\n        \"__v\": 0\n    }\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 470,
        "y": 380,
        "wires": [
            [
                "272b6d76a23994ba"
            ]
        ]
    },
    {
        "id": "9255709a121bbd33",
        "type": "inject",
        "z": "a073baad498bb284",
        "g": "9e02f8f5e79de5a0",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 240,
        "y": 380,
        "wires": [
            [
                "596247ccc0b71a3c"
            ]
        ]
    },
    {
        "id": "28eddc9efdf05bee",
        "type": "function",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "Test 1",
        "func": "var SportsSettingsVar = context.global.get('SportsSettings');\nmsg.payload = SportsSettingsVar;\n\nreturn msg",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 490,
        "y": 520,
        "wires": [
            [
                "cd9414575b2fd3df"
            ]
        ]
    },
    {
        "id": "a1342c8699ac314d",
        "type": "inject",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 320,
        "y": 520,
        "wires": [
            [
                "28eddc9efdf05bee"
            ]
        ]
    },
    {
        "id": "cd9414575b2fd3df",
        "type": "debug",
        "z": "a073baad498bb284",
        "g": "4126bd8cd63414e5",
        "name": "output response",
        "active": true,
        "tosidebar": true,
        "console": false,
        "tostatus": true,
        "complete": "payload",
        "targetType": "msg",
        "statusVal": "payload",
        "statusType": "auto",
        "x": 700,
        "y": 520,
        "wires": []
    },
    {
        "id": "1f92eed3352f8aa5",
        "type": "tab",
        "label": "BetInputCheck",
        "disabled": false,
        "info": "",
        "env": []
    },
    {
        "id": "14d05059c9c5dcb2",
        "type": "mongodb4-client",
        "name": "Cima Main Connection",
        "protocol": "mongodb",
        "hostname": "127.0.0.1",
        "port": "22000",
        "dbName": "CimaMain",
        "appName": "",
        "authSource": "admin",
        "authMechanism": "SCRAM-SHA-256",
        "tls": false,
        "tlsCAFile": "",
        "tlsCertificateKeyFile": "",
        "tlsInsecure": false,
        "connectTimeoutMS": "",
        "socketTimeoutMS": "0",
        "minPoolSize": "0",
        "maxPoolSize": "",
        "maxIdleTimeMS": "0",
        "uri": "mongodb://127.0.0.1:22000",
        "advanced": "{}",
        "uriTabActive": "tab-uri-advanced"
    },
    {
        "id": "f4f02f7b9a092dd3",
        "type": "function",
        "z": "1f92eed3352f8aa5",
        "g": "9e02f8f5e79de5a0",
        "name": "TEST JSON 1",
        "func": "msg.payload = {\n  scrapeResults: {\n    scraped_sport: \"Football\",\n    scraped_linetype: \"POINTSPREAD\",\n    scraped_line: \"6.5\",\n    scraped_points: \"6.5\",\n    scraped_odds: 100,\n    scraped_team: \"N. Carolina A & T\",\n    scraped_opponent: \"NC Central\",\n    scraped_league: \"CFB\",\n    scraped_game_number: \"309225\",\n    scraped_book: \"SBGGlobal\",\n    scraped_timestamp: \"2025-09-04T02:43:54.460Z\"\n  },\n  fullBet: {\n    _id: \"64fcde48596995d08bb7750e\",\n    bet1: {\n      team1: \"NC Central\",\n      book1: \"Bovada\",\n      line1PointsAmFloat: 6.5,\n      line1PriceAm: 100,\n      book1AccountAssigned: \"Sportsbetting_Chucky\",\n      usLineSpeed: \"2\",\n      euLineSpeed: \"default\",\n      expressServerCheck: \"default\",\n      cityServerCheck: \"default\",\n      rabbitChildCheck: \"default\"\n    },\n    bet2: {\n      team2: \"N. Carolina A & T\",\n      book2: \"SBGGlobal\",\n      line2PointsAmFloat: -3,\n      line2PriceAm: 115,\n      book2AccountAssigned: \"Betdsi_Chucky\",\n      usLineSpeed: \"2\",\n      euLineSpeed: \"default\",\n      expressServerCheck: \"default\",\n      cityServerCheck: \"default\",\n      childProcessCheck: \"default\"\n    },\n    primaryBets: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4a: \"default\",\n      Stage4b: \"default\",\n      Wager1Placed: \"default\",\n      Wager2Placed: \"default\"\n    },\n    Rabbit1: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4a: \"default\",\n      Stage4b: \"default\",\n      Wager1Placed: \"default\",\n      Wager2Placed: \"default\"\n    },\n    Rabbit2: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4a: \"default\",\n      Stage4b: \"default\",\n      Wager1Placed: \"default\",\n      Wager2Placed: \"default\"\n    },\n    Lay: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4: \"default\",\n      LayState: \"default\"\n    },\n    rawDBSID: \"64fcde48596995d08bb7750e\",\n    alertName: \"Middle Alert\",\n    timeStamp: \"2023-09-09T21:05:53.000Z\",\n    timeStampEST: \"09/09/23 05:05:53pm\",\n    betType: \"MIDDLEBET\",\n    pointsDifference: 3.5,\n    roughSum: 215,\n    potentialProfitLowLeg: 100,\n    potentialProfitHighLeg: 115,\n    potentialProfitLine1: 100,\n    potentialProfitLine2: 115,\n    potentialProfitMiddle: 215,\n    potentialCostLine1: -100,\n    potentialCostLine2: -100,\n    potentialLoss: -200,\n    middleVigRate: 215,\n    lineType: \"POINTSPREAD\",\n    sport: \"Football\",\n    league: \"CFB\",\n    gameNumber: \"309225\",\n    line1PriceAmTop: \"100\",\n    line2PriceAmGUI: \"115\",\n    line1FlagCheckPassed: \"default\",\n    line1PriceConfirm: \"default\",\n    line2FlagCheckPassed: \"default\",\n    line2PriceConfirm: \"default\",\n    middleVigMargin: \"default\",\n    vigSplitMargin: \"default\",\n    moneylineMargin: \"default\",\n    confirmedBet1Time: \"default\",\n    confirmedBet1Points: \"default\",\n    confirmedBet1Line: \"default\",\n    confirmedBet1Slip: \"default\",\n    confirmedBet2Time: \"default\",\n    confirmedBet2Points: \"default\",\n    confirmedBet2Line: \"default\",\n    confirmedBet2Slip: \"default\",\n    confirmedbetType: \"default\",\n    confirmedPointsDifference: \"default\",\n    confirmedProfit: \"default\",\n    confirmedMargin: \"default\",\n    fastBookLocation: \"US\",\n    conditionCheck: \"default\",\n    bet1Placed: \"default\",\n    bet2Placed: \"default\",\n    Error: \"none\",\n    errorLine1PriceAm: \"none\",\n    errorLine2PriceAm: \"none\",\n    windowsLeft: 707,\n    finalStatus: \"default\",\n    __v: 0\n  }\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 380,
        "y": 320,
        "wires": [
            [
                "272b6d76a23994ba"
            ]
        ]
    },
    {
        "id": "991f5a75c2dd331f",
        "type": "inject",
        "z": "1f92eed3352f8aa5",
        "g": "9e02f8f5e79de5a0",
        "name": "START INJECT",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": false,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "START",
        "payloadType": "str",
        "x": 200,
        "y": 320,
        "wires": [
            [
                "f4f02f7b9a092dd3",
                "14efe5eefe47b302"
            ]
        ]
    },
    {
        "id": "14efe5eefe47b302",
        "type": "function",
        "z": "1f92eed3352f8aa5",
        "g": "9e02f8f5e79de5a0",
        "name": "TEST JSON 2",
        "func": "msg.payload = {\n  scrapeResults: {\n    scraped_sport: \"FOOTBALL\",\n    scraped_linetype: \"POINTSPREAD\",\n    scraped_line: \"6.5\",\n    scraped_points: \"6.5\",\n    scraped_odds: 100,\n    scraped_team: \"N. Carolina A & T\",\n    scraped_opponent: \"NC Central\",\n    scraped_league: \"CFB\",\n    scraped_game_number: \"309225\",\n    scraped_book: \"SBGGlobal\",\n    scraped_timestamp: \"2025-09-04T02:43:54.460Z\"\n  },\n  fullBet: {\n    _id: \"64fcde48596995d08bb7750e\",\n    bet1: {\n      team1: \"NC Central\",\n      book1: \"Bovada\",\n      line1PointsAmFloat: 6.5,\n      line1PriceAm: 100,\n      book1AccountAssigned: \"Sportsbetting_Chucky\",\n      usLineSpeed: \"2\",\n      euLineSpeed: \"default\",\n      expressServerCheck: \"default\",\n      cityServerCheck: \"default\",\n      rabbitChildCheck: \"default\"\n    },\n    bet2: {\n      team2: \"N. Carolina A & T\",\n      book2: \"SBGGlobal\",\n      line2PointsAmFloat: -3,\n      line2PriceAm: 115,\n      book2AccountAssigned: \"Betdsi_Chucky\",\n      usLineSpeed: \"2\",\n      euLineSpeed: \"default\",\n      expressServerCheck: \"default\",\n      cityServerCheck: \"default\",\n      childProcessCheck: \"default\"\n    },\n    primaryBets: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4a: \"default\",\n      Stage4b: \"default\",\n      Wager1Placed: \"default\",\n      Wager2Placed: \"default\"\n    },\n    Rabbit1: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4a: \"default\",\n      Stage4b: \"default\",\n      Wager1Placed: \"default\",\n      Wager2Placed: \"default\"\n    },\n    Rabbit2: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4a: \"default\",\n      Stage4b: \"default\",\n      Wager1Placed: \"default\",\n      Wager2Placed: \"default\"\n    },\n    Lay: {\n      Stage1: \"default\",\n      Stage2: \"default\",\n      Stage3: \"default\",\n      Stage4: \"default\",\n      LayState: \"default\"\n    },\n    rawDBSID: \"64fcde48596995d08bb7750e\",\n    alertName: \"Middle Alert\",\n    timeStamp: \"2023-09-09T21:05:53.000Z\",\n    timeStampEST: \"09/09/23 05:05:53pm\",\n    betType: \"MIDDLEBET\",\n    pointsDifference: 3.5,\n    roughSum: 215,\n    potentialProfitLowLeg: 100,\n    potentialProfitHighLeg: 115,\n    potentialProfitLine1: 100,\n    potentialProfitLine2: 115,\n    potentialProfitMiddle: 215,\n    potentialCostLine1: -100,\n    potentialCostLine2: -100,\n    potentialLoss: -200,\n    middleVigRate: 215,\n    lineType: \"POINTSPREAD\",\n    sport: \"Football\",\n    league: \"CFB\",\n    gameNumber: \"309225\",\n    line1PriceAmTop: \"100\",\n    line2PriceAmGUI: \"115\",\n    line1FlagCheckPassed: \"default\",\n    line1PriceConfirm: \"default\",\n    line2FlagCheckPassed: \"default\",\n    line2PriceConfirm: \"default\",\n    middleVigMargin: \"default\",\n    vigSplitMargin: \"default\",\n    moneylineMargin: \"default\",\n    confirmedBet1Time: \"default\",\n    confirmedBet1Points: \"default\",\n    confirmedBet1Line: \"default\",\n    confirmedBet1Slip: \"default\",\n    confirmedBet2Time: \"default\",\n    confirmedBet2Points: \"default\",\n    confirmedBet2Line: \"default\",\n    confirmedBet2Slip: \"default\",\n    confirmedbetType: \"default\",\n    confirmedPointsDifference: \"default\",\n    confirmedProfit: \"default\",\n    confirmedMargin: \"default\",\n    fastBookLocation: \"US\",\n    conditionCheck: \"default\",\n    bet1Placed: \"default\",\n    bet2Placed: \"default\",\n    Error: \"none\",\n    errorLine1PriceAm: \"none\",\n    errorLine2PriceAm: \"none\",\n    windowsLeft: 707,\n    finalStatus: \"default\",\n    __v: 0\n  }\n};\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 360,
        "y": 380,
        "wires": [
            [
                "272b6d76a23994ba"
            ]
        ]
    }
]